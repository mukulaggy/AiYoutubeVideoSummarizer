/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ytdl-core";
exports.ids = ["vendor-chunks/ytdl-core"];
exports.modules = {

/***/ "(rsc)/./node_modules/ytdl-core/lib/cache.js":
/*!*********************************************!*\
  !*** ./node_modules/ytdl-core/lib/cache.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { setTimeout } = __webpack_require__(/*! timers */ \"timers\");\n\n// A cache that expires.\nmodule.exports = class Cache extends Map {\n  constructor(timeout = 1000) {\n    super();\n    this.timeout = timeout;\n  }\n  set(key, value) {\n    if (this.has(key)) {\n      clearTimeout(super.get(key).tid);\n    }\n    super.set(key, {\n      tid: setTimeout(this.delete.bind(this, key), this.timeout).unref(),\n      value,\n    });\n  }\n  get(key) {\n    let entry = super.get(key);\n    if (entry) {\n      return entry.value;\n    }\n    return null;\n  }\n  getOrSet(key, fn) {\n    if (this.has(key)) {\n      return this.get(key);\n    } else {\n      let value = fn();\n      this.set(key, value);\n      (async() => {\n        try {\n          await value;\n        } catch (err) {\n          this.delete(key);\n        }\n      })();\n      return value;\n    }\n  }\n  delete(key) {\n    let entry = super.get(key);\n    if (entry) {\n      clearTimeout(entry.tid);\n      super.delete(key);\n    }\n  }\n  clear() {\n    for (let entry of this.values()) {\n      clearTimeout(entry.tid);\n    }\n    super.clear();\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMveXRkbC1jb3JlL2xpYi9jYWNoZS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxRQUFRLGFBQWEsRUFBRSxtQkFBTyxDQUFDLHNCQUFROztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGFnZ3ltXFxPbmVEcml2ZVxcRGVza3RvcFxccHJvamVjdHNcXHlvdXR1YmVfc3VtbWFyaXplclxcbm9kZV9tb2R1bGVzXFx5dGRsLWNvcmVcXGxpYlxcY2FjaGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgeyBzZXRUaW1lb3V0IH0gPSByZXF1aXJlKCd0aW1lcnMnKTtcblxuLy8gQSBjYWNoZSB0aGF0IGV4cGlyZXMuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIENhY2hlIGV4dGVuZHMgTWFwIHtcbiAgY29uc3RydWN0b3IodGltZW91dCA9IDEwMDApIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMudGltZW91dCA9IHRpbWVvdXQ7XG4gIH1cbiAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICBpZiAodGhpcy5oYXMoa2V5KSkge1xuICAgICAgY2xlYXJUaW1lb3V0KHN1cGVyLmdldChrZXkpLnRpZCk7XG4gICAgfVxuICAgIHN1cGVyLnNldChrZXksIHtcbiAgICAgIHRpZDogc2V0VGltZW91dCh0aGlzLmRlbGV0ZS5iaW5kKHRoaXMsIGtleSksIHRoaXMudGltZW91dCkudW5yZWYoKSxcbiAgICAgIHZhbHVlLFxuICAgIH0pO1xuICB9XG4gIGdldChrZXkpIHtcbiAgICBsZXQgZW50cnkgPSBzdXBlci5nZXQoa2V5KTtcbiAgICBpZiAoZW50cnkpIHtcbiAgICAgIHJldHVybiBlbnRyeS52YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZ2V0T3JTZXQoa2V5LCBmbikge1xuICAgIGlmICh0aGlzLmhhcyhrZXkpKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXQoa2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHZhbHVlID0gZm4oKTtcbiAgICAgIHRoaXMuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgKGFzeW5jKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGF3YWl0IHZhbHVlO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICB0aGlzLmRlbGV0ZShrZXkpO1xuICAgICAgICB9XG4gICAgICB9KSgpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfVxuICBkZWxldGUoa2V5KSB7XG4gICAgbGV0IGVudHJ5ID0gc3VwZXIuZ2V0KGtleSk7XG4gICAgaWYgKGVudHJ5KSB7XG4gICAgICBjbGVhclRpbWVvdXQoZW50cnkudGlkKTtcbiAgICAgIHN1cGVyLmRlbGV0ZShrZXkpO1xuICAgIH1cbiAgfVxuICBjbGVhcigpIHtcbiAgICBmb3IgKGxldCBlbnRyeSBvZiB0aGlzLnZhbHVlcygpKSB7XG4gICAgICBjbGVhclRpbWVvdXQoZW50cnkudGlkKTtcbiAgICB9XG4gICAgc3VwZXIuY2xlYXIoKTtcbiAgfVxufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ytdl-core/lib/cache.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ytdl-core/lib/format-utils.js":
/*!****************************************************!*\
  !*** ./node_modules/ytdl-core/lib/format-utils.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("const utils = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/ytdl-core/lib/utils.js\");\nconst FORMATS = __webpack_require__(/*! ./formats */ \"(rsc)/./node_modules/ytdl-core/lib/formats.js\");\n\n\n// Use these to help sort formats, higher index is better.\nconst audioEncodingRanks = [\n  'mp4a',\n  'mp3',\n  'vorbis',\n  'aac',\n  'opus',\n  'flac',\n];\nconst videoEncodingRanks = [\n  'mp4v',\n  'avc1',\n  'Sorenson H.283',\n  'MPEG-4 Visual',\n  'VP8',\n  'VP9',\n  'H.264',\n];\n\nconst getVideoBitrate = format => format.bitrate || 0;\nconst getVideoEncodingRank = format =>\n  videoEncodingRanks.findIndex(enc => format.codecs && format.codecs.includes(enc));\nconst getAudioBitrate = format => format.audioBitrate || 0;\nconst getAudioEncodingRank = format =>\n  audioEncodingRanks.findIndex(enc => format.codecs && format.codecs.includes(enc));\n\n\n/**\n * Sort formats by a list of functions.\n *\n * @param {Object} a\n * @param {Object} b\n * @param {Array.<Function>} sortBy\n * @returns {number}\n */\nconst sortFormatsBy = (a, b, sortBy) => {\n  let res = 0;\n  for (let fn of sortBy) {\n    res = fn(b) - fn(a);\n    if (res !== 0) {\n      break;\n    }\n  }\n  return res;\n};\n\n\nconst sortFormatsByVideo = (a, b) => sortFormatsBy(a, b, [\n  format => parseInt(format.qualityLabel),\n  getVideoBitrate,\n  getVideoEncodingRank,\n]);\n\n\nconst sortFormatsByAudio = (a, b) => sortFormatsBy(a, b, [\n  getAudioBitrate,\n  getAudioEncodingRank,\n]);\n\n\n/**\n * Sort formats from highest quality to lowest.\n *\n * @param {Object} a\n * @param {Object} b\n * @returns {number}\n */\nexports.sortFormats = (a, b) => sortFormatsBy(a, b, [\n  // Formats with both video and audio are ranked highest.\n  format => +!!format.isHLS,\n  format => +!!format.isDashMPD,\n  format => +(format.contentLength > 0),\n  format => +(format.hasVideo && format.hasAudio),\n  format => +format.hasVideo,\n  format => parseInt(format.qualityLabel) || 0,\n  getVideoBitrate,\n  getAudioBitrate,\n  getVideoEncodingRank,\n  getAudioEncodingRank,\n]);\n\n\n/**\n * Choose a format depending on the given options.\n *\n * @param {Array.<Object>} formats\n * @param {Object} options\n * @returns {Object}\n * @throws {Error} when no format matches the filter/format rules\n */\nexports.chooseFormat = (formats, options) => {\n  if (typeof options.format === 'object') {\n    if (!options.format.url) {\n      throw Error('Invalid format given, did you use `ytdl.getInfo()`?');\n    }\n    return options.format;\n  }\n\n  if (options.filter) {\n    formats = exports.filterFormats(formats, options.filter);\n  }\n\n  // We currently only support HLS-Formats for livestreams\n  // So we (now) remove all non-HLS streams\n  if (formats.some(fmt => fmt.isHLS)) {\n    formats = formats.filter(fmt => fmt.isHLS || !fmt.isLive);\n  }\n\n  let format;\n  const quality = options.quality || 'highest';\n  switch (quality) {\n    case 'highest':\n      format = formats[0];\n      break;\n\n    case 'lowest':\n      format = formats[formats.length - 1];\n      break;\n\n    case 'highestaudio': {\n      formats = exports.filterFormats(formats, 'audio');\n      formats.sort(sortFormatsByAudio);\n      // Filter for only the best audio format\n      const bestAudioFormat = formats[0];\n      formats = formats.filter(f => sortFormatsByAudio(bestAudioFormat, f) === 0);\n      // Check for the worst video quality for the best audio quality and pick according\n      // This does not loose default sorting of video encoding and bitrate\n      const worstVideoQuality = formats.map(f => parseInt(f.qualityLabel) || 0).sort((a, b) => a - b)[0];\n      format = formats.find(f => (parseInt(f.qualityLabel) || 0) === worstVideoQuality);\n      break;\n    }\n\n    case 'lowestaudio':\n      formats = exports.filterFormats(formats, 'audio');\n      formats.sort(sortFormatsByAudio);\n      format = formats[formats.length - 1];\n      break;\n\n    case 'highestvideo': {\n      formats = exports.filterFormats(formats, 'video');\n      formats.sort(sortFormatsByVideo);\n      // Filter for only the best video format\n      const bestVideoFormat = formats[0];\n      formats = formats.filter(f => sortFormatsByVideo(bestVideoFormat, f) === 0);\n      // Check for the worst audio quality for the best video quality and pick according\n      // This does not loose default sorting of audio encoding and bitrate\n      const worstAudioQuality = formats.map(f => f.audioBitrate || 0).sort((a, b) => a - b)[0];\n      format = formats.find(f => (f.audioBitrate || 0) === worstAudioQuality);\n      break;\n    }\n\n    case 'lowestvideo':\n      formats = exports.filterFormats(formats, 'video');\n      formats.sort(sortFormatsByVideo);\n      format = formats[formats.length - 1];\n      break;\n\n    default:\n      format = getFormatByQuality(quality, formats);\n      break;\n  }\n\n  if (!format) {\n    throw Error(`No such format found: ${quality}`);\n  }\n  return format;\n};\n\n/**\n * Gets a format based on quality or array of quality's\n *\n * @param {string|[string]} quality\n * @param {[Object]} formats\n * @returns {Object}\n */\nconst getFormatByQuality = (quality, formats) => {\n  let getFormat = itag => formats.find(format => `${format.itag}` === `${itag}`);\n  if (Array.isArray(quality)) {\n    return getFormat(quality.find(q => getFormat(q)));\n  } else {\n    return getFormat(quality);\n  }\n};\n\n\n/**\n * @param {Array.<Object>} formats\n * @param {Function} filter\n * @returns {Array.<Object>}\n */\nexports.filterFormats = (formats, filter) => {\n  let fn;\n  switch (filter) {\n    case 'videoandaudio':\n    case 'audioandvideo':\n      fn = format => format.hasVideo && format.hasAudio;\n      break;\n\n    case 'video':\n      fn = format => format.hasVideo;\n      break;\n\n    case 'videoonly':\n      fn = format => format.hasVideo && !format.hasAudio;\n      break;\n\n    case 'audio':\n      fn = format => format.hasAudio;\n      break;\n\n    case 'audioonly':\n      fn = format => !format.hasVideo && format.hasAudio;\n      break;\n\n    default:\n      if (typeof filter === 'function') {\n        fn = filter;\n      } else {\n        throw TypeError(`Given filter (${filter}) is not supported`);\n      }\n  }\n  return formats.filter(format => !!format.url && fn(format));\n};\n\n\n/**\n * @param {Object} format\n * @returns {Object}\n */\nexports.addFormatMeta = format => {\n  format = Object.assign({}, FORMATS[format.itag], format);\n  format.hasVideo = !!format.qualityLabel;\n  format.hasAudio = !!format.audioBitrate;\n  format.container = format.mimeType ?\n    format.mimeType.split(';')[0].split('/')[1] : null;\n  format.codecs = format.mimeType ?\n    utils.between(format.mimeType, 'codecs=\"', '\"') : null;\n  format.videoCodec = format.hasVideo && format.codecs ?\n    format.codecs.split(', ')[0] : null;\n  format.audioCodec = format.hasAudio && format.codecs ?\n    format.codecs.split(', ').slice(-1)[0] : null;\n  format.isLive = /\\bsource[/=]yt_live_broadcast\\b/.test(format.url);\n  format.isHLS = /\\/manifest\\/hls_(variant|playlist)\\//.test(format.url);\n  format.isDashMPD = /\\/manifest\\/dash\\//.test(format.url);\n  return format;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMveXRkbC1jb3JlL2xpYi9mb3JtYXQtdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQUEsY0FBYyxtQkFBTyxDQUFDLDREQUFTO0FBQy9CLGdCQUFnQixtQkFBTyxDQUFDLGdFQUFXOzs7QUFHbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLGtCQUFrQjtBQUM3QixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0IsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYixZQUFZLE9BQU87QUFDbkI7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5Q0FBeUMsUUFBUTtBQUNqRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxVQUFVO0FBQ3JCLGFBQWE7QUFDYjtBQUNBO0FBQ0Esb0RBQW9ELFlBQVksU0FBUyxLQUFLO0FBQzlFO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCLFdBQVcsVUFBVTtBQUNyQixhQUFhO0FBQ2I7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IseUNBQXlDLE9BQU87QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBLHFCQUFxQjtBQUNyQiwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcYWdneW1cXE9uZURyaXZlXFxEZXNrdG9wXFxwcm9qZWN0c1xceW91dHViZV9zdW1tYXJpemVyXFxub2RlX21vZHVsZXNcXHl0ZGwtY29yZVxcbGliXFxmb3JtYXQtdXRpbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5jb25zdCBGT1JNQVRTID0gcmVxdWlyZSgnLi9mb3JtYXRzJyk7XG5cblxuLy8gVXNlIHRoZXNlIHRvIGhlbHAgc29ydCBmb3JtYXRzLCBoaWdoZXIgaW5kZXggaXMgYmV0dGVyLlxuY29uc3QgYXVkaW9FbmNvZGluZ1JhbmtzID0gW1xuICAnbXA0YScsXG4gICdtcDMnLFxuICAndm9yYmlzJyxcbiAgJ2FhYycsXG4gICdvcHVzJyxcbiAgJ2ZsYWMnLFxuXTtcbmNvbnN0IHZpZGVvRW5jb2RpbmdSYW5rcyA9IFtcbiAgJ21wNHYnLFxuICAnYXZjMScsXG4gICdTb3JlbnNvbiBILjI4MycsXG4gICdNUEVHLTQgVmlzdWFsJyxcbiAgJ1ZQOCcsXG4gICdWUDknLFxuICAnSC4yNjQnLFxuXTtcblxuY29uc3QgZ2V0VmlkZW9CaXRyYXRlID0gZm9ybWF0ID0+IGZvcm1hdC5iaXRyYXRlIHx8IDA7XG5jb25zdCBnZXRWaWRlb0VuY29kaW5nUmFuayA9IGZvcm1hdCA9PlxuICB2aWRlb0VuY29kaW5nUmFua3MuZmluZEluZGV4KGVuYyA9PiBmb3JtYXQuY29kZWNzICYmIGZvcm1hdC5jb2RlY3MuaW5jbHVkZXMoZW5jKSk7XG5jb25zdCBnZXRBdWRpb0JpdHJhdGUgPSBmb3JtYXQgPT4gZm9ybWF0LmF1ZGlvQml0cmF0ZSB8fCAwO1xuY29uc3QgZ2V0QXVkaW9FbmNvZGluZ1JhbmsgPSBmb3JtYXQgPT5cbiAgYXVkaW9FbmNvZGluZ1JhbmtzLmZpbmRJbmRleChlbmMgPT4gZm9ybWF0LmNvZGVjcyAmJiBmb3JtYXQuY29kZWNzLmluY2x1ZGVzKGVuYykpO1xuXG5cbi8qKlxuICogU29ydCBmb3JtYXRzIGJ5IGEgbGlzdCBvZiBmdW5jdGlvbnMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGFcbiAqIEBwYXJhbSB7T2JqZWN0fSBiXG4gKiBAcGFyYW0ge0FycmF5LjxGdW5jdGlvbj59IHNvcnRCeVxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuY29uc3Qgc29ydEZvcm1hdHNCeSA9IChhLCBiLCBzb3J0QnkpID0+IHtcbiAgbGV0IHJlcyA9IDA7XG4gIGZvciAobGV0IGZuIG9mIHNvcnRCeSkge1xuICAgIHJlcyA9IGZuKGIpIC0gZm4oYSk7XG4gICAgaWYgKHJlcyAhPT0gMCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXM7XG59O1xuXG5cbmNvbnN0IHNvcnRGb3JtYXRzQnlWaWRlbyA9IChhLCBiKSA9PiBzb3J0Rm9ybWF0c0J5KGEsIGIsIFtcbiAgZm9ybWF0ID0+IHBhcnNlSW50KGZvcm1hdC5xdWFsaXR5TGFiZWwpLFxuICBnZXRWaWRlb0JpdHJhdGUsXG4gIGdldFZpZGVvRW5jb2RpbmdSYW5rLFxuXSk7XG5cblxuY29uc3Qgc29ydEZvcm1hdHNCeUF1ZGlvID0gKGEsIGIpID0+IHNvcnRGb3JtYXRzQnkoYSwgYiwgW1xuICBnZXRBdWRpb0JpdHJhdGUsXG4gIGdldEF1ZGlvRW5jb2RpbmdSYW5rLFxuXSk7XG5cblxuLyoqXG4gKiBTb3J0IGZvcm1hdHMgZnJvbSBoaWdoZXN0IHF1YWxpdHkgdG8gbG93ZXN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhXG4gKiBAcGFyYW0ge09iamVjdH0gYlxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0cy5zb3J0Rm9ybWF0cyA9IChhLCBiKSA9PiBzb3J0Rm9ybWF0c0J5KGEsIGIsIFtcbiAgLy8gRm9ybWF0cyB3aXRoIGJvdGggdmlkZW8gYW5kIGF1ZGlvIGFyZSByYW5rZWQgaGlnaGVzdC5cbiAgZm9ybWF0ID0+ICshIWZvcm1hdC5pc0hMUyxcbiAgZm9ybWF0ID0+ICshIWZvcm1hdC5pc0Rhc2hNUEQsXG4gIGZvcm1hdCA9PiArKGZvcm1hdC5jb250ZW50TGVuZ3RoID4gMCksXG4gIGZvcm1hdCA9PiArKGZvcm1hdC5oYXNWaWRlbyAmJiBmb3JtYXQuaGFzQXVkaW8pLFxuICBmb3JtYXQgPT4gK2Zvcm1hdC5oYXNWaWRlbyxcbiAgZm9ybWF0ID0+IHBhcnNlSW50KGZvcm1hdC5xdWFsaXR5TGFiZWwpIHx8IDAsXG4gIGdldFZpZGVvQml0cmF0ZSxcbiAgZ2V0QXVkaW9CaXRyYXRlLFxuICBnZXRWaWRlb0VuY29kaW5nUmFuayxcbiAgZ2V0QXVkaW9FbmNvZGluZ1JhbmssXG5dKTtcblxuXG4vKipcbiAqIENob29zZSBhIGZvcm1hdCBkZXBlbmRpbmcgb24gdGhlIGdpdmVuIG9wdGlvbnMuXG4gKlxuICogQHBhcmFtIHtBcnJheS48T2JqZWN0Pn0gZm9ybWF0c1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKiBAdGhyb3dzIHtFcnJvcn0gd2hlbiBubyBmb3JtYXQgbWF0Y2hlcyB0aGUgZmlsdGVyL2Zvcm1hdCBydWxlc1xuICovXG5leHBvcnRzLmNob29zZUZvcm1hdCA9IChmb3JtYXRzLCBvcHRpb25zKSA9PiB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5mb3JtYXQgPT09ICdvYmplY3QnKSB7XG4gICAgaWYgKCFvcHRpb25zLmZvcm1hdC51cmwpIHtcbiAgICAgIHRocm93IEVycm9yKCdJbnZhbGlkIGZvcm1hdCBnaXZlbiwgZGlkIHlvdSB1c2UgYHl0ZGwuZ2V0SW5mbygpYD8nKTtcbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnMuZm9ybWF0O1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuZmlsdGVyKSB7XG4gICAgZm9ybWF0cyA9IGV4cG9ydHMuZmlsdGVyRm9ybWF0cyhmb3JtYXRzLCBvcHRpb25zLmZpbHRlcik7XG4gIH1cblxuICAvLyBXZSBjdXJyZW50bHkgb25seSBzdXBwb3J0IEhMUy1Gb3JtYXRzIGZvciBsaXZlc3RyZWFtc1xuICAvLyBTbyB3ZSAobm93KSByZW1vdmUgYWxsIG5vbi1ITFMgc3RyZWFtc1xuICBpZiAoZm9ybWF0cy5zb21lKGZtdCA9PiBmbXQuaXNITFMpKSB7XG4gICAgZm9ybWF0cyA9IGZvcm1hdHMuZmlsdGVyKGZtdCA9PiBmbXQuaXNITFMgfHwgIWZtdC5pc0xpdmUpO1xuICB9XG5cbiAgbGV0IGZvcm1hdDtcbiAgY29uc3QgcXVhbGl0eSA9IG9wdGlvbnMucXVhbGl0eSB8fCAnaGlnaGVzdCc7XG4gIHN3aXRjaCAocXVhbGl0eSkge1xuICAgIGNhc2UgJ2hpZ2hlc3QnOlxuICAgICAgZm9ybWF0ID0gZm9ybWF0c1swXTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnbG93ZXN0JzpcbiAgICAgIGZvcm1hdCA9IGZvcm1hdHNbZm9ybWF0cy5sZW5ndGggLSAxXTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnaGlnaGVzdGF1ZGlvJzoge1xuICAgICAgZm9ybWF0cyA9IGV4cG9ydHMuZmlsdGVyRm9ybWF0cyhmb3JtYXRzLCAnYXVkaW8nKTtcbiAgICAgIGZvcm1hdHMuc29ydChzb3J0Rm9ybWF0c0J5QXVkaW8pO1xuICAgICAgLy8gRmlsdGVyIGZvciBvbmx5IHRoZSBiZXN0IGF1ZGlvIGZvcm1hdFxuICAgICAgY29uc3QgYmVzdEF1ZGlvRm9ybWF0ID0gZm9ybWF0c1swXTtcbiAgICAgIGZvcm1hdHMgPSBmb3JtYXRzLmZpbHRlcihmID0+IHNvcnRGb3JtYXRzQnlBdWRpbyhiZXN0QXVkaW9Gb3JtYXQsIGYpID09PSAwKTtcbiAgICAgIC8vIENoZWNrIGZvciB0aGUgd29yc3QgdmlkZW8gcXVhbGl0eSBmb3IgdGhlIGJlc3QgYXVkaW8gcXVhbGl0eSBhbmQgcGljayBhY2NvcmRpbmdcbiAgICAgIC8vIFRoaXMgZG9lcyBub3QgbG9vc2UgZGVmYXVsdCBzb3J0aW5nIG9mIHZpZGVvIGVuY29kaW5nIGFuZCBiaXRyYXRlXG4gICAgICBjb25zdCB3b3JzdFZpZGVvUXVhbGl0eSA9IGZvcm1hdHMubWFwKGYgPT4gcGFyc2VJbnQoZi5xdWFsaXR5TGFiZWwpIHx8IDApLnNvcnQoKGEsIGIpID0+IGEgLSBiKVswXTtcbiAgICAgIGZvcm1hdCA9IGZvcm1hdHMuZmluZChmID0+IChwYXJzZUludChmLnF1YWxpdHlMYWJlbCkgfHwgMCkgPT09IHdvcnN0VmlkZW9RdWFsaXR5KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNhc2UgJ2xvd2VzdGF1ZGlvJzpcbiAgICAgIGZvcm1hdHMgPSBleHBvcnRzLmZpbHRlckZvcm1hdHMoZm9ybWF0cywgJ2F1ZGlvJyk7XG4gICAgICBmb3JtYXRzLnNvcnQoc29ydEZvcm1hdHNCeUF1ZGlvKTtcbiAgICAgIGZvcm1hdCA9IGZvcm1hdHNbZm9ybWF0cy5sZW5ndGggLSAxXTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnaGlnaGVzdHZpZGVvJzoge1xuICAgICAgZm9ybWF0cyA9IGV4cG9ydHMuZmlsdGVyRm9ybWF0cyhmb3JtYXRzLCAndmlkZW8nKTtcbiAgICAgIGZvcm1hdHMuc29ydChzb3J0Rm9ybWF0c0J5VmlkZW8pO1xuICAgICAgLy8gRmlsdGVyIGZvciBvbmx5IHRoZSBiZXN0IHZpZGVvIGZvcm1hdFxuICAgICAgY29uc3QgYmVzdFZpZGVvRm9ybWF0ID0gZm9ybWF0c1swXTtcbiAgICAgIGZvcm1hdHMgPSBmb3JtYXRzLmZpbHRlcihmID0+IHNvcnRGb3JtYXRzQnlWaWRlbyhiZXN0VmlkZW9Gb3JtYXQsIGYpID09PSAwKTtcbiAgICAgIC8vIENoZWNrIGZvciB0aGUgd29yc3QgYXVkaW8gcXVhbGl0eSBmb3IgdGhlIGJlc3QgdmlkZW8gcXVhbGl0eSBhbmQgcGljayBhY2NvcmRpbmdcbiAgICAgIC8vIFRoaXMgZG9lcyBub3QgbG9vc2UgZGVmYXVsdCBzb3J0aW5nIG9mIGF1ZGlvIGVuY29kaW5nIGFuZCBiaXRyYXRlXG4gICAgICBjb25zdCB3b3JzdEF1ZGlvUXVhbGl0eSA9IGZvcm1hdHMubWFwKGYgPT4gZi5hdWRpb0JpdHJhdGUgfHwgMCkuc29ydCgoYSwgYikgPT4gYSAtIGIpWzBdO1xuICAgICAgZm9ybWF0ID0gZm9ybWF0cy5maW5kKGYgPT4gKGYuYXVkaW9CaXRyYXRlIHx8IDApID09PSB3b3JzdEF1ZGlvUXVhbGl0eSk7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjYXNlICdsb3dlc3R2aWRlbyc6XG4gICAgICBmb3JtYXRzID0gZXhwb3J0cy5maWx0ZXJGb3JtYXRzKGZvcm1hdHMsICd2aWRlbycpO1xuICAgICAgZm9ybWF0cy5zb3J0KHNvcnRGb3JtYXRzQnlWaWRlbyk7XG4gICAgICBmb3JtYXQgPSBmb3JtYXRzW2Zvcm1hdHMubGVuZ3RoIC0gMV07XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICBmb3JtYXQgPSBnZXRGb3JtYXRCeVF1YWxpdHkocXVhbGl0eSwgZm9ybWF0cyk7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIGlmICghZm9ybWF0KSB7XG4gICAgdGhyb3cgRXJyb3IoYE5vIHN1Y2ggZm9ybWF0IGZvdW5kOiAke3F1YWxpdHl9YCk7XG4gIH1cbiAgcmV0dXJuIGZvcm1hdDtcbn07XG5cbi8qKlxuICogR2V0cyBhIGZvcm1hdCBiYXNlZCBvbiBxdWFsaXR5IG9yIGFycmF5IG9mIHF1YWxpdHknc1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfFtzdHJpbmddfSBxdWFsaXR5XG4gKiBAcGFyYW0ge1tPYmplY3RdfSBmb3JtYXRzXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICovXG5jb25zdCBnZXRGb3JtYXRCeVF1YWxpdHkgPSAocXVhbGl0eSwgZm9ybWF0cykgPT4ge1xuICBsZXQgZ2V0Rm9ybWF0ID0gaXRhZyA9PiBmb3JtYXRzLmZpbmQoZm9ybWF0ID0+IGAke2Zvcm1hdC5pdGFnfWAgPT09IGAke2l0YWd9YCk7XG4gIGlmIChBcnJheS5pc0FycmF5KHF1YWxpdHkpKSB7XG4gICAgcmV0dXJuIGdldEZvcm1hdChxdWFsaXR5LmZpbmQocSA9PiBnZXRGb3JtYXQocSkpKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZ2V0Rm9ybWF0KHF1YWxpdHkpO1xuICB9XG59O1xuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheS48T2JqZWN0Pn0gZm9ybWF0c1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZmlsdGVyXG4gKiBAcmV0dXJucyB7QXJyYXkuPE9iamVjdD59XG4gKi9cbmV4cG9ydHMuZmlsdGVyRm9ybWF0cyA9IChmb3JtYXRzLCBmaWx0ZXIpID0+IHtcbiAgbGV0IGZuO1xuICBzd2l0Y2ggKGZpbHRlcikge1xuICAgIGNhc2UgJ3ZpZGVvYW5kYXVkaW8nOlxuICAgIGNhc2UgJ2F1ZGlvYW5kdmlkZW8nOlxuICAgICAgZm4gPSBmb3JtYXQgPT4gZm9ybWF0Lmhhc1ZpZGVvICYmIGZvcm1hdC5oYXNBdWRpbztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAndmlkZW8nOlxuICAgICAgZm4gPSBmb3JtYXQgPT4gZm9ybWF0Lmhhc1ZpZGVvO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICd2aWRlb29ubHknOlxuICAgICAgZm4gPSBmb3JtYXQgPT4gZm9ybWF0Lmhhc1ZpZGVvICYmICFmb3JtYXQuaGFzQXVkaW87XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2F1ZGlvJzpcbiAgICAgIGZuID0gZm9ybWF0ID0+IGZvcm1hdC5oYXNBdWRpbztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnYXVkaW9vbmx5JzpcbiAgICAgIGZuID0gZm9ybWF0ID0+ICFmb3JtYXQuaGFzVmlkZW8gJiYgZm9ybWF0Lmhhc0F1ZGlvO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKHR5cGVvZiBmaWx0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZm4gPSBmaWx0ZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoYEdpdmVuIGZpbHRlciAoJHtmaWx0ZXJ9KSBpcyBub3Qgc3VwcG9ydGVkYCk7XG4gICAgICB9XG4gIH1cbiAgcmV0dXJuIGZvcm1hdHMuZmlsdGVyKGZvcm1hdCA9PiAhIWZvcm1hdC51cmwgJiYgZm4oZm9ybWF0KSk7XG59O1xuXG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9IGZvcm1hdFxuICogQHJldHVybnMge09iamVjdH1cbiAqL1xuZXhwb3J0cy5hZGRGb3JtYXRNZXRhID0gZm9ybWF0ID0+IHtcbiAgZm9ybWF0ID0gT2JqZWN0LmFzc2lnbih7fSwgRk9STUFUU1tmb3JtYXQuaXRhZ10sIGZvcm1hdCk7XG4gIGZvcm1hdC5oYXNWaWRlbyA9ICEhZm9ybWF0LnF1YWxpdHlMYWJlbDtcbiAgZm9ybWF0Lmhhc0F1ZGlvID0gISFmb3JtYXQuYXVkaW9CaXRyYXRlO1xuICBmb3JtYXQuY29udGFpbmVyID0gZm9ybWF0Lm1pbWVUeXBlID9cbiAgICBmb3JtYXQubWltZVR5cGUuc3BsaXQoJzsnKVswXS5zcGxpdCgnLycpWzFdIDogbnVsbDtcbiAgZm9ybWF0LmNvZGVjcyA9IGZvcm1hdC5taW1lVHlwZSA/XG4gICAgdXRpbHMuYmV0d2Vlbihmb3JtYXQubWltZVR5cGUsICdjb2RlY3M9XCInLCAnXCInKSA6IG51bGw7XG4gIGZvcm1hdC52aWRlb0NvZGVjID0gZm9ybWF0Lmhhc1ZpZGVvICYmIGZvcm1hdC5jb2RlY3MgP1xuICAgIGZvcm1hdC5jb2RlY3Muc3BsaXQoJywgJylbMF0gOiBudWxsO1xuICBmb3JtYXQuYXVkaW9Db2RlYyA9IGZvcm1hdC5oYXNBdWRpbyAmJiBmb3JtYXQuY29kZWNzID9cbiAgICBmb3JtYXQuY29kZWNzLnNwbGl0KCcsICcpLnNsaWNlKC0xKVswXSA6IG51bGw7XG4gIGZvcm1hdC5pc0xpdmUgPSAvXFxic291cmNlWy89XXl0X2xpdmVfYnJvYWRjYXN0XFxiLy50ZXN0KGZvcm1hdC51cmwpO1xuICBmb3JtYXQuaXNITFMgPSAvXFwvbWFuaWZlc3RcXC9obHNfKHZhcmlhbnR8cGxheWxpc3QpXFwvLy50ZXN0KGZvcm1hdC51cmwpO1xuICBmb3JtYXQuaXNEYXNoTVBEID0gL1xcL21hbmlmZXN0XFwvZGFzaFxcLy8udGVzdChmb3JtYXQudXJsKTtcbiAgcmV0dXJuIGZvcm1hdDtcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ytdl-core/lib/format-utils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ytdl-core/lib/formats.js":
/*!***********************************************!*\
  !*** ./node_modules/ytdl-core/lib/formats.js ***!
  \***********************************************/
/***/ ((module) => {

eval("/**\n * http://en.wikipedia.org/wiki/YouTube#Quality_and_formats\n */\nmodule.exports = {\n\n  5: {\n    mimeType: 'video/flv; codecs=\"Sorenson H.283, mp3\"',\n    qualityLabel: '240p',\n    bitrate: 250000,\n    audioBitrate: 64,\n  },\n\n  6: {\n    mimeType: 'video/flv; codecs=\"Sorenson H.263, mp3\"',\n    qualityLabel: '270p',\n    bitrate: 800000,\n    audioBitrate: 64,\n  },\n\n  13: {\n    mimeType: 'video/3gp; codecs=\"MPEG-4 Visual, aac\"',\n    qualityLabel: null,\n    bitrate: 500000,\n    audioBitrate: null,\n  },\n\n  17: {\n    mimeType: 'video/3gp; codecs=\"MPEG-4 Visual, aac\"',\n    qualityLabel: '144p',\n    bitrate: 50000,\n    audioBitrate: 24,\n  },\n\n  18: {\n    mimeType: 'video/mp4; codecs=\"H.264, aac\"',\n    qualityLabel: '360p',\n    bitrate: 500000,\n    audioBitrate: 96,\n  },\n\n  22: {\n    mimeType: 'video/mp4; codecs=\"H.264, aac\"',\n    qualityLabel: '720p',\n    bitrate: 2000000,\n    audioBitrate: 192,\n  },\n\n  34: {\n    mimeType: 'video/flv; codecs=\"H.264, aac\"',\n    qualityLabel: '360p',\n    bitrate: 500000,\n    audioBitrate: 128,\n  },\n\n  35: {\n    mimeType: 'video/flv; codecs=\"H.264, aac\"',\n    qualityLabel: '480p',\n    bitrate: 800000,\n    audioBitrate: 128,\n  },\n\n  36: {\n    mimeType: 'video/3gp; codecs=\"MPEG-4 Visual, aac\"',\n    qualityLabel: '240p',\n    bitrate: 175000,\n    audioBitrate: 32,\n  },\n\n  37: {\n    mimeType: 'video/mp4; codecs=\"H.264, aac\"',\n    qualityLabel: '1080p',\n    bitrate: 3000000,\n    audioBitrate: 192,\n  },\n\n  38: {\n    mimeType: 'video/mp4; codecs=\"H.264, aac\"',\n    qualityLabel: '3072p',\n    bitrate: 3500000,\n    audioBitrate: 192,\n  },\n\n  43: {\n    mimeType: 'video/webm; codecs=\"VP8, vorbis\"',\n    qualityLabel: '360p',\n    bitrate: 500000,\n    audioBitrate: 128,\n  },\n\n  44: {\n    mimeType: 'video/webm; codecs=\"VP8, vorbis\"',\n    qualityLabel: '480p',\n    bitrate: 1000000,\n    audioBitrate: 128,\n  },\n\n  45: {\n    mimeType: 'video/webm; codecs=\"VP8, vorbis\"',\n    qualityLabel: '720p',\n    bitrate: 2000000,\n    audioBitrate: 192,\n  },\n\n  46: {\n    mimeType: 'audio/webm; codecs=\"vp8, vorbis\"',\n    qualityLabel: '1080p',\n    bitrate: null,\n    audioBitrate: 192,\n  },\n\n  82: {\n    mimeType: 'video/mp4; codecs=\"H.264, aac\"',\n    qualityLabel: '360p',\n    bitrate: 500000,\n    audioBitrate: 96,\n  },\n\n  83: {\n    mimeType: 'video/mp4; codecs=\"H.264, aac\"',\n    qualityLabel: '240p',\n    bitrate: 500000,\n    audioBitrate: 96,\n  },\n\n  84: {\n    mimeType: 'video/mp4; codecs=\"H.264, aac\"',\n    qualityLabel: '720p',\n    bitrate: 2000000,\n    audioBitrate: 192,\n  },\n\n  85: {\n    mimeType: 'video/mp4; codecs=\"H.264, aac\"',\n    qualityLabel: '1080p',\n    bitrate: 3000000,\n    audioBitrate: 192,\n  },\n\n  91: {\n    mimeType: 'video/ts; codecs=\"H.264, aac\"',\n    qualityLabel: '144p',\n    bitrate: 100000,\n    audioBitrate: 48,\n  },\n\n  92: {\n    mimeType: 'video/ts; codecs=\"H.264, aac\"',\n    qualityLabel: '240p',\n    bitrate: 150000,\n    audioBitrate: 48,\n  },\n\n  93: {\n    mimeType: 'video/ts; codecs=\"H.264, aac\"',\n    qualityLabel: '360p',\n    bitrate: 500000,\n    audioBitrate: 128,\n  },\n\n  94: {\n    mimeType: 'video/ts; codecs=\"H.264, aac\"',\n    qualityLabel: '480p',\n    bitrate: 800000,\n    audioBitrate: 128,\n  },\n\n  95: {\n    mimeType: 'video/ts; codecs=\"H.264, aac\"',\n    qualityLabel: '720p',\n    bitrate: 1500000,\n    audioBitrate: 256,\n  },\n\n  96: {\n    mimeType: 'video/ts; codecs=\"H.264, aac\"',\n    qualityLabel: '1080p',\n    bitrate: 2500000,\n    audioBitrate: 256,\n  },\n\n  100: {\n    mimeType: 'audio/webm; codecs=\"VP8, vorbis\"',\n    qualityLabel: '360p',\n    bitrate: null,\n    audioBitrate: 128,\n  },\n\n  101: {\n    mimeType: 'audio/webm; codecs=\"VP8, vorbis\"',\n    qualityLabel: '360p',\n    bitrate: null,\n    audioBitrate: 192,\n  },\n\n  102: {\n    mimeType: 'audio/webm; codecs=\"VP8, vorbis\"',\n    qualityLabel: '720p',\n    bitrate: null,\n    audioBitrate: 192,\n  },\n\n  120: {\n    mimeType: 'video/flv; codecs=\"H.264, aac\"',\n    qualityLabel: '720p',\n    bitrate: 2000000,\n    audioBitrate: 128,\n  },\n\n  127: {\n    mimeType: 'audio/ts; codecs=\"aac\"',\n    qualityLabel: null,\n    bitrate: null,\n    audioBitrate: 96,\n  },\n\n  128: {\n    mimeType: 'audio/ts; codecs=\"aac\"',\n    qualityLabel: null,\n    bitrate: null,\n    audioBitrate: 96,\n  },\n\n  132: {\n    mimeType: 'video/ts; codecs=\"H.264, aac\"',\n    qualityLabel: '240p',\n    bitrate: 150000,\n    audioBitrate: 48,\n  },\n\n  133: {\n    mimeType: 'video/mp4; codecs=\"H.264\"',\n    qualityLabel: '240p',\n    bitrate: 200000,\n    audioBitrate: null,\n  },\n\n  134: {\n    mimeType: 'video/mp4; codecs=\"H.264\"',\n    qualityLabel: '360p',\n    bitrate: 300000,\n    audioBitrate: null,\n  },\n\n  135: {\n    mimeType: 'video/mp4; codecs=\"H.264\"',\n    qualityLabel: '480p',\n    bitrate: 500000,\n    audioBitrate: null,\n  },\n\n  136: {\n    mimeType: 'video/mp4; codecs=\"H.264\"',\n    qualityLabel: '720p',\n    bitrate: 1000000,\n    audioBitrate: null,\n  },\n\n  137: {\n    mimeType: 'video/mp4; codecs=\"H.264\"',\n    qualityLabel: '1080p',\n    bitrate: 2500000,\n    audioBitrate: null,\n  },\n\n  138: {\n    mimeType: 'video/mp4; codecs=\"H.264\"',\n    qualityLabel: '4320p',\n    bitrate: 13500000,\n    audioBitrate: null,\n  },\n\n  139: {\n    mimeType: 'audio/mp4; codecs=\"aac\"',\n    qualityLabel: null,\n    bitrate: null,\n    audioBitrate: 48,\n  },\n\n  140: {\n    mimeType: 'audio/m4a; codecs=\"aac\"',\n    qualityLabel: null,\n    bitrate: null,\n    audioBitrate: 128,\n  },\n\n  141: {\n    mimeType: 'audio/mp4; codecs=\"aac\"',\n    qualityLabel: null,\n    bitrate: null,\n    audioBitrate: 256,\n  },\n\n  151: {\n    mimeType: 'video/ts; codecs=\"H.264, aac\"',\n    qualityLabel: '720p',\n    bitrate: 50000,\n    audioBitrate: 24,\n  },\n\n  160: {\n    mimeType: 'video/mp4; codecs=\"H.264\"',\n    qualityLabel: '144p',\n    bitrate: 100000,\n    audioBitrate: null,\n  },\n\n  171: {\n    mimeType: 'audio/webm; codecs=\"vorbis\"',\n    qualityLabel: null,\n    bitrate: null,\n    audioBitrate: 128,\n  },\n\n  172: {\n    mimeType: 'audio/webm; codecs=\"vorbis\"',\n    qualityLabel: null,\n    bitrate: null,\n    audioBitrate: 192,\n  },\n\n  242: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: '240p',\n    bitrate: 100000,\n    audioBitrate: null,\n  },\n\n  243: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: '360p',\n    bitrate: 250000,\n    audioBitrate: null,\n  },\n\n  244: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: '480p',\n    bitrate: 500000,\n    audioBitrate: null,\n  },\n\n  247: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: '720p',\n    bitrate: 700000,\n    audioBitrate: null,\n  },\n\n  248: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: '1080p',\n    bitrate: 1500000,\n    audioBitrate: null,\n  },\n\n  249: {\n    mimeType: 'audio/webm; codecs=\"opus\"',\n    qualityLabel: null,\n    bitrate: null,\n    audioBitrate: 48,\n  },\n\n  250: {\n    mimeType: 'audio/webm; codecs=\"opus\"',\n    qualityLabel: null,\n    bitrate: null,\n    audioBitrate: 64,\n  },\n\n  251: {\n    mimeType: 'audio/webm; codecs=\"opus\"',\n    qualityLabel: null,\n    bitrate: null,\n    audioBitrate: 160,\n  },\n\n  264: {\n    mimeType: 'video/mp4; codecs=\"H.264\"',\n    qualityLabel: '1440p',\n    bitrate: 4000000,\n    audioBitrate: null,\n  },\n\n  266: {\n    mimeType: 'video/mp4; codecs=\"H.264\"',\n    qualityLabel: '2160p',\n    bitrate: 12500000,\n    audioBitrate: null,\n  },\n\n  271: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: '1440p',\n    bitrate: 9000000,\n    audioBitrate: null,\n  },\n\n  272: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: '4320p',\n    bitrate: 20000000,\n    audioBitrate: null,\n  },\n\n  278: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: '144p 30fps',\n    bitrate: 80000,\n    audioBitrate: null,\n  },\n\n  298: {\n    mimeType: 'video/mp4; codecs=\"H.264\"',\n    qualityLabel: '720p',\n    bitrate: 3000000,\n    audioBitrate: null,\n  },\n\n  299: {\n    mimeType: 'video/mp4; codecs=\"H.264\"',\n    qualityLabel: '1080p',\n    bitrate: 5500000,\n    audioBitrate: null,\n  },\n\n  300: {\n    mimeType: 'video/ts; codecs=\"H.264, aac\"',\n    qualityLabel: '720p',\n    bitrate: 1318000,\n    audioBitrate: 48,\n  },\n\n  302: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: '720p HFR',\n    bitrate: 2500000,\n    audioBitrate: null,\n  },\n\n  303: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: '1080p HFR',\n    bitrate: 5000000,\n    audioBitrate: null,\n  },\n\n  308: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: '1440p HFR',\n    bitrate: 10000000,\n    audioBitrate: null,\n  },\n\n  313: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: '2160p',\n    bitrate: 13000000,\n    audioBitrate: null,\n  },\n\n  315: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: '2160p HFR',\n    bitrate: 20000000,\n    audioBitrate: null,\n  },\n\n  330: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: '144p HDR, HFR',\n    bitrate: 80000,\n    audioBitrate: null,\n  },\n\n  331: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: '240p HDR, HFR',\n    bitrate: 100000,\n    audioBitrate: null,\n  },\n\n  332: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: '360p HDR, HFR',\n    bitrate: 250000,\n    audioBitrate: null,\n  },\n\n  333: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: '240p HDR, HFR',\n    bitrate: 500000,\n    audioBitrate: null,\n  },\n\n  334: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: '720p HDR, HFR',\n    bitrate: 1000000,\n    audioBitrate: null,\n  },\n\n  335: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: '1080p HDR, HFR',\n    bitrate: 1500000,\n    audioBitrate: null,\n  },\n\n  336: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: '1440p HDR, HFR',\n    bitrate: 5000000,\n    audioBitrate: null,\n  },\n\n  337: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: '2160p HDR, HFR',\n    bitrate: 12000000,\n    audioBitrate: null,\n  },\n\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMveXRkbC1jb3JlL2xpYi9mb3JtYXRzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxhZ2d5bVxcT25lRHJpdmVcXERlc2t0b3BcXHByb2plY3RzXFx5b3V0dWJlX3N1bW1hcml6ZXJcXG5vZGVfbW9kdWxlc1xceXRkbC1jb3JlXFxsaWJcXGZvcm1hdHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1lvdVR1YmUjUXVhbGl0eV9hbmRfZm9ybWF0c1xuICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICA1OiB7XG4gICAgbWltZVR5cGU6ICd2aWRlby9mbHY7IGNvZGVjcz1cIlNvcmVuc29uIEguMjgzLCBtcDNcIicsXG4gICAgcXVhbGl0eUxhYmVsOiAnMjQwcCcsXG4gICAgYml0cmF0ZTogMjUwMDAwLFxuICAgIGF1ZGlvQml0cmF0ZTogNjQsXG4gIH0sXG5cbiAgNjoge1xuICAgIG1pbWVUeXBlOiAndmlkZW8vZmx2OyBjb2RlY3M9XCJTb3JlbnNvbiBILjI2MywgbXAzXCInLFxuICAgIHF1YWxpdHlMYWJlbDogJzI3MHAnLFxuICAgIGJpdHJhdGU6IDgwMDAwMCxcbiAgICBhdWRpb0JpdHJhdGU6IDY0LFxuICB9LFxuXG4gIDEzOiB7XG4gICAgbWltZVR5cGU6ICd2aWRlby8zZ3A7IGNvZGVjcz1cIk1QRUctNCBWaXN1YWwsIGFhY1wiJyxcbiAgICBxdWFsaXR5TGFiZWw6IG51bGwsXG4gICAgYml0cmF0ZTogNTAwMDAwLFxuICAgIGF1ZGlvQml0cmF0ZTogbnVsbCxcbiAgfSxcblxuICAxNzoge1xuICAgIG1pbWVUeXBlOiAndmlkZW8vM2dwOyBjb2RlY3M9XCJNUEVHLTQgVmlzdWFsLCBhYWNcIicsXG4gICAgcXVhbGl0eUxhYmVsOiAnMTQ0cCcsXG4gICAgYml0cmF0ZTogNTAwMDAsXG4gICAgYXVkaW9CaXRyYXRlOiAyNCxcbiAgfSxcblxuICAxODoge1xuICAgIG1pbWVUeXBlOiAndmlkZW8vbXA0OyBjb2RlY3M9XCJILjI2NCwgYWFjXCInLFxuICAgIHF1YWxpdHlMYWJlbDogJzM2MHAnLFxuICAgIGJpdHJhdGU6IDUwMDAwMCxcbiAgICBhdWRpb0JpdHJhdGU6IDk2LFxuICB9LFxuXG4gIDIyOiB7XG4gICAgbWltZVR5cGU6ICd2aWRlby9tcDQ7IGNvZGVjcz1cIkguMjY0LCBhYWNcIicsXG4gICAgcXVhbGl0eUxhYmVsOiAnNzIwcCcsXG4gICAgYml0cmF0ZTogMjAwMDAwMCxcbiAgICBhdWRpb0JpdHJhdGU6IDE5MixcbiAgfSxcblxuICAzNDoge1xuICAgIG1pbWVUeXBlOiAndmlkZW8vZmx2OyBjb2RlY3M9XCJILjI2NCwgYWFjXCInLFxuICAgIHF1YWxpdHlMYWJlbDogJzM2MHAnLFxuICAgIGJpdHJhdGU6IDUwMDAwMCxcbiAgICBhdWRpb0JpdHJhdGU6IDEyOCxcbiAgfSxcblxuICAzNToge1xuICAgIG1pbWVUeXBlOiAndmlkZW8vZmx2OyBjb2RlY3M9XCJILjI2NCwgYWFjXCInLFxuICAgIHF1YWxpdHlMYWJlbDogJzQ4MHAnLFxuICAgIGJpdHJhdGU6IDgwMDAwMCxcbiAgICBhdWRpb0JpdHJhdGU6IDEyOCxcbiAgfSxcblxuICAzNjoge1xuICAgIG1pbWVUeXBlOiAndmlkZW8vM2dwOyBjb2RlY3M9XCJNUEVHLTQgVmlzdWFsLCBhYWNcIicsXG4gICAgcXVhbGl0eUxhYmVsOiAnMjQwcCcsXG4gICAgYml0cmF0ZTogMTc1MDAwLFxuICAgIGF1ZGlvQml0cmF0ZTogMzIsXG4gIH0sXG5cbiAgMzc6IHtcbiAgICBtaW1lVHlwZTogJ3ZpZGVvL21wNDsgY29kZWNzPVwiSC4yNjQsIGFhY1wiJyxcbiAgICBxdWFsaXR5TGFiZWw6ICcxMDgwcCcsXG4gICAgYml0cmF0ZTogMzAwMDAwMCxcbiAgICBhdWRpb0JpdHJhdGU6IDE5MixcbiAgfSxcblxuICAzODoge1xuICAgIG1pbWVUeXBlOiAndmlkZW8vbXA0OyBjb2RlY3M9XCJILjI2NCwgYWFjXCInLFxuICAgIHF1YWxpdHlMYWJlbDogJzMwNzJwJyxcbiAgICBiaXRyYXRlOiAzNTAwMDAwLFxuICAgIGF1ZGlvQml0cmF0ZTogMTkyLFxuICB9LFxuXG4gIDQzOiB7XG4gICAgbWltZVR5cGU6ICd2aWRlby93ZWJtOyBjb2RlY3M9XCJWUDgsIHZvcmJpc1wiJyxcbiAgICBxdWFsaXR5TGFiZWw6ICczNjBwJyxcbiAgICBiaXRyYXRlOiA1MDAwMDAsXG4gICAgYXVkaW9CaXRyYXRlOiAxMjgsXG4gIH0sXG5cbiAgNDQ6IHtcbiAgICBtaW1lVHlwZTogJ3ZpZGVvL3dlYm07IGNvZGVjcz1cIlZQOCwgdm9yYmlzXCInLFxuICAgIHF1YWxpdHlMYWJlbDogJzQ4MHAnLFxuICAgIGJpdHJhdGU6IDEwMDAwMDAsXG4gICAgYXVkaW9CaXRyYXRlOiAxMjgsXG4gIH0sXG5cbiAgNDU6IHtcbiAgICBtaW1lVHlwZTogJ3ZpZGVvL3dlYm07IGNvZGVjcz1cIlZQOCwgdm9yYmlzXCInLFxuICAgIHF1YWxpdHlMYWJlbDogJzcyMHAnLFxuICAgIGJpdHJhdGU6IDIwMDAwMDAsXG4gICAgYXVkaW9CaXRyYXRlOiAxOTIsXG4gIH0sXG5cbiAgNDY6IHtcbiAgICBtaW1lVHlwZTogJ2F1ZGlvL3dlYm07IGNvZGVjcz1cInZwOCwgdm9yYmlzXCInLFxuICAgIHF1YWxpdHlMYWJlbDogJzEwODBwJyxcbiAgICBiaXRyYXRlOiBudWxsLFxuICAgIGF1ZGlvQml0cmF0ZTogMTkyLFxuICB9LFxuXG4gIDgyOiB7XG4gICAgbWltZVR5cGU6ICd2aWRlby9tcDQ7IGNvZGVjcz1cIkguMjY0LCBhYWNcIicsXG4gICAgcXVhbGl0eUxhYmVsOiAnMzYwcCcsXG4gICAgYml0cmF0ZTogNTAwMDAwLFxuICAgIGF1ZGlvQml0cmF0ZTogOTYsXG4gIH0sXG5cbiAgODM6IHtcbiAgICBtaW1lVHlwZTogJ3ZpZGVvL21wNDsgY29kZWNzPVwiSC4yNjQsIGFhY1wiJyxcbiAgICBxdWFsaXR5TGFiZWw6ICcyNDBwJyxcbiAgICBiaXRyYXRlOiA1MDAwMDAsXG4gICAgYXVkaW9CaXRyYXRlOiA5NixcbiAgfSxcblxuICA4NDoge1xuICAgIG1pbWVUeXBlOiAndmlkZW8vbXA0OyBjb2RlY3M9XCJILjI2NCwgYWFjXCInLFxuICAgIHF1YWxpdHlMYWJlbDogJzcyMHAnLFxuICAgIGJpdHJhdGU6IDIwMDAwMDAsXG4gICAgYXVkaW9CaXRyYXRlOiAxOTIsXG4gIH0sXG5cbiAgODU6IHtcbiAgICBtaW1lVHlwZTogJ3ZpZGVvL21wNDsgY29kZWNzPVwiSC4yNjQsIGFhY1wiJyxcbiAgICBxdWFsaXR5TGFiZWw6ICcxMDgwcCcsXG4gICAgYml0cmF0ZTogMzAwMDAwMCxcbiAgICBhdWRpb0JpdHJhdGU6IDE5MixcbiAgfSxcblxuICA5MToge1xuICAgIG1pbWVUeXBlOiAndmlkZW8vdHM7IGNvZGVjcz1cIkguMjY0LCBhYWNcIicsXG4gICAgcXVhbGl0eUxhYmVsOiAnMTQ0cCcsXG4gICAgYml0cmF0ZTogMTAwMDAwLFxuICAgIGF1ZGlvQml0cmF0ZTogNDgsXG4gIH0sXG5cbiAgOTI6IHtcbiAgICBtaW1lVHlwZTogJ3ZpZGVvL3RzOyBjb2RlY3M9XCJILjI2NCwgYWFjXCInLFxuICAgIHF1YWxpdHlMYWJlbDogJzI0MHAnLFxuICAgIGJpdHJhdGU6IDE1MDAwMCxcbiAgICBhdWRpb0JpdHJhdGU6IDQ4LFxuICB9LFxuXG4gIDkzOiB7XG4gICAgbWltZVR5cGU6ICd2aWRlby90czsgY29kZWNzPVwiSC4yNjQsIGFhY1wiJyxcbiAgICBxdWFsaXR5TGFiZWw6ICczNjBwJyxcbiAgICBiaXRyYXRlOiA1MDAwMDAsXG4gICAgYXVkaW9CaXRyYXRlOiAxMjgsXG4gIH0sXG5cbiAgOTQ6IHtcbiAgICBtaW1lVHlwZTogJ3ZpZGVvL3RzOyBjb2RlY3M9XCJILjI2NCwgYWFjXCInLFxuICAgIHF1YWxpdHlMYWJlbDogJzQ4MHAnLFxuICAgIGJpdHJhdGU6IDgwMDAwMCxcbiAgICBhdWRpb0JpdHJhdGU6IDEyOCxcbiAgfSxcblxuICA5NToge1xuICAgIG1pbWVUeXBlOiAndmlkZW8vdHM7IGNvZGVjcz1cIkguMjY0LCBhYWNcIicsXG4gICAgcXVhbGl0eUxhYmVsOiAnNzIwcCcsXG4gICAgYml0cmF0ZTogMTUwMDAwMCxcbiAgICBhdWRpb0JpdHJhdGU6IDI1NixcbiAgfSxcblxuICA5Njoge1xuICAgIG1pbWVUeXBlOiAndmlkZW8vdHM7IGNvZGVjcz1cIkguMjY0LCBhYWNcIicsXG4gICAgcXVhbGl0eUxhYmVsOiAnMTA4MHAnLFxuICAgIGJpdHJhdGU6IDI1MDAwMDAsXG4gICAgYXVkaW9CaXRyYXRlOiAyNTYsXG4gIH0sXG5cbiAgMTAwOiB7XG4gICAgbWltZVR5cGU6ICdhdWRpby93ZWJtOyBjb2RlY3M9XCJWUDgsIHZvcmJpc1wiJyxcbiAgICBxdWFsaXR5TGFiZWw6ICczNjBwJyxcbiAgICBiaXRyYXRlOiBudWxsLFxuICAgIGF1ZGlvQml0cmF0ZTogMTI4LFxuICB9LFxuXG4gIDEwMToge1xuICAgIG1pbWVUeXBlOiAnYXVkaW8vd2VibTsgY29kZWNzPVwiVlA4LCB2b3JiaXNcIicsXG4gICAgcXVhbGl0eUxhYmVsOiAnMzYwcCcsXG4gICAgYml0cmF0ZTogbnVsbCxcbiAgICBhdWRpb0JpdHJhdGU6IDE5MixcbiAgfSxcblxuICAxMDI6IHtcbiAgICBtaW1lVHlwZTogJ2F1ZGlvL3dlYm07IGNvZGVjcz1cIlZQOCwgdm9yYmlzXCInLFxuICAgIHF1YWxpdHlMYWJlbDogJzcyMHAnLFxuICAgIGJpdHJhdGU6IG51bGwsXG4gICAgYXVkaW9CaXRyYXRlOiAxOTIsXG4gIH0sXG5cbiAgMTIwOiB7XG4gICAgbWltZVR5cGU6ICd2aWRlby9mbHY7IGNvZGVjcz1cIkguMjY0LCBhYWNcIicsXG4gICAgcXVhbGl0eUxhYmVsOiAnNzIwcCcsXG4gICAgYml0cmF0ZTogMjAwMDAwMCxcbiAgICBhdWRpb0JpdHJhdGU6IDEyOCxcbiAgfSxcblxuICAxMjc6IHtcbiAgICBtaW1lVHlwZTogJ2F1ZGlvL3RzOyBjb2RlY3M9XCJhYWNcIicsXG4gICAgcXVhbGl0eUxhYmVsOiBudWxsLFxuICAgIGJpdHJhdGU6IG51bGwsXG4gICAgYXVkaW9CaXRyYXRlOiA5NixcbiAgfSxcblxuICAxMjg6IHtcbiAgICBtaW1lVHlwZTogJ2F1ZGlvL3RzOyBjb2RlY3M9XCJhYWNcIicsXG4gICAgcXVhbGl0eUxhYmVsOiBudWxsLFxuICAgIGJpdHJhdGU6IG51bGwsXG4gICAgYXVkaW9CaXRyYXRlOiA5NixcbiAgfSxcblxuICAxMzI6IHtcbiAgICBtaW1lVHlwZTogJ3ZpZGVvL3RzOyBjb2RlY3M9XCJILjI2NCwgYWFjXCInLFxuICAgIHF1YWxpdHlMYWJlbDogJzI0MHAnLFxuICAgIGJpdHJhdGU6IDE1MDAwMCxcbiAgICBhdWRpb0JpdHJhdGU6IDQ4LFxuICB9LFxuXG4gIDEzMzoge1xuICAgIG1pbWVUeXBlOiAndmlkZW8vbXA0OyBjb2RlY3M9XCJILjI2NFwiJyxcbiAgICBxdWFsaXR5TGFiZWw6ICcyNDBwJyxcbiAgICBiaXRyYXRlOiAyMDAwMDAsXG4gICAgYXVkaW9CaXRyYXRlOiBudWxsLFxuICB9LFxuXG4gIDEzNDoge1xuICAgIG1pbWVUeXBlOiAndmlkZW8vbXA0OyBjb2RlY3M9XCJILjI2NFwiJyxcbiAgICBxdWFsaXR5TGFiZWw6ICczNjBwJyxcbiAgICBiaXRyYXRlOiAzMDAwMDAsXG4gICAgYXVkaW9CaXRyYXRlOiBudWxsLFxuICB9LFxuXG4gIDEzNToge1xuICAgIG1pbWVUeXBlOiAndmlkZW8vbXA0OyBjb2RlY3M9XCJILjI2NFwiJyxcbiAgICBxdWFsaXR5TGFiZWw6ICc0ODBwJyxcbiAgICBiaXRyYXRlOiA1MDAwMDAsXG4gICAgYXVkaW9CaXRyYXRlOiBudWxsLFxuICB9LFxuXG4gIDEzNjoge1xuICAgIG1pbWVUeXBlOiAndmlkZW8vbXA0OyBjb2RlY3M9XCJILjI2NFwiJyxcbiAgICBxdWFsaXR5TGFiZWw6ICc3MjBwJyxcbiAgICBiaXRyYXRlOiAxMDAwMDAwLFxuICAgIGF1ZGlvQml0cmF0ZTogbnVsbCxcbiAgfSxcblxuICAxMzc6IHtcbiAgICBtaW1lVHlwZTogJ3ZpZGVvL21wNDsgY29kZWNzPVwiSC4yNjRcIicsXG4gICAgcXVhbGl0eUxhYmVsOiAnMTA4MHAnLFxuICAgIGJpdHJhdGU6IDI1MDAwMDAsXG4gICAgYXVkaW9CaXRyYXRlOiBudWxsLFxuICB9LFxuXG4gIDEzODoge1xuICAgIG1pbWVUeXBlOiAndmlkZW8vbXA0OyBjb2RlY3M9XCJILjI2NFwiJyxcbiAgICBxdWFsaXR5TGFiZWw6ICc0MzIwcCcsXG4gICAgYml0cmF0ZTogMTM1MDAwMDAsXG4gICAgYXVkaW9CaXRyYXRlOiBudWxsLFxuICB9LFxuXG4gIDEzOToge1xuICAgIG1pbWVUeXBlOiAnYXVkaW8vbXA0OyBjb2RlY3M9XCJhYWNcIicsXG4gICAgcXVhbGl0eUxhYmVsOiBudWxsLFxuICAgIGJpdHJhdGU6IG51bGwsXG4gICAgYXVkaW9CaXRyYXRlOiA0OCxcbiAgfSxcblxuICAxNDA6IHtcbiAgICBtaW1lVHlwZTogJ2F1ZGlvL200YTsgY29kZWNzPVwiYWFjXCInLFxuICAgIHF1YWxpdHlMYWJlbDogbnVsbCxcbiAgICBiaXRyYXRlOiBudWxsLFxuICAgIGF1ZGlvQml0cmF0ZTogMTI4LFxuICB9LFxuXG4gIDE0MToge1xuICAgIG1pbWVUeXBlOiAnYXVkaW8vbXA0OyBjb2RlY3M9XCJhYWNcIicsXG4gICAgcXVhbGl0eUxhYmVsOiBudWxsLFxuICAgIGJpdHJhdGU6IG51bGwsXG4gICAgYXVkaW9CaXRyYXRlOiAyNTYsXG4gIH0sXG5cbiAgMTUxOiB7XG4gICAgbWltZVR5cGU6ICd2aWRlby90czsgY29kZWNzPVwiSC4yNjQsIGFhY1wiJyxcbiAgICBxdWFsaXR5TGFiZWw6ICc3MjBwJyxcbiAgICBiaXRyYXRlOiA1MDAwMCxcbiAgICBhdWRpb0JpdHJhdGU6IDI0LFxuICB9LFxuXG4gIDE2MDoge1xuICAgIG1pbWVUeXBlOiAndmlkZW8vbXA0OyBjb2RlY3M9XCJILjI2NFwiJyxcbiAgICBxdWFsaXR5TGFiZWw6ICcxNDRwJyxcbiAgICBiaXRyYXRlOiAxMDAwMDAsXG4gICAgYXVkaW9CaXRyYXRlOiBudWxsLFxuICB9LFxuXG4gIDE3MToge1xuICAgIG1pbWVUeXBlOiAnYXVkaW8vd2VibTsgY29kZWNzPVwidm9yYmlzXCInLFxuICAgIHF1YWxpdHlMYWJlbDogbnVsbCxcbiAgICBiaXRyYXRlOiBudWxsLFxuICAgIGF1ZGlvQml0cmF0ZTogMTI4LFxuICB9LFxuXG4gIDE3Mjoge1xuICAgIG1pbWVUeXBlOiAnYXVkaW8vd2VibTsgY29kZWNzPVwidm9yYmlzXCInLFxuICAgIHF1YWxpdHlMYWJlbDogbnVsbCxcbiAgICBiaXRyYXRlOiBudWxsLFxuICAgIGF1ZGlvQml0cmF0ZTogMTkyLFxuICB9LFxuXG4gIDI0Mjoge1xuICAgIG1pbWVUeXBlOiAndmlkZW8vd2VibTsgY29kZWNzPVwiVlA5XCInLFxuICAgIHF1YWxpdHlMYWJlbDogJzI0MHAnLFxuICAgIGJpdHJhdGU6IDEwMDAwMCxcbiAgICBhdWRpb0JpdHJhdGU6IG51bGwsXG4gIH0sXG5cbiAgMjQzOiB7XG4gICAgbWltZVR5cGU6ICd2aWRlby93ZWJtOyBjb2RlY3M9XCJWUDlcIicsXG4gICAgcXVhbGl0eUxhYmVsOiAnMzYwcCcsXG4gICAgYml0cmF0ZTogMjUwMDAwLFxuICAgIGF1ZGlvQml0cmF0ZTogbnVsbCxcbiAgfSxcblxuICAyNDQ6IHtcbiAgICBtaW1lVHlwZTogJ3ZpZGVvL3dlYm07IGNvZGVjcz1cIlZQOVwiJyxcbiAgICBxdWFsaXR5TGFiZWw6ICc0ODBwJyxcbiAgICBiaXRyYXRlOiA1MDAwMDAsXG4gICAgYXVkaW9CaXRyYXRlOiBudWxsLFxuICB9LFxuXG4gIDI0Nzoge1xuICAgIG1pbWVUeXBlOiAndmlkZW8vd2VibTsgY29kZWNzPVwiVlA5XCInLFxuICAgIHF1YWxpdHlMYWJlbDogJzcyMHAnLFxuICAgIGJpdHJhdGU6IDcwMDAwMCxcbiAgICBhdWRpb0JpdHJhdGU6IG51bGwsXG4gIH0sXG5cbiAgMjQ4OiB7XG4gICAgbWltZVR5cGU6ICd2aWRlby93ZWJtOyBjb2RlY3M9XCJWUDlcIicsXG4gICAgcXVhbGl0eUxhYmVsOiAnMTA4MHAnLFxuICAgIGJpdHJhdGU6IDE1MDAwMDAsXG4gICAgYXVkaW9CaXRyYXRlOiBudWxsLFxuICB9LFxuXG4gIDI0OToge1xuICAgIG1pbWVUeXBlOiAnYXVkaW8vd2VibTsgY29kZWNzPVwib3B1c1wiJyxcbiAgICBxdWFsaXR5TGFiZWw6IG51bGwsXG4gICAgYml0cmF0ZTogbnVsbCxcbiAgICBhdWRpb0JpdHJhdGU6IDQ4LFxuICB9LFxuXG4gIDI1MDoge1xuICAgIG1pbWVUeXBlOiAnYXVkaW8vd2VibTsgY29kZWNzPVwib3B1c1wiJyxcbiAgICBxdWFsaXR5TGFiZWw6IG51bGwsXG4gICAgYml0cmF0ZTogbnVsbCxcbiAgICBhdWRpb0JpdHJhdGU6IDY0LFxuICB9LFxuXG4gIDI1MToge1xuICAgIG1pbWVUeXBlOiAnYXVkaW8vd2VibTsgY29kZWNzPVwib3B1c1wiJyxcbiAgICBxdWFsaXR5TGFiZWw6IG51bGwsXG4gICAgYml0cmF0ZTogbnVsbCxcbiAgICBhdWRpb0JpdHJhdGU6IDE2MCxcbiAgfSxcblxuICAyNjQ6IHtcbiAgICBtaW1lVHlwZTogJ3ZpZGVvL21wNDsgY29kZWNzPVwiSC4yNjRcIicsXG4gICAgcXVhbGl0eUxhYmVsOiAnMTQ0MHAnLFxuICAgIGJpdHJhdGU6IDQwMDAwMDAsXG4gICAgYXVkaW9CaXRyYXRlOiBudWxsLFxuICB9LFxuXG4gIDI2Njoge1xuICAgIG1pbWVUeXBlOiAndmlkZW8vbXA0OyBjb2RlY3M9XCJILjI2NFwiJyxcbiAgICBxdWFsaXR5TGFiZWw6ICcyMTYwcCcsXG4gICAgYml0cmF0ZTogMTI1MDAwMDAsXG4gICAgYXVkaW9CaXRyYXRlOiBudWxsLFxuICB9LFxuXG4gIDI3MToge1xuICAgIG1pbWVUeXBlOiAndmlkZW8vd2VibTsgY29kZWNzPVwiVlA5XCInLFxuICAgIHF1YWxpdHlMYWJlbDogJzE0NDBwJyxcbiAgICBiaXRyYXRlOiA5MDAwMDAwLFxuICAgIGF1ZGlvQml0cmF0ZTogbnVsbCxcbiAgfSxcblxuICAyNzI6IHtcbiAgICBtaW1lVHlwZTogJ3ZpZGVvL3dlYm07IGNvZGVjcz1cIlZQOVwiJyxcbiAgICBxdWFsaXR5TGFiZWw6ICc0MzIwcCcsXG4gICAgYml0cmF0ZTogMjAwMDAwMDAsXG4gICAgYXVkaW9CaXRyYXRlOiBudWxsLFxuICB9LFxuXG4gIDI3ODoge1xuICAgIG1pbWVUeXBlOiAndmlkZW8vd2VibTsgY29kZWNzPVwiVlA5XCInLFxuICAgIHF1YWxpdHlMYWJlbDogJzE0NHAgMzBmcHMnLFxuICAgIGJpdHJhdGU6IDgwMDAwLFxuICAgIGF1ZGlvQml0cmF0ZTogbnVsbCxcbiAgfSxcblxuICAyOTg6IHtcbiAgICBtaW1lVHlwZTogJ3ZpZGVvL21wNDsgY29kZWNzPVwiSC4yNjRcIicsXG4gICAgcXVhbGl0eUxhYmVsOiAnNzIwcCcsXG4gICAgYml0cmF0ZTogMzAwMDAwMCxcbiAgICBhdWRpb0JpdHJhdGU6IG51bGwsXG4gIH0sXG5cbiAgMjk5OiB7XG4gICAgbWltZVR5cGU6ICd2aWRlby9tcDQ7IGNvZGVjcz1cIkguMjY0XCInLFxuICAgIHF1YWxpdHlMYWJlbDogJzEwODBwJyxcbiAgICBiaXRyYXRlOiA1NTAwMDAwLFxuICAgIGF1ZGlvQml0cmF0ZTogbnVsbCxcbiAgfSxcblxuICAzMDA6IHtcbiAgICBtaW1lVHlwZTogJ3ZpZGVvL3RzOyBjb2RlY3M9XCJILjI2NCwgYWFjXCInLFxuICAgIHF1YWxpdHlMYWJlbDogJzcyMHAnLFxuICAgIGJpdHJhdGU6IDEzMTgwMDAsXG4gICAgYXVkaW9CaXRyYXRlOiA0OCxcbiAgfSxcblxuICAzMDI6IHtcbiAgICBtaW1lVHlwZTogJ3ZpZGVvL3dlYm07IGNvZGVjcz1cIlZQOVwiJyxcbiAgICBxdWFsaXR5TGFiZWw6ICc3MjBwIEhGUicsXG4gICAgYml0cmF0ZTogMjUwMDAwMCxcbiAgICBhdWRpb0JpdHJhdGU6IG51bGwsXG4gIH0sXG5cbiAgMzAzOiB7XG4gICAgbWltZVR5cGU6ICd2aWRlby93ZWJtOyBjb2RlY3M9XCJWUDlcIicsXG4gICAgcXVhbGl0eUxhYmVsOiAnMTA4MHAgSEZSJyxcbiAgICBiaXRyYXRlOiA1MDAwMDAwLFxuICAgIGF1ZGlvQml0cmF0ZTogbnVsbCxcbiAgfSxcblxuICAzMDg6IHtcbiAgICBtaW1lVHlwZTogJ3ZpZGVvL3dlYm07IGNvZGVjcz1cIlZQOVwiJyxcbiAgICBxdWFsaXR5TGFiZWw6ICcxNDQwcCBIRlInLFxuICAgIGJpdHJhdGU6IDEwMDAwMDAwLFxuICAgIGF1ZGlvQml0cmF0ZTogbnVsbCxcbiAgfSxcblxuICAzMTM6IHtcbiAgICBtaW1lVHlwZTogJ3ZpZGVvL3dlYm07IGNvZGVjcz1cIlZQOVwiJyxcbiAgICBxdWFsaXR5TGFiZWw6ICcyMTYwcCcsXG4gICAgYml0cmF0ZTogMTMwMDAwMDAsXG4gICAgYXVkaW9CaXRyYXRlOiBudWxsLFxuICB9LFxuXG4gIDMxNToge1xuICAgIG1pbWVUeXBlOiAndmlkZW8vd2VibTsgY29kZWNzPVwiVlA5XCInLFxuICAgIHF1YWxpdHlMYWJlbDogJzIxNjBwIEhGUicsXG4gICAgYml0cmF0ZTogMjAwMDAwMDAsXG4gICAgYXVkaW9CaXRyYXRlOiBudWxsLFxuICB9LFxuXG4gIDMzMDoge1xuICAgIG1pbWVUeXBlOiAndmlkZW8vd2VibTsgY29kZWNzPVwiVlA5XCInLFxuICAgIHF1YWxpdHlMYWJlbDogJzE0NHAgSERSLCBIRlInLFxuICAgIGJpdHJhdGU6IDgwMDAwLFxuICAgIGF1ZGlvQml0cmF0ZTogbnVsbCxcbiAgfSxcblxuICAzMzE6IHtcbiAgICBtaW1lVHlwZTogJ3ZpZGVvL3dlYm07IGNvZGVjcz1cIlZQOVwiJyxcbiAgICBxdWFsaXR5TGFiZWw6ICcyNDBwIEhEUiwgSEZSJyxcbiAgICBiaXRyYXRlOiAxMDAwMDAsXG4gICAgYXVkaW9CaXRyYXRlOiBudWxsLFxuICB9LFxuXG4gIDMzMjoge1xuICAgIG1pbWVUeXBlOiAndmlkZW8vd2VibTsgY29kZWNzPVwiVlA5XCInLFxuICAgIHF1YWxpdHlMYWJlbDogJzM2MHAgSERSLCBIRlInLFxuICAgIGJpdHJhdGU6IDI1MDAwMCxcbiAgICBhdWRpb0JpdHJhdGU6IG51bGwsXG4gIH0sXG5cbiAgMzMzOiB7XG4gICAgbWltZVR5cGU6ICd2aWRlby93ZWJtOyBjb2RlY3M9XCJWUDlcIicsXG4gICAgcXVhbGl0eUxhYmVsOiAnMjQwcCBIRFIsIEhGUicsXG4gICAgYml0cmF0ZTogNTAwMDAwLFxuICAgIGF1ZGlvQml0cmF0ZTogbnVsbCxcbiAgfSxcblxuICAzMzQ6IHtcbiAgICBtaW1lVHlwZTogJ3ZpZGVvL3dlYm07IGNvZGVjcz1cIlZQOVwiJyxcbiAgICBxdWFsaXR5TGFiZWw6ICc3MjBwIEhEUiwgSEZSJyxcbiAgICBiaXRyYXRlOiAxMDAwMDAwLFxuICAgIGF1ZGlvQml0cmF0ZTogbnVsbCxcbiAgfSxcblxuICAzMzU6IHtcbiAgICBtaW1lVHlwZTogJ3ZpZGVvL3dlYm07IGNvZGVjcz1cIlZQOVwiJyxcbiAgICBxdWFsaXR5TGFiZWw6ICcxMDgwcCBIRFIsIEhGUicsXG4gICAgYml0cmF0ZTogMTUwMDAwMCxcbiAgICBhdWRpb0JpdHJhdGU6IG51bGwsXG4gIH0sXG5cbiAgMzM2OiB7XG4gICAgbWltZVR5cGU6ICd2aWRlby93ZWJtOyBjb2RlY3M9XCJWUDlcIicsXG4gICAgcXVhbGl0eUxhYmVsOiAnMTQ0MHAgSERSLCBIRlInLFxuICAgIGJpdHJhdGU6IDUwMDAwMDAsXG4gICAgYXVkaW9CaXRyYXRlOiBudWxsLFxuICB9LFxuXG4gIDMzNzoge1xuICAgIG1pbWVUeXBlOiAndmlkZW8vd2VibTsgY29kZWNzPVwiVlA5XCInLFxuICAgIHF1YWxpdHlMYWJlbDogJzIxNjBwIEhEUiwgSEZSJyxcbiAgICBiaXRyYXRlOiAxMjAwMDAwMCxcbiAgICBhdWRpb0JpdHJhdGU6IG51bGwsXG4gIH0sXG5cbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ytdl-core/lib/formats.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ytdl-core/lib/index.js":
/*!*********************************************!*\
  !*** ./node_modules/ytdl-core/lib/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const PassThrough = (__webpack_require__(/*! stream */ \"stream\").PassThrough);\nconst getInfo = __webpack_require__(/*! ./info */ \"(rsc)/./node_modules/ytdl-core/lib/info.js\");\nconst utils = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/ytdl-core/lib/utils.js\");\nconst formatUtils = __webpack_require__(/*! ./format-utils */ \"(rsc)/./node_modules/ytdl-core/lib/format-utils.js\");\nconst urlUtils = __webpack_require__(/*! ./url-utils */ \"(rsc)/./node_modules/ytdl-core/lib/url-utils.js\");\nconst sig = __webpack_require__(/*! ./sig */ \"(rsc)/./node_modules/ytdl-core/lib/sig.js\");\nconst miniget = __webpack_require__(/*! miniget */ \"(rsc)/./node_modules/miniget/dist/index.js\");\nconst m3u8stream = __webpack_require__(/*! m3u8stream */ \"(rsc)/./node_modules/m3u8stream/dist/index.js\");\nconst { parseTimestamp } = __webpack_require__(/*! m3u8stream */ \"(rsc)/./node_modules/m3u8stream/dist/index.js\");\n\n\n/**\n * @param {string} link\n * @param {!Object} options\n * @returns {ReadableStream}\n */\nconst ytdl = (link, options) => {\n  const stream = createStream(options);\n  ytdl.getInfo(link, options).then(info => {\n    downloadFromInfoCallback(stream, info, options);\n  }, stream.emit.bind(stream, 'error'));\n  return stream;\n};\nmodule.exports = ytdl;\n\nytdl.getBasicInfo = getInfo.getBasicInfo;\nytdl.getInfo = getInfo.getInfo;\nytdl.chooseFormat = formatUtils.chooseFormat;\nytdl.filterFormats = formatUtils.filterFormats;\nytdl.validateID = urlUtils.validateID;\nytdl.validateURL = urlUtils.validateURL;\nytdl.getURLVideoID = urlUtils.getURLVideoID;\nytdl.getVideoID = urlUtils.getVideoID;\nytdl.cache = {\n  sig: sig.cache,\n  info: getInfo.cache,\n  watch: getInfo.watchPageCache,\n  cookie: getInfo.cookieCache,\n};\nytdl.version = (__webpack_require__(/*! ../package.json */ \"(rsc)/./node_modules/ytdl-core/package.json\").version);\n\n\nconst createStream = options => {\n  const stream = new PassThrough({\n    highWaterMark: (options && options.highWaterMark) || 1024 * 512,\n  });\n  stream._destroy = () => { stream.destroyed = true; };\n  return stream;\n};\n\n\nconst pipeAndSetEvents = (req, stream, end) => {\n  // Forward events from the request to the stream.\n  [\n    'abort', 'request', 'response', 'error', 'redirect', 'retry', 'reconnect',\n  ].forEach(event => {\n    req.prependListener(event, stream.emit.bind(stream, event));\n  });\n  req.pipe(stream, { end });\n};\n\n\n/**\n * Chooses a format to download.\n *\n * @param {stream.Readable} stream\n * @param {Object} info\n * @param {Object} options\n */\nconst downloadFromInfoCallback = (stream, info, options) => {\n  options = options || {};\n\n  let err = utils.playError(info.player_response, ['UNPLAYABLE', 'LIVE_STREAM_OFFLINE', 'LOGIN_REQUIRED']);\n  if (err) {\n    stream.emit('error', err);\n    return;\n  }\n\n  if (!info.formats.length) {\n    stream.emit('error', Error('This video is unavailable'));\n    return;\n  }\n\n  let format;\n  try {\n    format = formatUtils.chooseFormat(info.formats, options);\n  } catch (e) {\n    stream.emit('error', e);\n    return;\n  }\n  stream.emit('info', info, format);\n  if (stream.destroyed) { return; }\n\n  let contentLength, downloaded = 0;\n  const ondata = chunk => {\n    downloaded += chunk.length;\n    stream.emit('progress', chunk.length, downloaded, contentLength);\n  };\n\n  if (options.IPv6Block) {\n    options.requestOptions = Object.assign({}, options.requestOptions, {\n      family: 6,\n      localAddress: utils.getRandomIPv6(options.IPv6Block),\n    });\n  }\n\n  // Download the file in chunks, in this case the default is 10MB,\n  // anything over this will cause youtube to throttle the download\n  const dlChunkSize = options.dlChunkSize || 1024 * 1024 * 10;\n  let req;\n  let shouldEnd = true;\n\n  if (format.isHLS || format.isDashMPD) {\n    req = m3u8stream(format.url, {\n      chunkReadahead: +info.live_chunk_readahead,\n      begin: options.begin || (format.isLive && Date.now()),\n      liveBuffer: options.liveBuffer,\n      requestOptions: options.requestOptions,\n      parser: format.isDashMPD ? 'dash-mpd' : 'm3u8',\n      id: format.itag,\n    });\n\n    req.on('progress', (segment, totalSegments) => {\n      stream.emit('progress', segment.size, segment.num, totalSegments);\n    });\n    pipeAndSetEvents(req, stream, shouldEnd);\n  } else {\n    const requestOptions = Object.assign({}, options.requestOptions, {\n      maxReconnects: 6,\n      maxRetries: 3,\n      backoff: { inc: 500, max: 10000 },\n    });\n\n    let shouldBeChunked = dlChunkSize !== 0 && (!format.hasAudio || !format.hasVideo);\n\n    if (shouldBeChunked) {\n      let start = (options.range && options.range.start) || 0;\n      let end = start + dlChunkSize;\n      const rangeEnd = options.range && options.range.end;\n\n      contentLength = options.range ?\n        (rangeEnd ? rangeEnd + 1 : parseInt(format.contentLength)) - start :\n        parseInt(format.contentLength);\n\n      const getNextChunk = () => {\n        if (!rangeEnd && end >= contentLength) end = 0;\n        if (rangeEnd && end > rangeEnd) end = rangeEnd;\n        shouldEnd = !end || end === rangeEnd;\n\n        requestOptions.headers = Object.assign({}, requestOptions.headers, {\n          Range: `bytes=${start}-${end || ''}`,\n        });\n\n        req = miniget(format.url, requestOptions);\n        req.on('data', ondata);\n        req.on('end', () => {\n          if (stream.destroyed) { return; }\n          if (end && end !== rangeEnd) {\n            start = end + 1;\n            end += dlChunkSize;\n            getNextChunk();\n          }\n        });\n        pipeAndSetEvents(req, stream, shouldEnd);\n      };\n      getNextChunk();\n    } else {\n      // Audio only and video only formats don't support begin\n      if (options.begin) {\n        format.url += `&begin=${parseTimestamp(options.begin)}`;\n      }\n      if (options.range && (options.range.start || options.range.end)) {\n        requestOptions.headers = Object.assign({}, requestOptions.headers, {\n          Range: `bytes=${options.range.start || '0'}-${options.range.end || ''}`,\n        });\n      }\n      req = miniget(format.url, requestOptions);\n      req.on('response', res => {\n        if (stream.destroyed) { return; }\n        contentLength = contentLength || parseInt(res.headers['content-length']);\n      });\n      req.on('data', ondata);\n      pipeAndSetEvents(req, stream, shouldEnd);\n    }\n  }\n\n  stream._destroy = () => {\n    stream.destroyed = true;\n    req.destroy();\n    req.end();\n  };\n};\n\n\n/**\n * Can be used to download video after its `info` is gotten through\n * `ytdl.getInfo()`. In case the user might want to look at the\n * `info` object before deciding to download.\n *\n * @param {Object} info\n * @param {!Object} options\n * @returns {ReadableStream}\n */\nytdl.downloadFromInfo = (info, options) => {\n  const stream = createStream(options);\n  if (!info.full) {\n    throw Error('Cannot use `ytdl.downloadFromInfo()` when called ' +\n      'with info from `ytdl.getBasicInfo()`');\n  }\n  setImmediate(() => {\n    downloadFromInfoCallback(stream, info, options);\n  });\n  return stream;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMveXRkbC1jb3JlL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxvQkFBb0IseURBQTZCO0FBQ2pELGdCQUFnQixtQkFBTyxDQUFDLDBEQUFRO0FBQ2hDLGNBQWMsbUJBQU8sQ0FBQyw0REFBUztBQUMvQixvQkFBb0IsbUJBQU8sQ0FBQywwRUFBZ0I7QUFDNUMsaUJBQWlCLG1CQUFPLENBQUMsb0VBQWE7QUFDdEMsWUFBWSxtQkFBTyxDQUFDLHdEQUFPO0FBQzNCLGdCQUFnQixtQkFBTyxDQUFDLDJEQUFTO0FBQ2pDLG1CQUFtQixtQkFBTyxDQUFDLGlFQUFZO0FBQ3ZDLFFBQVEsaUJBQWlCLEVBQUUsbUJBQU8sQ0FBQyxpRUFBWTs7O0FBRy9DO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUdBQWtDOzs7QUFHakQ7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILDRCQUE0QjtBQUM1QjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gscUJBQXFCLEtBQUs7QUFDMUI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCOztBQUUxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsSUFBSTtBQUNKLDJDQUEyQztBQUMzQztBQUNBO0FBQ0EsaUJBQWlCLHNCQUFzQjtBQUN2QyxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpREFBaUQ7QUFDakQsMEJBQTBCLE1BQU0sR0FBRyxVQUFVO0FBQzdDLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxnQ0FBZ0MsOEJBQThCO0FBQzlEO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQsMEJBQTBCLDJCQUEyQixHQUFHLHdCQUF3QjtBQUNoRixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGFnZ3ltXFxPbmVEcml2ZVxcRGVza3RvcFxccHJvamVjdHNcXHlvdXR1YmVfc3VtbWFyaXplclxcbm9kZV9tb2R1bGVzXFx5dGRsLWNvcmVcXGxpYlxcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgUGFzc1Rocm91Z2ggPSByZXF1aXJlKCdzdHJlYW0nKS5QYXNzVGhyb3VnaDtcbmNvbnN0IGdldEluZm8gPSByZXF1aXJlKCcuL2luZm8nKTtcbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuY29uc3QgZm9ybWF0VXRpbHMgPSByZXF1aXJlKCcuL2Zvcm1hdC11dGlscycpO1xuY29uc3QgdXJsVXRpbHMgPSByZXF1aXJlKCcuL3VybC11dGlscycpO1xuY29uc3Qgc2lnID0gcmVxdWlyZSgnLi9zaWcnKTtcbmNvbnN0IG1pbmlnZXQgPSByZXF1aXJlKCdtaW5pZ2V0Jyk7XG5jb25zdCBtM3U4c3RyZWFtID0gcmVxdWlyZSgnbTN1OHN0cmVhbScpO1xuY29uc3QgeyBwYXJzZVRpbWVzdGFtcCB9ID0gcmVxdWlyZSgnbTN1OHN0cmVhbScpO1xuXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGxpbmtcbiAqIEBwYXJhbSB7IU9iamVjdH0gb3B0aW9uc1xuICogQHJldHVybnMge1JlYWRhYmxlU3RyZWFtfVxuICovXG5jb25zdCB5dGRsID0gKGxpbmssIG9wdGlvbnMpID0+IHtcbiAgY29uc3Qgc3RyZWFtID0gY3JlYXRlU3RyZWFtKG9wdGlvbnMpO1xuICB5dGRsLmdldEluZm8obGluaywgb3B0aW9ucykudGhlbihpbmZvID0+IHtcbiAgICBkb3dubG9hZEZyb21JbmZvQ2FsbGJhY2soc3RyZWFtLCBpbmZvLCBvcHRpb25zKTtcbiAgfSwgc3RyZWFtLmVtaXQuYmluZChzdHJlYW0sICdlcnJvcicpKTtcbiAgcmV0dXJuIHN0cmVhbTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IHl0ZGw7XG5cbnl0ZGwuZ2V0QmFzaWNJbmZvID0gZ2V0SW5mby5nZXRCYXNpY0luZm87XG55dGRsLmdldEluZm8gPSBnZXRJbmZvLmdldEluZm87XG55dGRsLmNob29zZUZvcm1hdCA9IGZvcm1hdFV0aWxzLmNob29zZUZvcm1hdDtcbnl0ZGwuZmlsdGVyRm9ybWF0cyA9IGZvcm1hdFV0aWxzLmZpbHRlckZvcm1hdHM7XG55dGRsLnZhbGlkYXRlSUQgPSB1cmxVdGlscy52YWxpZGF0ZUlEO1xueXRkbC52YWxpZGF0ZVVSTCA9IHVybFV0aWxzLnZhbGlkYXRlVVJMO1xueXRkbC5nZXRVUkxWaWRlb0lEID0gdXJsVXRpbHMuZ2V0VVJMVmlkZW9JRDtcbnl0ZGwuZ2V0VmlkZW9JRCA9IHVybFV0aWxzLmdldFZpZGVvSUQ7XG55dGRsLmNhY2hlID0ge1xuICBzaWc6IHNpZy5jYWNoZSxcbiAgaW5mbzogZ2V0SW5mby5jYWNoZSxcbiAgd2F0Y2g6IGdldEluZm8ud2F0Y2hQYWdlQ2FjaGUsXG4gIGNvb2tpZTogZ2V0SW5mby5jb29raWVDYWNoZSxcbn07XG55dGRsLnZlcnNpb24gPSByZXF1aXJlKCcuLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9uO1xuXG5cbmNvbnN0IGNyZWF0ZVN0cmVhbSA9IG9wdGlvbnMgPT4ge1xuICBjb25zdCBzdHJlYW0gPSBuZXcgUGFzc1Rocm91Z2goe1xuICAgIGhpZ2hXYXRlck1hcms6IChvcHRpb25zICYmIG9wdGlvbnMuaGlnaFdhdGVyTWFyaykgfHwgMTAyNCAqIDUxMixcbiAgfSk7XG4gIHN0cmVhbS5fZGVzdHJveSA9ICgpID0+IHsgc3RyZWFtLmRlc3Ryb3llZCA9IHRydWU7IH07XG4gIHJldHVybiBzdHJlYW07XG59O1xuXG5cbmNvbnN0IHBpcGVBbmRTZXRFdmVudHMgPSAocmVxLCBzdHJlYW0sIGVuZCkgPT4ge1xuICAvLyBGb3J3YXJkIGV2ZW50cyBmcm9tIHRoZSByZXF1ZXN0IHRvIHRoZSBzdHJlYW0uXG4gIFtcbiAgICAnYWJvcnQnLCAncmVxdWVzdCcsICdyZXNwb25zZScsICdlcnJvcicsICdyZWRpcmVjdCcsICdyZXRyeScsICdyZWNvbm5lY3QnLFxuICBdLmZvckVhY2goZXZlbnQgPT4ge1xuICAgIHJlcS5wcmVwZW5kTGlzdGVuZXIoZXZlbnQsIHN0cmVhbS5lbWl0LmJpbmQoc3RyZWFtLCBldmVudCkpO1xuICB9KTtcbiAgcmVxLnBpcGUoc3RyZWFtLCB7IGVuZCB9KTtcbn07XG5cblxuLyoqXG4gKiBDaG9vc2VzIGEgZm9ybWF0IHRvIGRvd25sb2FkLlxuICpcbiAqIEBwYXJhbSB7c3RyZWFtLlJlYWRhYmxlfSBzdHJlYW1cbiAqIEBwYXJhbSB7T2JqZWN0fSBpbmZvXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICovXG5jb25zdCBkb3dubG9hZEZyb21JbmZvQ2FsbGJhY2sgPSAoc3RyZWFtLCBpbmZvLCBvcHRpb25zKSA9PiB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIGxldCBlcnIgPSB1dGlscy5wbGF5RXJyb3IoaW5mby5wbGF5ZXJfcmVzcG9uc2UsIFsnVU5QTEFZQUJMRScsICdMSVZFX1NUUkVBTV9PRkZMSU5FJywgJ0xPR0lOX1JFUVVJUkVEJ10pO1xuICBpZiAoZXJyKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoIWluZm8uZm9ybWF0cy5sZW5ndGgpIHtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBFcnJvcignVGhpcyB2aWRlbyBpcyB1bmF2YWlsYWJsZScpKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBsZXQgZm9ybWF0O1xuICB0cnkge1xuICAgIGZvcm1hdCA9IGZvcm1hdFV0aWxzLmNob29zZUZvcm1hdChpbmZvLmZvcm1hdHMsIG9wdGlvbnMpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHN0cmVhbS5lbWl0KCdpbmZvJywgaW5mbywgZm9ybWF0KTtcbiAgaWYgKHN0cmVhbS5kZXN0cm95ZWQpIHsgcmV0dXJuOyB9XG5cbiAgbGV0IGNvbnRlbnRMZW5ndGgsIGRvd25sb2FkZWQgPSAwO1xuICBjb25zdCBvbmRhdGEgPSBjaHVuayA9PiB7XG4gICAgZG93bmxvYWRlZCArPSBjaHVuay5sZW5ndGg7XG4gICAgc3RyZWFtLmVtaXQoJ3Byb2dyZXNzJywgY2h1bmsubGVuZ3RoLCBkb3dubG9hZGVkLCBjb250ZW50TGVuZ3RoKTtcbiAgfTtcblxuICBpZiAob3B0aW9ucy5JUHY2QmxvY2spIHtcbiAgICBvcHRpb25zLnJlcXVlc3RPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucy5yZXF1ZXN0T3B0aW9ucywge1xuICAgICAgZmFtaWx5OiA2LFxuICAgICAgbG9jYWxBZGRyZXNzOiB1dGlscy5nZXRSYW5kb21JUHY2KG9wdGlvbnMuSVB2NkJsb2NrKSxcbiAgICB9KTtcbiAgfVxuXG4gIC8vIERvd25sb2FkIHRoZSBmaWxlIGluIGNodW5rcywgaW4gdGhpcyBjYXNlIHRoZSBkZWZhdWx0IGlzIDEwTUIsXG4gIC8vIGFueXRoaW5nIG92ZXIgdGhpcyB3aWxsIGNhdXNlIHlvdXR1YmUgdG8gdGhyb3R0bGUgdGhlIGRvd25sb2FkXG4gIGNvbnN0IGRsQ2h1bmtTaXplID0gb3B0aW9ucy5kbENodW5rU2l6ZSB8fCAxMDI0ICogMTAyNCAqIDEwO1xuICBsZXQgcmVxO1xuICBsZXQgc2hvdWxkRW5kID0gdHJ1ZTtcblxuICBpZiAoZm9ybWF0LmlzSExTIHx8IGZvcm1hdC5pc0Rhc2hNUEQpIHtcbiAgICByZXEgPSBtM3U4c3RyZWFtKGZvcm1hdC51cmwsIHtcbiAgICAgIGNodW5rUmVhZGFoZWFkOiAraW5mby5saXZlX2NodW5rX3JlYWRhaGVhZCxcbiAgICAgIGJlZ2luOiBvcHRpb25zLmJlZ2luIHx8IChmb3JtYXQuaXNMaXZlICYmIERhdGUubm93KCkpLFxuICAgICAgbGl2ZUJ1ZmZlcjogb3B0aW9ucy5saXZlQnVmZmVyLFxuICAgICAgcmVxdWVzdE9wdGlvbnM6IG9wdGlvbnMucmVxdWVzdE9wdGlvbnMsXG4gICAgICBwYXJzZXI6IGZvcm1hdC5pc0Rhc2hNUEQgPyAnZGFzaC1tcGQnIDogJ20zdTgnLFxuICAgICAgaWQ6IGZvcm1hdC5pdGFnLFxuICAgIH0pO1xuXG4gICAgcmVxLm9uKCdwcm9ncmVzcycsIChzZWdtZW50LCB0b3RhbFNlZ21lbnRzKSA9PiB7XG4gICAgICBzdHJlYW0uZW1pdCgncHJvZ3Jlc3MnLCBzZWdtZW50LnNpemUsIHNlZ21lbnQubnVtLCB0b3RhbFNlZ21lbnRzKTtcbiAgICB9KTtcbiAgICBwaXBlQW5kU2V0RXZlbnRzKHJlcSwgc3RyZWFtLCBzaG91bGRFbmQpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHJlcXVlc3RPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucy5yZXF1ZXN0T3B0aW9ucywge1xuICAgICAgbWF4UmVjb25uZWN0czogNixcbiAgICAgIG1heFJldHJpZXM6IDMsXG4gICAgICBiYWNrb2ZmOiB7IGluYzogNTAwLCBtYXg6IDEwMDAwIH0sXG4gICAgfSk7XG5cbiAgICBsZXQgc2hvdWxkQmVDaHVua2VkID0gZGxDaHVua1NpemUgIT09IDAgJiYgKCFmb3JtYXQuaGFzQXVkaW8gfHwgIWZvcm1hdC5oYXNWaWRlbyk7XG5cbiAgICBpZiAoc2hvdWxkQmVDaHVua2VkKSB7XG4gICAgICBsZXQgc3RhcnQgPSAob3B0aW9ucy5yYW5nZSAmJiBvcHRpb25zLnJhbmdlLnN0YXJ0KSB8fCAwO1xuICAgICAgbGV0IGVuZCA9IHN0YXJ0ICsgZGxDaHVua1NpemU7XG4gICAgICBjb25zdCByYW5nZUVuZCA9IG9wdGlvbnMucmFuZ2UgJiYgb3B0aW9ucy5yYW5nZS5lbmQ7XG5cbiAgICAgIGNvbnRlbnRMZW5ndGggPSBvcHRpb25zLnJhbmdlID9cbiAgICAgICAgKHJhbmdlRW5kID8gcmFuZ2VFbmQgKyAxIDogcGFyc2VJbnQoZm9ybWF0LmNvbnRlbnRMZW5ndGgpKSAtIHN0YXJ0IDpcbiAgICAgICAgcGFyc2VJbnQoZm9ybWF0LmNvbnRlbnRMZW5ndGgpO1xuXG4gICAgICBjb25zdCBnZXROZXh0Q2h1bmsgPSAoKSA9PiB7XG4gICAgICAgIGlmICghcmFuZ2VFbmQgJiYgZW5kID49IGNvbnRlbnRMZW5ndGgpIGVuZCA9IDA7XG4gICAgICAgIGlmIChyYW5nZUVuZCAmJiBlbmQgPiByYW5nZUVuZCkgZW5kID0gcmFuZ2VFbmQ7XG4gICAgICAgIHNob3VsZEVuZCA9ICFlbmQgfHwgZW5kID09PSByYW5nZUVuZDtcblxuICAgICAgICByZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgcmVxdWVzdE9wdGlvbnMuaGVhZGVycywge1xuICAgICAgICAgIFJhbmdlOiBgYnl0ZXM9JHtzdGFydH0tJHtlbmQgfHwgJyd9YCxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmVxID0gbWluaWdldChmb3JtYXQudXJsLCByZXF1ZXN0T3B0aW9ucyk7XG4gICAgICAgIHJlcS5vbignZGF0YScsIG9uZGF0YSk7XG4gICAgICAgIHJlcS5vbignZW5kJywgKCkgPT4ge1xuICAgICAgICAgIGlmIChzdHJlYW0uZGVzdHJveWVkKSB7IHJldHVybjsgfVxuICAgICAgICAgIGlmIChlbmQgJiYgZW5kICE9PSByYW5nZUVuZCkge1xuICAgICAgICAgICAgc3RhcnQgPSBlbmQgKyAxO1xuICAgICAgICAgICAgZW5kICs9IGRsQ2h1bmtTaXplO1xuICAgICAgICAgICAgZ2V0TmV4dENodW5rKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcGlwZUFuZFNldEV2ZW50cyhyZXEsIHN0cmVhbSwgc2hvdWxkRW5kKTtcbiAgICAgIH07XG4gICAgICBnZXROZXh0Q2h1bmsoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQXVkaW8gb25seSBhbmQgdmlkZW8gb25seSBmb3JtYXRzIGRvbid0IHN1cHBvcnQgYmVnaW5cbiAgICAgIGlmIChvcHRpb25zLmJlZ2luKSB7XG4gICAgICAgIGZvcm1hdC51cmwgKz0gYCZiZWdpbj0ke3BhcnNlVGltZXN0YW1wKG9wdGlvbnMuYmVnaW4pfWA7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5yYW5nZSAmJiAob3B0aW9ucy5yYW5nZS5zdGFydCB8fCBvcHRpb25zLnJhbmdlLmVuZCkpIHtcbiAgICAgICAgcmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oe30sIHJlcXVlc3RPcHRpb25zLmhlYWRlcnMsIHtcbiAgICAgICAgICBSYW5nZTogYGJ5dGVzPSR7b3B0aW9ucy5yYW5nZS5zdGFydCB8fCAnMCd9LSR7b3B0aW9ucy5yYW5nZS5lbmQgfHwgJyd9YCxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXEgPSBtaW5pZ2V0KGZvcm1hdC51cmwsIHJlcXVlc3RPcHRpb25zKTtcbiAgICAgIHJlcS5vbigncmVzcG9uc2UnLCByZXMgPT4ge1xuICAgICAgICBpZiAoc3RyZWFtLmRlc3Ryb3llZCkgeyByZXR1cm47IH1cbiAgICAgICAgY29udGVudExlbmd0aCA9IGNvbnRlbnRMZW5ndGggfHwgcGFyc2VJbnQocmVzLmhlYWRlcnNbJ2NvbnRlbnQtbGVuZ3RoJ10pO1xuICAgICAgfSk7XG4gICAgICByZXEub24oJ2RhdGEnLCBvbmRhdGEpO1xuICAgICAgcGlwZUFuZFNldEV2ZW50cyhyZXEsIHN0cmVhbSwgc2hvdWxkRW5kKTtcbiAgICB9XG4gIH1cblxuICBzdHJlYW0uX2Rlc3Ryb3kgPSAoKSA9PiB7XG4gICAgc3RyZWFtLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgcmVxLmRlc3Ryb3koKTtcbiAgICByZXEuZW5kKCk7XG4gIH07XG59O1xuXG5cbi8qKlxuICogQ2FuIGJlIHVzZWQgdG8gZG93bmxvYWQgdmlkZW8gYWZ0ZXIgaXRzIGBpbmZvYCBpcyBnb3R0ZW4gdGhyb3VnaFxuICogYHl0ZGwuZ2V0SW5mbygpYC4gSW4gY2FzZSB0aGUgdXNlciBtaWdodCB3YW50IHRvIGxvb2sgYXQgdGhlXG4gKiBgaW5mb2Agb2JqZWN0IGJlZm9yZSBkZWNpZGluZyB0byBkb3dubG9hZC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gaW5mb1xuICogQHBhcmFtIHshT2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJucyB7UmVhZGFibGVTdHJlYW19XG4gKi9cbnl0ZGwuZG93bmxvYWRGcm9tSW5mbyA9IChpbmZvLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHN0cmVhbSA9IGNyZWF0ZVN0cmVhbShvcHRpb25zKTtcbiAgaWYgKCFpbmZvLmZ1bGwpIHtcbiAgICB0aHJvdyBFcnJvcignQ2Fubm90IHVzZSBgeXRkbC5kb3dubG9hZEZyb21JbmZvKClgIHdoZW4gY2FsbGVkICcgK1xuICAgICAgJ3dpdGggaW5mbyBmcm9tIGB5dGRsLmdldEJhc2ljSW5mbygpYCcpO1xuICB9XG4gIHNldEltbWVkaWF0ZSgoKSA9PiB7XG4gICAgZG93bmxvYWRGcm9tSW5mb0NhbGxiYWNrKHN0cmVhbSwgaW5mbywgb3B0aW9ucyk7XG4gIH0pO1xuICByZXR1cm4gc3RyZWFtO1xufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ytdl-core/lib/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ytdl-core/lib/info-extras.js":
/*!***************************************************!*\
  !*** ./node_modules/ytdl-core/lib/info-extras.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("const utils = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/ytdl-core/lib/utils.js\");\nconst qs = __webpack_require__(/*! querystring */ \"querystring\");\nconst { parseTimestamp } = __webpack_require__(/*! m3u8stream */ \"(rsc)/./node_modules/m3u8stream/dist/index.js\");\n\n\nconst BASE_URL = 'https://www.youtube.com/watch?v=';\nconst TITLE_TO_CATEGORY = {\n  song: { name: 'Music', url: 'https://music.youtube.com/' },\n};\n\nconst getText = obj => obj ? obj.runs ? obj.runs[0].text : obj.simpleText : null;\n\n\n/**\n * Get video media.\n *\n * @param {Object} info\n * @returns {Object}\n */\nexports.getMedia = info => {\n  let media = {};\n  let results = [];\n  try {\n    results = info.response.contents.twoColumnWatchNextResults.results.results.contents;\n  } catch (err) {\n    // Do nothing\n  }\n\n  let result = results.find(v => v.videoSecondaryInfoRenderer);\n  if (!result) { return {}; }\n\n  try {\n    let metadataRows =\n      (result.metadataRowContainer || result.videoSecondaryInfoRenderer.metadataRowContainer)\n        .metadataRowContainerRenderer.rows;\n    for (let row of metadataRows) {\n      if (row.metadataRowRenderer) {\n        let title = getText(row.metadataRowRenderer.title).toLowerCase();\n        let contents = row.metadataRowRenderer.contents[0];\n        media[title] = getText(contents);\n        let runs = contents.runs;\n        if (runs && runs[0].navigationEndpoint) {\n          media[`${title}_url`] = new URL(\n            runs[0].navigationEndpoint.commandMetadata.webCommandMetadata.url, BASE_URL).toString();\n        }\n        if (title in TITLE_TO_CATEGORY) {\n          media.category = TITLE_TO_CATEGORY[title].name;\n          media.category_url = TITLE_TO_CATEGORY[title].url;\n        }\n      } else if (row.richMetadataRowRenderer) {\n        let contents = row.richMetadataRowRenderer.contents;\n        let boxArt = contents\n          .filter(meta => meta.richMetadataRenderer.style === 'RICH_METADATA_RENDERER_STYLE_BOX_ART');\n        for (let { richMetadataRenderer } of boxArt) {\n          let meta = richMetadataRenderer;\n          media.year = getText(meta.subtitle);\n          let type = getText(meta.callToAction).split(' ')[1];\n          media[type] = getText(meta.title);\n          media[`${type}_url`] = new URL(\n            meta.endpoint.commandMetadata.webCommandMetadata.url, BASE_URL).toString();\n          media.thumbnails = meta.thumbnail.thumbnails;\n        }\n        let topic = contents\n          .filter(meta => meta.richMetadataRenderer.style === 'RICH_METADATA_RENDERER_STYLE_TOPIC');\n        for (let { richMetadataRenderer } of topic) {\n          let meta = richMetadataRenderer;\n          media.category = getText(meta.title);\n          media.category_url = new URL(\n            meta.endpoint.commandMetadata.webCommandMetadata.url, BASE_URL).toString();\n        }\n      }\n    }\n  } catch (err) {\n    // Do nothing.\n  }\n\n  return media;\n};\n\n\nconst isVerified = badges => !!(badges && badges.find(b => b.metadataBadgeRenderer.tooltip === 'Verified'));\n\n\n/**\n * Get video author.\n *\n * @param {Object} info\n * @returns {Object}\n */\nexports.getAuthor = info => {\n  let channelId, thumbnails = [], subscriberCount, verified = false;\n  try {\n    let results = info.response.contents.twoColumnWatchNextResults.results.results.contents;\n    let v = results.find(v2 =>\n      v2.videoSecondaryInfoRenderer &&\n      v2.videoSecondaryInfoRenderer.owner &&\n      v2.videoSecondaryInfoRenderer.owner.videoOwnerRenderer);\n    let videoOwnerRenderer = v.videoSecondaryInfoRenderer.owner.videoOwnerRenderer;\n    channelId = videoOwnerRenderer.navigationEndpoint.browseEndpoint.browseId;\n    thumbnails = videoOwnerRenderer.thumbnail.thumbnails.map(thumbnail => {\n      thumbnail.url = new URL(thumbnail.url, BASE_URL).toString();\n      return thumbnail;\n    });\n    subscriberCount = utils.parseAbbreviatedNumber(getText(videoOwnerRenderer.subscriberCountText));\n    verified = isVerified(videoOwnerRenderer.badges);\n  } catch (err) {\n    // Do nothing.\n  }\n  try {\n    let videoDetails = info.player_response.microformat && info.player_response.microformat.playerMicroformatRenderer;\n    let id = (videoDetails && videoDetails.channelId) || channelId || info.player_response.videoDetails.channelId;\n    let author = {\n      id: id,\n      name: videoDetails ? videoDetails.ownerChannelName : info.player_response.videoDetails.author,\n      user: videoDetails ? videoDetails.ownerProfileUrl.split('/').slice(-1)[0] : null,\n      channel_url: `https://www.youtube.com/channel/${id}`,\n      external_channel_url: videoDetails ? `https://www.youtube.com/channel/${videoDetails.externalChannelId}` : '',\n      user_url: videoDetails ? new URL(videoDetails.ownerProfileUrl, BASE_URL).toString() : '',\n      thumbnails,\n      verified,\n      subscriber_count: subscriberCount,\n    };\n    if (thumbnails.length) {\n      utils.deprecate(author, 'avatar', author.thumbnails[0].url, 'author.avatar', 'author.thumbnails[0].url');\n    }\n    return author;\n  } catch (err) {\n    return {};\n  }\n};\n\nconst parseRelatedVideo = (details, rvsParams) => {\n  if (!details) return;\n  try {\n    let viewCount = getText(details.viewCountText);\n    let shortViewCount = getText(details.shortViewCountText);\n    let rvsDetails = rvsParams.find(elem => elem.id === details.videoId);\n    if (!/^\\d/.test(shortViewCount)) {\n      shortViewCount = (rvsDetails && rvsDetails.short_view_count_text) || '';\n    }\n    viewCount = (/^\\d/.test(viewCount) ? viewCount : shortViewCount).split(' ')[0];\n    let browseEndpoint = details.shortBylineText.runs[0].navigationEndpoint.browseEndpoint;\n    let channelId = browseEndpoint.browseId;\n    let name = getText(details.shortBylineText);\n    let user = (browseEndpoint.canonicalBaseUrl || '').split('/').slice(-1)[0];\n    let video = {\n      id: details.videoId,\n      title: getText(details.title),\n      published: getText(details.publishedTimeText),\n      author: {\n        id: channelId,\n        name,\n        user,\n        channel_url: `https://www.youtube.com/channel/${channelId}`,\n        user_url: `https://www.youtube.com/user/${user}`,\n        thumbnails: details.channelThumbnail.thumbnails.map(thumbnail => {\n          thumbnail.url = new URL(thumbnail.url, BASE_URL).toString();\n          return thumbnail;\n        }),\n        verified: isVerified(details.ownerBadges),\n\n        [Symbol.toPrimitive]() {\n          console.warn(`\\`relatedVideo.author\\` will be removed in a near future release, ` +\n            `use \\`relatedVideo.author.name\\` instead.`);\n          return video.author.name;\n        },\n\n      },\n      short_view_count_text: shortViewCount.split(' ')[0],\n      view_count: viewCount.replace(/,/g, ''),\n      length_seconds: details.lengthText ?\n        Math.floor(parseTimestamp(getText(details.lengthText)) / 1000) :\n        rvsParams && `${rvsParams.length_seconds}`,\n      thumbnails: details.thumbnail.thumbnails,\n      richThumbnails:\n        details.richThumbnail ?\n          details.richThumbnail.movingThumbnailRenderer.movingThumbnailDetails.thumbnails : [],\n      isLive: !!(details.badges && details.badges.find(b => b.metadataBadgeRenderer.label === 'LIVE NOW')),\n    };\n\n    utils.deprecate(video, 'author_thumbnail', video.author.thumbnails[0].url,\n      'relatedVideo.author_thumbnail', 'relatedVideo.author.thumbnails[0].url');\n    utils.deprecate(video, 'ucid', video.author.id, 'relatedVideo.ucid', 'relatedVideo.author.id');\n    utils.deprecate(video, 'video_thumbnail', video.thumbnails[0].url,\n      'relatedVideo.video_thumbnail', 'relatedVideo.thumbnails[0].url');\n    return video;\n  } catch (err) {\n    // Skip.\n  }\n};\n\n/**\n * Get related videos.\n *\n * @param {Object} info\n * @returns {Array.<Object>}\n */\nexports.getRelatedVideos = info => {\n  let rvsParams = [], secondaryResults = [];\n  try {\n    rvsParams = info.response.webWatchNextResponseExtensionData.relatedVideoArgs.split(',').map(e => qs.parse(e));\n  } catch (err) {\n    // Do nothing.\n  }\n  try {\n    secondaryResults = info.response.contents.twoColumnWatchNextResults.secondaryResults.secondaryResults.results;\n  } catch (err) {\n    return [];\n  }\n  let videos = [];\n  for (let result of secondaryResults || []) {\n    let details = result.compactVideoRenderer;\n    if (details) {\n      let video = parseRelatedVideo(details, rvsParams);\n      if (video) videos.push(video);\n    } else {\n      let autoplay = result.compactAutoplayRenderer || result.itemSectionRenderer;\n      if (!autoplay || !Array.isArray(autoplay.contents)) continue;\n      for (let content of autoplay.contents) {\n        let video = parseRelatedVideo(content.compactVideoRenderer, rvsParams);\n        if (video) videos.push(video);\n      }\n    }\n  }\n  return videos;\n};\n\n/**\n * Get like count.\n *\n * @param {Object} info\n * @returns {number}\n */\nexports.getLikes = info => {\n  try {\n    let contents = info.response.contents.twoColumnWatchNextResults.results.results.contents;\n    let video = contents.find(r => r.videoPrimaryInfoRenderer);\n    let buttons = video.videoPrimaryInfoRenderer.videoActions.menuRenderer.topLevelButtons;\n    let like = buttons.find(b => b.toggleButtonRenderer &&\n      b.toggleButtonRenderer.defaultIcon.iconType === 'LIKE');\n    return parseInt(like.toggleButtonRenderer.defaultText.accessibility.accessibilityData.label.replace(/\\D+/g, ''));\n  } catch (err) {\n    return null;\n  }\n};\n\n/**\n * Get dislike count.\n *\n * @param {Object} info\n * @returns {number}\n */\nexports.getDislikes = info => {\n  try {\n    let contents = info.response.contents.twoColumnWatchNextResults.results.results.contents;\n    let video = contents.find(r => r.videoPrimaryInfoRenderer);\n    let buttons = video.videoPrimaryInfoRenderer.videoActions.menuRenderer.topLevelButtons;\n    let dislike = buttons.find(b => b.toggleButtonRenderer &&\n      b.toggleButtonRenderer.defaultIcon.iconType === 'DISLIKE');\n    return parseInt(dislike.toggleButtonRenderer.defaultText.accessibility.accessibilityData.label.replace(/\\D+/g, ''));\n  } catch (err) {\n    return null;\n  }\n};\n\n/**\n * Cleans up a few fields on `videoDetails`.\n *\n * @param {Object} videoDetails\n * @param {Object} info\n * @returns {Object}\n */\nexports.cleanVideoDetails = (videoDetails, info) => {\n  videoDetails.thumbnails = videoDetails.thumbnail.thumbnails;\n  delete videoDetails.thumbnail;\n  utils.deprecate(videoDetails, 'thumbnail', { thumbnails: videoDetails.thumbnails },\n    'videoDetails.thumbnail.thumbnails', 'videoDetails.thumbnails');\n  videoDetails.description = videoDetails.shortDescription || getText(videoDetails.description);\n  delete videoDetails.shortDescription;\n  utils.deprecate(videoDetails, 'shortDescription', videoDetails.description,\n    'videoDetails.shortDescription', 'videoDetails.description');\n\n  // Use more reliable `lengthSeconds` from `playerMicroformatRenderer`.\n  videoDetails.lengthSeconds =\n    (info.player_response.microformat &&\n    info.player_response.microformat.playerMicroformatRenderer.lengthSeconds) ||\n    info.player_response.videoDetails.lengthSeconds;\n  return videoDetails;\n};\n\n/**\n * Get storyboards info.\n *\n * @param {Object} info\n * @returns {Array.<Object>}\n */\nexports.getStoryboards = info => {\n  const parts = info.player_response.storyboards &&\n    info.player_response.storyboards.playerStoryboardSpecRenderer &&\n    info.player_response.storyboards.playerStoryboardSpecRenderer.spec &&\n    info.player_response.storyboards.playerStoryboardSpecRenderer.spec.split('|');\n\n  if (!parts) return [];\n\n  const url = new URL(parts.shift());\n\n  return parts.map((part, i) => {\n    let [\n      thumbnailWidth,\n      thumbnailHeight,\n      thumbnailCount,\n      columns,\n      rows,\n      interval,\n      nameReplacement,\n      sigh,\n    ] = part.split('#');\n\n    url.searchParams.set('sigh', sigh);\n\n    thumbnailCount = parseInt(thumbnailCount, 10);\n    columns = parseInt(columns, 10);\n    rows = parseInt(rows, 10);\n\n    const storyboardCount = Math.ceil(thumbnailCount / (columns * rows));\n\n    return {\n      templateUrl: url.toString().replace('$L', i).replace('$N', nameReplacement),\n      thumbnailWidth: parseInt(thumbnailWidth, 10),\n      thumbnailHeight: parseInt(thumbnailHeight, 10),\n      thumbnailCount,\n      interval: parseInt(interval, 10),\n      columns,\n      rows,\n      storyboardCount,\n    };\n  });\n};\n\n/**\n * Get chapters info.\n *\n * @param {Object} info\n * @returns {Array.<Object>}\n */\nexports.getChapters = info => {\n  const playerOverlayRenderer = info.response &&\n    info.response.playerOverlays &&\n    info.response.playerOverlays.playerOverlayRenderer;\n  const playerBar = playerOverlayRenderer &&\n    playerOverlayRenderer.decoratedPlayerBarRenderer &&\n    playerOverlayRenderer.decoratedPlayerBarRenderer.decoratedPlayerBarRenderer &&\n    playerOverlayRenderer.decoratedPlayerBarRenderer.decoratedPlayerBarRenderer.playerBar;\n  const markersMap = playerBar &&\n    playerBar.multiMarkersPlayerBarRenderer &&\n    playerBar.multiMarkersPlayerBarRenderer.markersMap;\n  const marker = Array.isArray(markersMap) && markersMap.find(m => m.value && Array.isArray(m.value.chapters));\n  if (!marker) return [];\n  const chapters = marker.value.chapters;\n\n  return chapters.map(chapter => ({\n    title: getText(chapter.chapterRenderer.title),\n    start_time: chapter.chapterRenderer.timeRangeStartMillis / 1000,\n  }));\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMveXRkbC1jb3JlL2xpYi9pbmZvLWV4dHJhcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxjQUFjLG1CQUFPLENBQUMsNERBQVM7QUFDL0IsV0FBVyxtQkFBTyxDQUFDLGdDQUFhO0FBQ2hDLFFBQVEsaUJBQWlCLEVBQUUsbUJBQU8sQ0FBQyxpRUFBWTs7O0FBRy9DO0FBQ0E7QUFDQSxVQUFVLGtEQUFrRDtBQUM1RDs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE1BQU07QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix1QkFBdUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsS0FBSztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHVCQUF1QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxHQUFHO0FBQ3pELDhFQUE4RSwrQkFBK0I7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxVQUFVO0FBQ2xFLGtEQUFrRCxLQUFLO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlCQUF5QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSwrQ0FBK0MscUNBQXFDO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxhZ2d5bVxcT25lRHJpdmVcXERlc2t0b3BcXHByb2plY3RzXFx5b3V0dWJlX3N1bW1hcml6ZXJcXG5vZGVfbW9kdWxlc1xceXRkbC1jb3JlXFxsaWJcXGluZm8tZXh0cmFzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuY29uc3QgcXMgPSByZXF1aXJlKCdxdWVyeXN0cmluZycpO1xuY29uc3QgeyBwYXJzZVRpbWVzdGFtcCB9ID0gcmVxdWlyZSgnbTN1OHN0cmVhbScpO1xuXG5cbmNvbnN0IEJBU0VfVVJMID0gJ2h0dHBzOi8vd3d3LnlvdXR1YmUuY29tL3dhdGNoP3Y9JztcbmNvbnN0IFRJVExFX1RPX0NBVEVHT1JZID0ge1xuICBzb25nOiB7IG5hbWU6ICdNdXNpYycsIHVybDogJ2h0dHBzOi8vbXVzaWMueW91dHViZS5jb20vJyB9LFxufTtcblxuY29uc3QgZ2V0VGV4dCA9IG9iaiA9PiBvYmogPyBvYmoucnVucyA/IG9iai5ydW5zWzBdLnRleHQgOiBvYmouc2ltcGxlVGV4dCA6IG51bGw7XG5cblxuLyoqXG4gKiBHZXQgdmlkZW8gbWVkaWEuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGluZm9cbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKi9cbmV4cG9ydHMuZ2V0TWVkaWEgPSBpbmZvID0+IHtcbiAgbGV0IG1lZGlhID0ge307XG4gIGxldCByZXN1bHRzID0gW107XG4gIHRyeSB7XG4gICAgcmVzdWx0cyA9IGluZm8ucmVzcG9uc2UuY29udGVudHMudHdvQ29sdW1uV2F0Y2hOZXh0UmVzdWx0cy5yZXN1bHRzLnJlc3VsdHMuY29udGVudHM7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIERvIG5vdGhpbmdcbiAgfVxuXG4gIGxldCByZXN1bHQgPSByZXN1bHRzLmZpbmQodiA9PiB2LnZpZGVvU2Vjb25kYXJ5SW5mb1JlbmRlcmVyKTtcbiAgaWYgKCFyZXN1bHQpIHsgcmV0dXJuIHt9OyB9XG5cbiAgdHJ5IHtcbiAgICBsZXQgbWV0YWRhdGFSb3dzID1cbiAgICAgIChyZXN1bHQubWV0YWRhdGFSb3dDb250YWluZXIgfHwgcmVzdWx0LnZpZGVvU2Vjb25kYXJ5SW5mb1JlbmRlcmVyLm1ldGFkYXRhUm93Q29udGFpbmVyKVxuICAgICAgICAubWV0YWRhdGFSb3dDb250YWluZXJSZW5kZXJlci5yb3dzO1xuICAgIGZvciAobGV0IHJvdyBvZiBtZXRhZGF0YVJvd3MpIHtcbiAgICAgIGlmIChyb3cubWV0YWRhdGFSb3dSZW5kZXJlcikge1xuICAgICAgICBsZXQgdGl0bGUgPSBnZXRUZXh0KHJvdy5tZXRhZGF0YVJvd1JlbmRlcmVyLnRpdGxlKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBsZXQgY29udGVudHMgPSByb3cubWV0YWRhdGFSb3dSZW5kZXJlci5jb250ZW50c1swXTtcbiAgICAgICAgbWVkaWFbdGl0bGVdID0gZ2V0VGV4dChjb250ZW50cyk7XG4gICAgICAgIGxldCBydW5zID0gY29udGVudHMucnVucztcbiAgICAgICAgaWYgKHJ1bnMgJiYgcnVuc1swXS5uYXZpZ2F0aW9uRW5kcG9pbnQpIHtcbiAgICAgICAgICBtZWRpYVtgJHt0aXRsZX1fdXJsYF0gPSBuZXcgVVJMKFxuICAgICAgICAgICAgcnVuc1swXS5uYXZpZ2F0aW9uRW5kcG9pbnQuY29tbWFuZE1ldGFkYXRhLndlYkNvbW1hbmRNZXRhZGF0YS51cmwsIEJBU0VfVVJMKS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aXRsZSBpbiBUSVRMRV9UT19DQVRFR09SWSkge1xuICAgICAgICAgIG1lZGlhLmNhdGVnb3J5ID0gVElUTEVfVE9fQ0FURUdPUllbdGl0bGVdLm5hbWU7XG4gICAgICAgICAgbWVkaWEuY2F0ZWdvcnlfdXJsID0gVElUTEVfVE9fQ0FURUdPUllbdGl0bGVdLnVybDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChyb3cucmljaE1ldGFkYXRhUm93UmVuZGVyZXIpIHtcbiAgICAgICAgbGV0IGNvbnRlbnRzID0gcm93LnJpY2hNZXRhZGF0YVJvd1JlbmRlcmVyLmNvbnRlbnRzO1xuICAgICAgICBsZXQgYm94QXJ0ID0gY29udGVudHNcbiAgICAgICAgICAuZmlsdGVyKG1ldGEgPT4gbWV0YS5yaWNoTWV0YWRhdGFSZW5kZXJlci5zdHlsZSA9PT0gJ1JJQ0hfTUVUQURBVEFfUkVOREVSRVJfU1RZTEVfQk9YX0FSVCcpO1xuICAgICAgICBmb3IgKGxldCB7IHJpY2hNZXRhZGF0YVJlbmRlcmVyIH0gb2YgYm94QXJ0KSB7XG4gICAgICAgICAgbGV0IG1ldGEgPSByaWNoTWV0YWRhdGFSZW5kZXJlcjtcbiAgICAgICAgICBtZWRpYS55ZWFyID0gZ2V0VGV4dChtZXRhLnN1YnRpdGxlKTtcbiAgICAgICAgICBsZXQgdHlwZSA9IGdldFRleHQobWV0YS5jYWxsVG9BY3Rpb24pLnNwbGl0KCcgJylbMV07XG4gICAgICAgICAgbWVkaWFbdHlwZV0gPSBnZXRUZXh0KG1ldGEudGl0bGUpO1xuICAgICAgICAgIG1lZGlhW2Ake3R5cGV9X3VybGBdID0gbmV3IFVSTChcbiAgICAgICAgICAgIG1ldGEuZW5kcG9pbnQuY29tbWFuZE1ldGFkYXRhLndlYkNvbW1hbmRNZXRhZGF0YS51cmwsIEJBU0VfVVJMKS50b1N0cmluZygpO1xuICAgICAgICAgIG1lZGlhLnRodW1ibmFpbHMgPSBtZXRhLnRodW1ibmFpbC50aHVtYm5haWxzO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0b3BpYyA9IGNvbnRlbnRzXG4gICAgICAgICAgLmZpbHRlcihtZXRhID0+IG1ldGEucmljaE1ldGFkYXRhUmVuZGVyZXIuc3R5bGUgPT09ICdSSUNIX01FVEFEQVRBX1JFTkRFUkVSX1NUWUxFX1RPUElDJyk7XG4gICAgICAgIGZvciAobGV0IHsgcmljaE1ldGFkYXRhUmVuZGVyZXIgfSBvZiB0b3BpYykge1xuICAgICAgICAgIGxldCBtZXRhID0gcmljaE1ldGFkYXRhUmVuZGVyZXI7XG4gICAgICAgICAgbWVkaWEuY2F0ZWdvcnkgPSBnZXRUZXh0KG1ldGEudGl0bGUpO1xuICAgICAgICAgIG1lZGlhLmNhdGVnb3J5X3VybCA9IG5ldyBVUkwoXG4gICAgICAgICAgICBtZXRhLmVuZHBvaW50LmNvbW1hbmRNZXRhZGF0YS53ZWJDb21tYW5kTWV0YWRhdGEudXJsLCBCQVNFX1VSTCkudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gRG8gbm90aGluZy5cbiAgfVxuXG4gIHJldHVybiBtZWRpYTtcbn07XG5cblxuY29uc3QgaXNWZXJpZmllZCA9IGJhZGdlcyA9PiAhIShiYWRnZXMgJiYgYmFkZ2VzLmZpbmQoYiA9PiBiLm1ldGFkYXRhQmFkZ2VSZW5kZXJlci50b29sdGlwID09PSAnVmVyaWZpZWQnKSk7XG5cblxuLyoqXG4gKiBHZXQgdmlkZW8gYXV0aG9yLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbmZvXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICovXG5leHBvcnRzLmdldEF1dGhvciA9IGluZm8gPT4ge1xuICBsZXQgY2hhbm5lbElkLCB0aHVtYm5haWxzID0gW10sIHN1YnNjcmliZXJDb3VudCwgdmVyaWZpZWQgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICBsZXQgcmVzdWx0cyA9IGluZm8ucmVzcG9uc2UuY29udGVudHMudHdvQ29sdW1uV2F0Y2hOZXh0UmVzdWx0cy5yZXN1bHRzLnJlc3VsdHMuY29udGVudHM7XG4gICAgbGV0IHYgPSByZXN1bHRzLmZpbmQodjIgPT5cbiAgICAgIHYyLnZpZGVvU2Vjb25kYXJ5SW5mb1JlbmRlcmVyICYmXG4gICAgICB2Mi52aWRlb1NlY29uZGFyeUluZm9SZW5kZXJlci5vd25lciAmJlxuICAgICAgdjIudmlkZW9TZWNvbmRhcnlJbmZvUmVuZGVyZXIub3duZXIudmlkZW9Pd25lclJlbmRlcmVyKTtcbiAgICBsZXQgdmlkZW9Pd25lclJlbmRlcmVyID0gdi52aWRlb1NlY29uZGFyeUluZm9SZW5kZXJlci5vd25lci52aWRlb093bmVyUmVuZGVyZXI7XG4gICAgY2hhbm5lbElkID0gdmlkZW9Pd25lclJlbmRlcmVyLm5hdmlnYXRpb25FbmRwb2ludC5icm93c2VFbmRwb2ludC5icm93c2VJZDtcbiAgICB0aHVtYm5haWxzID0gdmlkZW9Pd25lclJlbmRlcmVyLnRodW1ibmFpbC50aHVtYm5haWxzLm1hcCh0aHVtYm5haWwgPT4ge1xuICAgICAgdGh1bWJuYWlsLnVybCA9IG5ldyBVUkwodGh1bWJuYWlsLnVybCwgQkFTRV9VUkwpLnRvU3RyaW5nKCk7XG4gICAgICByZXR1cm4gdGh1bWJuYWlsO1xuICAgIH0pO1xuICAgIHN1YnNjcmliZXJDb3VudCA9IHV0aWxzLnBhcnNlQWJicmV2aWF0ZWROdW1iZXIoZ2V0VGV4dCh2aWRlb093bmVyUmVuZGVyZXIuc3Vic2NyaWJlckNvdW50VGV4dCkpO1xuICAgIHZlcmlmaWVkID0gaXNWZXJpZmllZCh2aWRlb093bmVyUmVuZGVyZXIuYmFkZ2VzKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gRG8gbm90aGluZy5cbiAgfVxuICB0cnkge1xuICAgIGxldCB2aWRlb0RldGFpbHMgPSBpbmZvLnBsYXllcl9yZXNwb25zZS5taWNyb2Zvcm1hdCAmJiBpbmZvLnBsYXllcl9yZXNwb25zZS5taWNyb2Zvcm1hdC5wbGF5ZXJNaWNyb2Zvcm1hdFJlbmRlcmVyO1xuICAgIGxldCBpZCA9ICh2aWRlb0RldGFpbHMgJiYgdmlkZW9EZXRhaWxzLmNoYW5uZWxJZCkgfHwgY2hhbm5lbElkIHx8IGluZm8ucGxheWVyX3Jlc3BvbnNlLnZpZGVvRGV0YWlscy5jaGFubmVsSWQ7XG4gICAgbGV0IGF1dGhvciA9IHtcbiAgICAgIGlkOiBpZCxcbiAgICAgIG5hbWU6IHZpZGVvRGV0YWlscyA/IHZpZGVvRGV0YWlscy5vd25lckNoYW5uZWxOYW1lIDogaW5mby5wbGF5ZXJfcmVzcG9uc2UudmlkZW9EZXRhaWxzLmF1dGhvcixcbiAgICAgIHVzZXI6IHZpZGVvRGV0YWlscyA/IHZpZGVvRGV0YWlscy5vd25lclByb2ZpbGVVcmwuc3BsaXQoJy8nKS5zbGljZSgtMSlbMF0gOiBudWxsLFxuICAgICAgY2hhbm5lbF91cmw6IGBodHRwczovL3d3dy55b3V0dWJlLmNvbS9jaGFubmVsLyR7aWR9YCxcbiAgICAgIGV4dGVybmFsX2NoYW5uZWxfdXJsOiB2aWRlb0RldGFpbHMgPyBgaHR0cHM6Ly93d3cueW91dHViZS5jb20vY2hhbm5lbC8ke3ZpZGVvRGV0YWlscy5leHRlcm5hbENoYW5uZWxJZH1gIDogJycsXG4gICAgICB1c2VyX3VybDogdmlkZW9EZXRhaWxzID8gbmV3IFVSTCh2aWRlb0RldGFpbHMub3duZXJQcm9maWxlVXJsLCBCQVNFX1VSTCkudG9TdHJpbmcoKSA6ICcnLFxuICAgICAgdGh1bWJuYWlscyxcbiAgICAgIHZlcmlmaWVkLFxuICAgICAgc3Vic2NyaWJlcl9jb3VudDogc3Vic2NyaWJlckNvdW50LFxuICAgIH07XG4gICAgaWYgKHRodW1ibmFpbHMubGVuZ3RoKSB7XG4gICAgICB1dGlscy5kZXByZWNhdGUoYXV0aG9yLCAnYXZhdGFyJywgYXV0aG9yLnRodW1ibmFpbHNbMF0udXJsLCAnYXV0aG9yLmF2YXRhcicsICdhdXRob3IudGh1bWJuYWlsc1swXS51cmwnKTtcbiAgICB9XG4gICAgcmV0dXJuIGF1dGhvcjtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG59O1xuXG5jb25zdCBwYXJzZVJlbGF0ZWRWaWRlbyA9IChkZXRhaWxzLCBydnNQYXJhbXMpID0+IHtcbiAgaWYgKCFkZXRhaWxzKSByZXR1cm47XG4gIHRyeSB7XG4gICAgbGV0IHZpZXdDb3VudCA9IGdldFRleHQoZGV0YWlscy52aWV3Q291bnRUZXh0KTtcbiAgICBsZXQgc2hvcnRWaWV3Q291bnQgPSBnZXRUZXh0KGRldGFpbHMuc2hvcnRWaWV3Q291bnRUZXh0KTtcbiAgICBsZXQgcnZzRGV0YWlscyA9IHJ2c1BhcmFtcy5maW5kKGVsZW0gPT4gZWxlbS5pZCA9PT0gZGV0YWlscy52aWRlb0lkKTtcbiAgICBpZiAoIS9eXFxkLy50ZXN0KHNob3J0Vmlld0NvdW50KSkge1xuICAgICAgc2hvcnRWaWV3Q291bnQgPSAocnZzRGV0YWlscyAmJiBydnNEZXRhaWxzLnNob3J0X3ZpZXdfY291bnRfdGV4dCkgfHwgJyc7XG4gICAgfVxuICAgIHZpZXdDb3VudCA9ICgvXlxcZC8udGVzdCh2aWV3Q291bnQpID8gdmlld0NvdW50IDogc2hvcnRWaWV3Q291bnQpLnNwbGl0KCcgJylbMF07XG4gICAgbGV0IGJyb3dzZUVuZHBvaW50ID0gZGV0YWlscy5zaG9ydEJ5bGluZVRleHQucnVuc1swXS5uYXZpZ2F0aW9uRW5kcG9pbnQuYnJvd3NlRW5kcG9pbnQ7XG4gICAgbGV0IGNoYW5uZWxJZCA9IGJyb3dzZUVuZHBvaW50LmJyb3dzZUlkO1xuICAgIGxldCBuYW1lID0gZ2V0VGV4dChkZXRhaWxzLnNob3J0QnlsaW5lVGV4dCk7XG4gICAgbGV0IHVzZXIgPSAoYnJvd3NlRW5kcG9pbnQuY2Fub25pY2FsQmFzZVVybCB8fCAnJykuc3BsaXQoJy8nKS5zbGljZSgtMSlbMF07XG4gICAgbGV0IHZpZGVvID0ge1xuICAgICAgaWQ6IGRldGFpbHMudmlkZW9JZCxcbiAgICAgIHRpdGxlOiBnZXRUZXh0KGRldGFpbHMudGl0bGUpLFxuICAgICAgcHVibGlzaGVkOiBnZXRUZXh0KGRldGFpbHMucHVibGlzaGVkVGltZVRleHQpLFxuICAgICAgYXV0aG9yOiB7XG4gICAgICAgIGlkOiBjaGFubmVsSWQsXG4gICAgICAgIG5hbWUsXG4gICAgICAgIHVzZXIsXG4gICAgICAgIGNoYW5uZWxfdXJsOiBgaHR0cHM6Ly93d3cueW91dHViZS5jb20vY2hhbm5lbC8ke2NoYW5uZWxJZH1gLFxuICAgICAgICB1c2VyX3VybDogYGh0dHBzOi8vd3d3LnlvdXR1YmUuY29tL3VzZXIvJHt1c2VyfWAsXG4gICAgICAgIHRodW1ibmFpbHM6IGRldGFpbHMuY2hhbm5lbFRodW1ibmFpbC50aHVtYm5haWxzLm1hcCh0aHVtYm5haWwgPT4ge1xuICAgICAgICAgIHRodW1ibmFpbC51cmwgPSBuZXcgVVJMKHRodW1ibmFpbC51cmwsIEJBU0VfVVJMKS50b1N0cmluZygpO1xuICAgICAgICAgIHJldHVybiB0aHVtYm5haWw7XG4gICAgICAgIH0pLFxuICAgICAgICB2ZXJpZmllZDogaXNWZXJpZmllZChkZXRhaWxzLm93bmVyQmFkZ2VzKSxcblxuICAgICAgICBbU3ltYm9sLnRvUHJpbWl0aXZlXSgpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oYFxcYHJlbGF0ZWRWaWRlby5hdXRob3JcXGAgd2lsbCBiZSByZW1vdmVkIGluIGEgbmVhciBmdXR1cmUgcmVsZWFzZSwgYCArXG4gICAgICAgICAgICBgdXNlIFxcYHJlbGF0ZWRWaWRlby5hdXRob3IubmFtZVxcYCBpbnN0ZWFkLmApO1xuICAgICAgICAgIHJldHVybiB2aWRlby5hdXRob3IubmFtZTtcbiAgICAgICAgfSxcblxuICAgICAgfSxcbiAgICAgIHNob3J0X3ZpZXdfY291bnRfdGV4dDogc2hvcnRWaWV3Q291bnQuc3BsaXQoJyAnKVswXSxcbiAgICAgIHZpZXdfY291bnQ6IHZpZXdDb3VudC5yZXBsYWNlKC8sL2csICcnKSxcbiAgICAgIGxlbmd0aF9zZWNvbmRzOiBkZXRhaWxzLmxlbmd0aFRleHQgP1xuICAgICAgICBNYXRoLmZsb29yKHBhcnNlVGltZXN0YW1wKGdldFRleHQoZGV0YWlscy5sZW5ndGhUZXh0KSkgLyAxMDAwKSA6XG4gICAgICAgIHJ2c1BhcmFtcyAmJiBgJHtydnNQYXJhbXMubGVuZ3RoX3NlY29uZHN9YCxcbiAgICAgIHRodW1ibmFpbHM6IGRldGFpbHMudGh1bWJuYWlsLnRodW1ibmFpbHMsXG4gICAgICByaWNoVGh1bWJuYWlsczpcbiAgICAgICAgZGV0YWlscy5yaWNoVGh1bWJuYWlsID9cbiAgICAgICAgICBkZXRhaWxzLnJpY2hUaHVtYm5haWwubW92aW5nVGh1bWJuYWlsUmVuZGVyZXIubW92aW5nVGh1bWJuYWlsRGV0YWlscy50aHVtYm5haWxzIDogW10sXG4gICAgICBpc0xpdmU6ICEhKGRldGFpbHMuYmFkZ2VzICYmIGRldGFpbHMuYmFkZ2VzLmZpbmQoYiA9PiBiLm1ldGFkYXRhQmFkZ2VSZW5kZXJlci5sYWJlbCA9PT0gJ0xJVkUgTk9XJykpLFxuICAgIH07XG5cbiAgICB1dGlscy5kZXByZWNhdGUodmlkZW8sICdhdXRob3JfdGh1bWJuYWlsJywgdmlkZW8uYXV0aG9yLnRodW1ibmFpbHNbMF0udXJsLFxuICAgICAgJ3JlbGF0ZWRWaWRlby5hdXRob3JfdGh1bWJuYWlsJywgJ3JlbGF0ZWRWaWRlby5hdXRob3IudGh1bWJuYWlsc1swXS51cmwnKTtcbiAgICB1dGlscy5kZXByZWNhdGUodmlkZW8sICd1Y2lkJywgdmlkZW8uYXV0aG9yLmlkLCAncmVsYXRlZFZpZGVvLnVjaWQnLCAncmVsYXRlZFZpZGVvLmF1dGhvci5pZCcpO1xuICAgIHV0aWxzLmRlcHJlY2F0ZSh2aWRlbywgJ3ZpZGVvX3RodW1ibmFpbCcsIHZpZGVvLnRodW1ibmFpbHNbMF0udXJsLFxuICAgICAgJ3JlbGF0ZWRWaWRlby52aWRlb190aHVtYm5haWwnLCAncmVsYXRlZFZpZGVvLnRodW1ibmFpbHNbMF0udXJsJyk7XG4gICAgcmV0dXJuIHZpZGVvO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBTa2lwLlxuICB9XG59O1xuXG4vKipcbiAqIEdldCByZWxhdGVkIHZpZGVvcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gaW5mb1xuICogQHJldHVybnMge0FycmF5LjxPYmplY3Q+fVxuICovXG5leHBvcnRzLmdldFJlbGF0ZWRWaWRlb3MgPSBpbmZvID0+IHtcbiAgbGV0IHJ2c1BhcmFtcyA9IFtdLCBzZWNvbmRhcnlSZXN1bHRzID0gW107XG4gIHRyeSB7XG4gICAgcnZzUGFyYW1zID0gaW5mby5yZXNwb25zZS53ZWJXYXRjaE5leHRSZXNwb25zZUV4dGVuc2lvbkRhdGEucmVsYXRlZFZpZGVvQXJncy5zcGxpdCgnLCcpLm1hcChlID0+IHFzLnBhcnNlKGUpKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gRG8gbm90aGluZy5cbiAgfVxuICB0cnkge1xuICAgIHNlY29uZGFyeVJlc3VsdHMgPSBpbmZvLnJlc3BvbnNlLmNvbnRlbnRzLnR3b0NvbHVtbldhdGNoTmV4dFJlc3VsdHMuc2Vjb25kYXJ5UmVzdWx0cy5zZWNvbmRhcnlSZXN1bHRzLnJlc3VsdHM7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBsZXQgdmlkZW9zID0gW107XG4gIGZvciAobGV0IHJlc3VsdCBvZiBzZWNvbmRhcnlSZXN1bHRzIHx8IFtdKSB7XG4gICAgbGV0IGRldGFpbHMgPSByZXN1bHQuY29tcGFjdFZpZGVvUmVuZGVyZXI7XG4gICAgaWYgKGRldGFpbHMpIHtcbiAgICAgIGxldCB2aWRlbyA9IHBhcnNlUmVsYXRlZFZpZGVvKGRldGFpbHMsIHJ2c1BhcmFtcyk7XG4gICAgICBpZiAodmlkZW8pIHZpZGVvcy5wdXNoKHZpZGVvKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGF1dG9wbGF5ID0gcmVzdWx0LmNvbXBhY3RBdXRvcGxheVJlbmRlcmVyIHx8IHJlc3VsdC5pdGVtU2VjdGlvblJlbmRlcmVyO1xuICAgICAgaWYgKCFhdXRvcGxheSB8fCAhQXJyYXkuaXNBcnJheShhdXRvcGxheS5jb250ZW50cykpIGNvbnRpbnVlO1xuICAgICAgZm9yIChsZXQgY29udGVudCBvZiBhdXRvcGxheS5jb250ZW50cykge1xuICAgICAgICBsZXQgdmlkZW8gPSBwYXJzZVJlbGF0ZWRWaWRlbyhjb250ZW50LmNvbXBhY3RWaWRlb1JlbmRlcmVyLCBydnNQYXJhbXMpO1xuICAgICAgICBpZiAodmlkZW8pIHZpZGVvcy5wdXNoKHZpZGVvKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZpZGVvcztcbn07XG5cbi8qKlxuICogR2V0IGxpa2UgY291bnQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGluZm9cbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydHMuZ2V0TGlrZXMgPSBpbmZvID0+IHtcbiAgdHJ5IHtcbiAgICBsZXQgY29udGVudHMgPSBpbmZvLnJlc3BvbnNlLmNvbnRlbnRzLnR3b0NvbHVtbldhdGNoTmV4dFJlc3VsdHMucmVzdWx0cy5yZXN1bHRzLmNvbnRlbnRzO1xuICAgIGxldCB2aWRlbyA9IGNvbnRlbnRzLmZpbmQociA9PiByLnZpZGVvUHJpbWFyeUluZm9SZW5kZXJlcik7XG4gICAgbGV0IGJ1dHRvbnMgPSB2aWRlby52aWRlb1ByaW1hcnlJbmZvUmVuZGVyZXIudmlkZW9BY3Rpb25zLm1lbnVSZW5kZXJlci50b3BMZXZlbEJ1dHRvbnM7XG4gICAgbGV0IGxpa2UgPSBidXR0b25zLmZpbmQoYiA9PiBiLnRvZ2dsZUJ1dHRvblJlbmRlcmVyICYmXG4gICAgICBiLnRvZ2dsZUJ1dHRvblJlbmRlcmVyLmRlZmF1bHRJY29uLmljb25UeXBlID09PSAnTElLRScpO1xuICAgIHJldHVybiBwYXJzZUludChsaWtlLnRvZ2dsZUJ1dHRvblJlbmRlcmVyLmRlZmF1bHRUZXh0LmFjY2Vzc2liaWxpdHkuYWNjZXNzaWJpbGl0eURhdGEubGFiZWwucmVwbGFjZSgvXFxEKy9nLCAnJykpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcblxuLyoqXG4gKiBHZXQgZGlzbGlrZSBjb3VudC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gaW5mb1xuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0cy5nZXREaXNsaWtlcyA9IGluZm8gPT4ge1xuICB0cnkge1xuICAgIGxldCBjb250ZW50cyA9IGluZm8ucmVzcG9uc2UuY29udGVudHMudHdvQ29sdW1uV2F0Y2hOZXh0UmVzdWx0cy5yZXN1bHRzLnJlc3VsdHMuY29udGVudHM7XG4gICAgbGV0IHZpZGVvID0gY29udGVudHMuZmluZChyID0+IHIudmlkZW9QcmltYXJ5SW5mb1JlbmRlcmVyKTtcbiAgICBsZXQgYnV0dG9ucyA9IHZpZGVvLnZpZGVvUHJpbWFyeUluZm9SZW5kZXJlci52aWRlb0FjdGlvbnMubWVudVJlbmRlcmVyLnRvcExldmVsQnV0dG9ucztcbiAgICBsZXQgZGlzbGlrZSA9IGJ1dHRvbnMuZmluZChiID0+IGIudG9nZ2xlQnV0dG9uUmVuZGVyZXIgJiZcbiAgICAgIGIudG9nZ2xlQnV0dG9uUmVuZGVyZXIuZGVmYXVsdEljb24uaWNvblR5cGUgPT09ICdESVNMSUtFJyk7XG4gICAgcmV0dXJuIHBhcnNlSW50KGRpc2xpa2UudG9nZ2xlQnV0dG9uUmVuZGVyZXIuZGVmYXVsdFRleHQuYWNjZXNzaWJpbGl0eS5hY2Nlc3NpYmlsaXR5RGF0YS5sYWJlbC5yZXBsYWNlKC9cXEQrL2csICcnKSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59O1xuXG4vKipcbiAqIENsZWFucyB1cCBhIGZldyBmaWVsZHMgb24gYHZpZGVvRGV0YWlsc2AuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZpZGVvRGV0YWlsc1xuICogQHBhcmFtIHtPYmplY3R9IGluZm9cbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKi9cbmV4cG9ydHMuY2xlYW5WaWRlb0RldGFpbHMgPSAodmlkZW9EZXRhaWxzLCBpbmZvKSA9PiB7XG4gIHZpZGVvRGV0YWlscy50aHVtYm5haWxzID0gdmlkZW9EZXRhaWxzLnRodW1ibmFpbC50aHVtYm5haWxzO1xuICBkZWxldGUgdmlkZW9EZXRhaWxzLnRodW1ibmFpbDtcbiAgdXRpbHMuZGVwcmVjYXRlKHZpZGVvRGV0YWlscywgJ3RodW1ibmFpbCcsIHsgdGh1bWJuYWlsczogdmlkZW9EZXRhaWxzLnRodW1ibmFpbHMgfSxcbiAgICAndmlkZW9EZXRhaWxzLnRodW1ibmFpbC50aHVtYm5haWxzJywgJ3ZpZGVvRGV0YWlscy50aHVtYm5haWxzJyk7XG4gIHZpZGVvRGV0YWlscy5kZXNjcmlwdGlvbiA9IHZpZGVvRGV0YWlscy5zaG9ydERlc2NyaXB0aW9uIHx8IGdldFRleHQodmlkZW9EZXRhaWxzLmRlc2NyaXB0aW9uKTtcbiAgZGVsZXRlIHZpZGVvRGV0YWlscy5zaG9ydERlc2NyaXB0aW9uO1xuICB1dGlscy5kZXByZWNhdGUodmlkZW9EZXRhaWxzLCAnc2hvcnREZXNjcmlwdGlvbicsIHZpZGVvRGV0YWlscy5kZXNjcmlwdGlvbixcbiAgICAndmlkZW9EZXRhaWxzLnNob3J0RGVzY3JpcHRpb24nLCAndmlkZW9EZXRhaWxzLmRlc2NyaXB0aW9uJyk7XG5cbiAgLy8gVXNlIG1vcmUgcmVsaWFibGUgYGxlbmd0aFNlY29uZHNgIGZyb20gYHBsYXllck1pY3JvZm9ybWF0UmVuZGVyZXJgLlxuICB2aWRlb0RldGFpbHMubGVuZ3RoU2Vjb25kcyA9XG4gICAgKGluZm8ucGxheWVyX3Jlc3BvbnNlLm1pY3JvZm9ybWF0ICYmXG4gICAgaW5mby5wbGF5ZXJfcmVzcG9uc2UubWljcm9mb3JtYXQucGxheWVyTWljcm9mb3JtYXRSZW5kZXJlci5sZW5ndGhTZWNvbmRzKSB8fFxuICAgIGluZm8ucGxheWVyX3Jlc3BvbnNlLnZpZGVvRGV0YWlscy5sZW5ndGhTZWNvbmRzO1xuICByZXR1cm4gdmlkZW9EZXRhaWxzO1xufTtcblxuLyoqXG4gKiBHZXQgc3Rvcnlib2FyZHMgaW5mby5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gaW5mb1xuICogQHJldHVybnMge0FycmF5LjxPYmplY3Q+fVxuICovXG5leHBvcnRzLmdldFN0b3J5Ym9hcmRzID0gaW5mbyA9PiB7XG4gIGNvbnN0IHBhcnRzID0gaW5mby5wbGF5ZXJfcmVzcG9uc2Uuc3Rvcnlib2FyZHMgJiZcbiAgICBpbmZvLnBsYXllcl9yZXNwb25zZS5zdG9yeWJvYXJkcy5wbGF5ZXJTdG9yeWJvYXJkU3BlY1JlbmRlcmVyICYmXG4gICAgaW5mby5wbGF5ZXJfcmVzcG9uc2Uuc3Rvcnlib2FyZHMucGxheWVyU3Rvcnlib2FyZFNwZWNSZW5kZXJlci5zcGVjICYmXG4gICAgaW5mby5wbGF5ZXJfcmVzcG9uc2Uuc3Rvcnlib2FyZHMucGxheWVyU3Rvcnlib2FyZFNwZWNSZW5kZXJlci5zcGVjLnNwbGl0KCd8Jyk7XG5cbiAgaWYgKCFwYXJ0cykgcmV0dXJuIFtdO1xuXG4gIGNvbnN0IHVybCA9IG5ldyBVUkwocGFydHMuc2hpZnQoKSk7XG5cbiAgcmV0dXJuIHBhcnRzLm1hcCgocGFydCwgaSkgPT4ge1xuICAgIGxldCBbXG4gICAgICB0aHVtYm5haWxXaWR0aCxcbiAgICAgIHRodW1ibmFpbEhlaWdodCxcbiAgICAgIHRodW1ibmFpbENvdW50LFxuICAgICAgY29sdW1ucyxcbiAgICAgIHJvd3MsXG4gICAgICBpbnRlcnZhbCxcbiAgICAgIG5hbWVSZXBsYWNlbWVudCxcbiAgICAgIHNpZ2gsXG4gICAgXSA9IHBhcnQuc3BsaXQoJyMnKTtcblxuICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KCdzaWdoJywgc2lnaCk7XG5cbiAgICB0aHVtYm5haWxDb3VudCA9IHBhcnNlSW50KHRodW1ibmFpbENvdW50LCAxMCk7XG4gICAgY29sdW1ucyA9IHBhcnNlSW50KGNvbHVtbnMsIDEwKTtcbiAgICByb3dzID0gcGFyc2VJbnQocm93cywgMTApO1xuXG4gICAgY29uc3Qgc3Rvcnlib2FyZENvdW50ID0gTWF0aC5jZWlsKHRodW1ibmFpbENvdW50IC8gKGNvbHVtbnMgKiByb3dzKSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdGVtcGxhdGVVcmw6IHVybC50b1N0cmluZygpLnJlcGxhY2UoJyRMJywgaSkucmVwbGFjZSgnJE4nLCBuYW1lUmVwbGFjZW1lbnQpLFxuICAgICAgdGh1bWJuYWlsV2lkdGg6IHBhcnNlSW50KHRodW1ibmFpbFdpZHRoLCAxMCksXG4gICAgICB0aHVtYm5haWxIZWlnaHQ6IHBhcnNlSW50KHRodW1ibmFpbEhlaWdodCwgMTApLFxuICAgICAgdGh1bWJuYWlsQ291bnQsXG4gICAgICBpbnRlcnZhbDogcGFyc2VJbnQoaW50ZXJ2YWwsIDEwKSxcbiAgICAgIGNvbHVtbnMsXG4gICAgICByb3dzLFxuICAgICAgc3Rvcnlib2FyZENvdW50LFxuICAgIH07XG4gIH0pO1xufTtcblxuLyoqXG4gKiBHZXQgY2hhcHRlcnMgaW5mby5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gaW5mb1xuICogQHJldHVybnMge0FycmF5LjxPYmplY3Q+fVxuICovXG5leHBvcnRzLmdldENoYXB0ZXJzID0gaW5mbyA9PiB7XG4gIGNvbnN0IHBsYXllck92ZXJsYXlSZW5kZXJlciA9IGluZm8ucmVzcG9uc2UgJiZcbiAgICBpbmZvLnJlc3BvbnNlLnBsYXllck92ZXJsYXlzICYmXG4gICAgaW5mby5yZXNwb25zZS5wbGF5ZXJPdmVybGF5cy5wbGF5ZXJPdmVybGF5UmVuZGVyZXI7XG4gIGNvbnN0IHBsYXllckJhciA9IHBsYXllck92ZXJsYXlSZW5kZXJlciAmJlxuICAgIHBsYXllck92ZXJsYXlSZW5kZXJlci5kZWNvcmF0ZWRQbGF5ZXJCYXJSZW5kZXJlciAmJlxuICAgIHBsYXllck92ZXJsYXlSZW5kZXJlci5kZWNvcmF0ZWRQbGF5ZXJCYXJSZW5kZXJlci5kZWNvcmF0ZWRQbGF5ZXJCYXJSZW5kZXJlciAmJlxuICAgIHBsYXllck92ZXJsYXlSZW5kZXJlci5kZWNvcmF0ZWRQbGF5ZXJCYXJSZW5kZXJlci5kZWNvcmF0ZWRQbGF5ZXJCYXJSZW5kZXJlci5wbGF5ZXJCYXI7XG4gIGNvbnN0IG1hcmtlcnNNYXAgPSBwbGF5ZXJCYXIgJiZcbiAgICBwbGF5ZXJCYXIubXVsdGlNYXJrZXJzUGxheWVyQmFyUmVuZGVyZXIgJiZcbiAgICBwbGF5ZXJCYXIubXVsdGlNYXJrZXJzUGxheWVyQmFyUmVuZGVyZXIubWFya2Vyc01hcDtcbiAgY29uc3QgbWFya2VyID0gQXJyYXkuaXNBcnJheShtYXJrZXJzTWFwKSAmJiBtYXJrZXJzTWFwLmZpbmQobSA9PiBtLnZhbHVlICYmIEFycmF5LmlzQXJyYXkobS52YWx1ZS5jaGFwdGVycykpO1xuICBpZiAoIW1hcmtlcikgcmV0dXJuIFtdO1xuICBjb25zdCBjaGFwdGVycyA9IG1hcmtlci52YWx1ZS5jaGFwdGVycztcblxuICByZXR1cm4gY2hhcHRlcnMubWFwKGNoYXB0ZXIgPT4gKHtcbiAgICB0aXRsZTogZ2V0VGV4dChjaGFwdGVyLmNoYXB0ZXJSZW5kZXJlci50aXRsZSksXG4gICAgc3RhcnRfdGltZTogY2hhcHRlci5jaGFwdGVyUmVuZGVyZXIudGltZVJhbmdlU3RhcnRNaWxsaXMgLyAxMDAwLFxuICB9KSk7XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ytdl-core/lib/info-extras.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ytdl-core/lib/info.js":
/*!********************************************!*\
  !*** ./node_modules/ytdl-core/lib/info.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("const querystring = __webpack_require__(/*! querystring */ \"querystring\");\nconst sax = __webpack_require__(/*! sax */ \"(rsc)/./node_modules/sax/lib/sax.js\");\nconst miniget = __webpack_require__(/*! miniget */ \"(rsc)/./node_modules/miniget/dist/index.js\");\nconst utils = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/ytdl-core/lib/utils.js\");\n// Forces Node JS version of setTimeout for Electron based applications\nconst { setTimeout } = __webpack_require__(/*! timers */ \"timers\");\nconst formatUtils = __webpack_require__(/*! ./format-utils */ \"(rsc)/./node_modules/ytdl-core/lib/format-utils.js\");\nconst urlUtils = __webpack_require__(/*! ./url-utils */ \"(rsc)/./node_modules/ytdl-core/lib/url-utils.js\");\nconst extras = __webpack_require__(/*! ./info-extras */ \"(rsc)/./node_modules/ytdl-core/lib/info-extras.js\");\nconst sig = __webpack_require__(/*! ./sig */ \"(rsc)/./node_modules/ytdl-core/lib/sig.js\");\nconst Cache = __webpack_require__(/*! ./cache */ \"(rsc)/./node_modules/ytdl-core/lib/cache.js\");\n\n\nconst BASE_URL = 'https://www.youtube.com/watch?v=';\n\n\n// Cached for storing basic/full info.\nexports.cache = new Cache();\nexports.cookieCache = new Cache(1000 * 60 * 60 * 24);\nexports.watchPageCache = new Cache();\n// Cache for cver used in getVideoInfoPage\nlet cver = '2.20210622.10.00';\n\n\n// Special error class used to determine if an error is unrecoverable,\n// as in, ytdl-core should not try again to fetch the video metadata.\n// In this case, the video is usually unavailable in some way.\nclass UnrecoverableError extends Error {}\n\n\n// List of URLs that show up in `notice_url` for age restricted videos.\nconst AGE_RESTRICTED_URLS = [\n  'support.google.com/youtube/?p=age_restrictions',\n  'youtube.com/t/community_guidelines',\n];\n\n\n/**\n * Gets info from a video without getting additional formats.\n *\n * @param {string} id\n * @param {Object} options\n * @returns {Promise<Object>}\n*/\nexports.getBasicInfo = async(id, options) => {\n  if (options.IPv6Block) {\n    options.requestOptions = Object.assign({}, options.requestOptions, {\n      family: 6,\n      localAddress: utils.getRandomIPv6(options.IPv6Block),\n    });\n  }\n  const retryOptions = Object.assign({}, miniget.defaultOptions, options.requestOptions);\n  options.requestOptions = Object.assign({}, options.requestOptions, {});\n  options.requestOptions.headers = Object.assign({},\n    {\n      // eslint-disable-next-line max-len\n      'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.101 Safari/537.36',\n    }, options.requestOptions.headers);\n  const validate = info => {\n    let playErr = utils.playError(info.player_response, ['ERROR'], UnrecoverableError);\n    let privateErr = privateVideoError(info.player_response);\n    if (playErr || privateErr) {\n      throw playErr || privateErr;\n    }\n    return info && info.player_response && (\n      info.player_response.streamingData || isRental(info.player_response) || isNotYetBroadcasted(info.player_response)\n    );\n  };\n  let info = await pipeline([id, options], validate, retryOptions, [\n    getWatchHTMLPage,\n    getWatchJSONPage,\n    getVideoInfoPage,\n  ]);\n\n  Object.assign(info, {\n    formats: parseFormats(info.player_response),\n    related_videos: extras.getRelatedVideos(info),\n  });\n\n  // Add additional properties to info.\n  const media = extras.getMedia(info);\n  const additional = {\n    author: extras.getAuthor(info),\n    media,\n    likes: extras.getLikes(info),\n    dislikes: extras.getDislikes(info),\n    age_restricted: !!(media && AGE_RESTRICTED_URLS.some(url =>\n      Object.values(media).some(v => typeof v === 'string' && v.includes(url)))\n    ),\n\n    // Give the standard link to the video.\n    video_url: BASE_URL + id,\n    storyboards: extras.getStoryboards(info),\n    chapters: extras.getChapters(info),\n  };\n\n  info.videoDetails = extras.cleanVideoDetails(Object.assign({},\n    info.player_response && info.player_response.microformat &&\n    info.player_response.microformat.playerMicroformatRenderer,\n    info.player_response && info.player_response.videoDetails, additional), info);\n\n  return info;\n};\n\nconst privateVideoError = player_response => {\n  let playability = player_response && player_response.playabilityStatus;\n  if (playability && playability.status === 'LOGIN_REQUIRED' && playability.messages &&\n    playability.messages.filter(m => /This is a private video/.test(m)).length) {\n    return new UnrecoverableError(playability.reason || (playability.messages && playability.messages[0]));\n  } else {\n    return null;\n  }\n};\n\n\nconst isRental = player_response => {\n  let playability = player_response.playabilityStatus;\n  return playability && playability.status === 'UNPLAYABLE' &&\n    playability.errorScreen && playability.errorScreen.playerLegacyDesktopYpcOfferRenderer;\n};\n\n\nconst isNotYetBroadcasted = player_response => {\n  let playability = player_response.playabilityStatus;\n  return playability && playability.status === 'LIVE_STREAM_OFFLINE';\n};\n\n\nconst getWatchHTMLURL = (id, options) => `${BASE_URL + id}&hl=${options.lang || 'en'}`;\nconst getWatchHTMLPageBody = (id, options) => {\n  const url = getWatchHTMLURL(id, options);\n  return exports.watchPageCache.getOrSet(url, () => utils.exposedMiniget(url, options).text());\n};\n\n\nconst EMBED_URL = 'https://www.youtube.com/embed/';\nconst getEmbedPageBody = (id, options) => {\n  const embedUrl = `${EMBED_URL + id}?hl=${options.lang || 'en'}`;\n  return utils.exposedMiniget(embedUrl, options).text();\n};\n\n\nconst getHTML5player = body => {\n  let html5playerRes =\n    /<script\\s+src=\"([^\"]+)\"(?:\\s+type=\"text\\/javascript\")?\\s+name=\"player_ias\\/base\"\\s*>|\"jsUrl\":\"([^\"]+)\"/\n      .exec(body);\n  return html5playerRes ? html5playerRes[1] || html5playerRes[2] : null;\n};\n\n\nconst getIdentityToken = (id, options, key, throwIfNotFound) =>\n  exports.cookieCache.getOrSet(key, async() => {\n    let page = await getWatchHTMLPageBody(id, options);\n    let match = page.match(/([\"'])ID_TOKEN\\1[:,]\\s?\"([^\"]+)\"/);\n    if (!match && throwIfNotFound) {\n      throw new UnrecoverableError('Cookie header used in request, but unable to find YouTube identity token');\n    }\n    return match && match[2];\n  });\n\n\n/**\n * Goes through each endpoint in the pipeline, retrying on failure if the error is recoverable.\n * If unable to succeed with one endpoint, moves onto the next one.\n *\n * @param {Array.<Object>} args\n * @param {Function} validate\n * @param {Object} retryOptions\n * @param {Array.<Function>} endpoints\n * @returns {[Object, Object, Object]}\n */\nconst pipeline = async(args, validate, retryOptions, endpoints) => {\n  let info;\n  for (let func of endpoints) {\n    try {\n      const newInfo = await retryFunc(func, args.concat([info]), retryOptions);\n      if (newInfo.player_response) {\n        newInfo.player_response.videoDetails = assign(\n          info && info.player_response && info.player_response.videoDetails,\n          newInfo.player_response.videoDetails);\n        newInfo.player_response = assign(info && info.player_response, newInfo.player_response);\n      }\n      info = assign(info, newInfo);\n      if (validate(info, false)) {\n        break;\n      }\n    } catch (err) {\n      if (err instanceof UnrecoverableError || func === endpoints[endpoints.length - 1]) {\n        throw err;\n      }\n      // Unable to find video metadata... so try next endpoint.\n    }\n  }\n  return info;\n};\n\n\n/**\n * Like Object.assign(), but ignores `null` and `undefined` from `source`.\n *\n * @param {Object} target\n * @param {Object} source\n * @returns {Object}\n */\nconst assign = (target, source) => {\n  if (!target || !source) { return target || source; }\n  for (let [key, value] of Object.entries(source)) {\n    if (value !== null && value !== undefined) {\n      target[key] = value;\n    }\n  }\n  return target;\n};\n\n\n/**\n * Given a function, calls it with `args` until it's successful,\n * or until it encounters an unrecoverable error.\n * Currently, any error from miniget is considered unrecoverable. Errors such as\n * too many redirects, invalid URL, status code 404, status code 502.\n *\n * @param {Function} func\n * @param {Array.<Object>} args\n * @param {Object} options\n * @param {number} options.maxRetries\n * @param {Object} options.backoff\n * @param {number} options.backoff.inc\n */\nconst retryFunc = async(func, args, options) => {\n  let currentTry = 0, result;\n  while (currentTry <= options.maxRetries) {\n    try {\n      result = await func(...args);\n      break;\n    } catch (err) {\n      if (err instanceof UnrecoverableError ||\n        (err instanceof miniget.MinigetError && err.statusCode < 500) || currentTry >= options.maxRetries) {\n        throw err;\n      }\n      let wait = Math.min(++currentTry * options.backoff.inc, options.backoff.max);\n      await new Promise(resolve => setTimeout(resolve, wait));\n    }\n  }\n  return result;\n};\n\n\nconst jsonClosingChars = /^[)\\]}'\\s]+/;\nconst parseJSON = (source, varName, json) => {\n  if (!json || typeof json === 'object') {\n    return json;\n  } else {\n    try {\n      json = json.replace(jsonClosingChars, '');\n      return JSON.parse(json);\n    } catch (err) {\n      throw Error(`Error parsing ${varName} in ${source}: ${err.message}`);\n    }\n  }\n};\n\n\nconst findJSON = (source, varName, body, left, right, prependJSON) => {\n  let jsonStr = utils.between(body, left, right);\n  if (!jsonStr) {\n    throw Error(`Could not find ${varName} in ${source}`);\n  }\n  return parseJSON(source, varName, utils.cutAfterJS(`${prependJSON}${jsonStr}`));\n};\n\n\nconst findPlayerResponse = (source, info) => {\n  const player_response = info && (\n    (info.args && info.args.player_response) ||\n    info.player_response || info.playerResponse || info.embedded_player_response);\n  return parseJSON(source, 'player_response', player_response);\n};\n\n\nconst getWatchJSONURL = (id, options) => `${getWatchHTMLURL(id, options)}&pbj=1`;\nconst getWatchJSONPage = async(id, options) => {\n  const reqOptions = Object.assign({ headers: {} }, options.requestOptions);\n  let cookie = reqOptions.headers.Cookie || reqOptions.headers.cookie;\n  reqOptions.headers = Object.assign({\n    'x-youtube-client-name': '1',\n    'x-youtube-client-version': cver,\n    'x-youtube-identity-token': exports.cookieCache.get(cookie || 'browser') || '',\n  }, reqOptions.headers);\n\n  const setIdentityToken = async(key, throwIfNotFound) => {\n    if (reqOptions.headers['x-youtube-identity-token']) { return; }\n    reqOptions.headers['x-youtube-identity-token'] = await getIdentityToken(id, options, key, throwIfNotFound);\n  };\n\n  if (cookie) {\n    await setIdentityToken(cookie, true);\n  }\n\n  const jsonUrl = getWatchJSONURL(id, options);\n  const body = await utils.exposedMiniget(jsonUrl, options, reqOptions).text();\n  let parsedBody = parseJSON('watch.json', 'body', body);\n  if (parsedBody.reload === 'now') {\n    await setIdentityToken('browser', false);\n  }\n  if (parsedBody.reload === 'now' || !Array.isArray(parsedBody)) {\n    throw Error('Unable to retrieve video metadata in watch.json');\n  }\n  let info = parsedBody.reduce((part, curr) => Object.assign(curr, part), {});\n  info.player_response = findPlayerResponse('watch.json', info);\n  info.html5player = info.player && info.player.assets && info.player.assets.js;\n\n  return info;\n};\n\n\nconst getWatchHTMLPage = async(id, options) => {\n  let body = await getWatchHTMLPageBody(id, options);\n  let info = { page: 'watch' };\n  try {\n    cver = utils.between(body, '{\"key\":\"cver\",\"value\":\"', '\"}');\n    info.player_response = findJSON('watch.html', 'player_response',\n      body, /\\bytInitialPlayerResponse\\s*=\\s*\\{/i, '</script>', '{');\n  } catch (err) {\n    let args = findJSON('watch.html', 'player_response', body, /\\bytplayer\\.config\\s*=\\s*{/, '</script>', '{');\n    info.player_response = findPlayerResponse('watch.html', args);\n  }\n  info.response = findJSON('watch.html', 'response', body, /\\bytInitialData(\"\\])?\\s*=\\s*\\{/i, '</script>', '{');\n  info.html5player = getHTML5player(body);\n  return info;\n};\n\n\nconst INFO_HOST = 'www.youtube.com';\nconst INFO_PATH = '/get_video_info';\nconst VIDEO_EURL = 'https://youtube.googleapis.com/v/';\nconst getVideoInfoPage = async(id, options) => {\n  const url = new URL(`https://${INFO_HOST}${INFO_PATH}`);\n  url.searchParams.set('video_id', id);\n  url.searchParams.set('c', 'TVHTML5');\n  url.searchParams.set('cver', `7${cver.substr(1)}`);\n  url.searchParams.set('eurl', VIDEO_EURL + id);\n  url.searchParams.set('ps', 'default');\n  url.searchParams.set('gl', 'US');\n  url.searchParams.set('hl', options.lang || 'en');\n  url.searchParams.set('html5', '1');\n  const body = await utils.exposedMiniget(url.toString(), options).text();\n  let info = querystring.parse(body);\n  info.player_response = findPlayerResponse('get_video_info', info);\n  return info;\n};\n\n\n/**\n * @param {Object} player_response\n * @returns {Array.<Object>}\n */\nconst parseFormats = player_response => {\n  let formats = [];\n  if (player_response && player_response.streamingData) {\n    formats = formats\n      .concat(player_response.streamingData.formats || [])\n      .concat(player_response.streamingData.adaptiveFormats || []);\n  }\n  return formats;\n};\n\n\n/**\n * Gets info from a video additional formats and deciphered URLs.\n *\n * @param {string} id\n * @param {Object} options\n * @returns {Promise<Object>}\n */\nexports.getInfo = async(id, options) => {\n  let info = await exports.getBasicInfo(id, options);\n  const hasManifest =\n    info.player_response && info.player_response.streamingData && (\n      info.player_response.streamingData.dashManifestUrl ||\n      info.player_response.streamingData.hlsManifestUrl\n    );\n  let funcs = [];\n  if (info.formats.length) {\n    info.html5player = info.html5player ||\n      getHTML5player(await getWatchHTMLPageBody(id, options)) || getHTML5player(await getEmbedPageBody(id, options));\n    if (!info.html5player) {\n      throw Error('Unable to find html5player file');\n    }\n    const html5player = new URL(info.html5player, BASE_URL).toString();\n    funcs.push(sig.decipherFormats(info.formats, html5player, options));\n  }\n  if (hasManifest && info.player_response.streamingData.dashManifestUrl) {\n    let url = info.player_response.streamingData.dashManifestUrl;\n    funcs.push(getDashManifest(url, options));\n  }\n  if (hasManifest && info.player_response.streamingData.hlsManifestUrl) {\n    let url = info.player_response.streamingData.hlsManifestUrl;\n    funcs.push(getM3U8(url, options));\n  }\n\n  let results = await Promise.all(funcs);\n  info.formats = Object.values(Object.assign({}, ...results));\n  info.formats = info.formats.map(formatUtils.addFormatMeta);\n  info.formats.sort(formatUtils.sortFormats);\n  info.full = true;\n  return info;\n};\n\n\n/**\n * Gets additional DASH formats.\n *\n * @param {string} url\n * @param {Object} options\n * @returns {Promise<Array.<Object>>}\n */\nconst getDashManifest = (url, options) => new Promise((resolve, reject) => {\n  let formats = {};\n  const parser = sax.parser(false);\n  parser.onerror = reject;\n  let adaptationSet;\n  parser.onopentag = node => {\n    if (node.name === 'ADAPTATIONSET') {\n      adaptationSet = node.attributes;\n    } else if (node.name === 'REPRESENTATION') {\n      const itag = parseInt(node.attributes.ID);\n      if (!isNaN(itag)) {\n        formats[url] = Object.assign({\n          itag, url,\n          bitrate: parseInt(node.attributes.BANDWIDTH),\n          mimeType: `${adaptationSet.MIMETYPE}; codecs=\"${node.attributes.CODECS}\"`,\n        }, node.attributes.HEIGHT ? {\n          width: parseInt(node.attributes.WIDTH),\n          height: parseInt(node.attributes.HEIGHT),\n          fps: parseInt(node.attributes.FRAMERATE),\n        } : {\n          audioSampleRate: node.attributes.AUDIOSAMPLINGRATE,\n        });\n      }\n    }\n  };\n  parser.onend = () => { resolve(formats); };\n  const req = utils.exposedMiniget(new URL(url, BASE_URL).toString(), options);\n  req.setEncoding('utf8');\n  req.on('error', reject);\n  req.on('data', chunk => { parser.write(chunk); });\n  req.on('end', parser.close.bind(parser));\n});\n\n\n/**\n * Gets additional formats.\n *\n * @param {string} url\n * @param {Object} options\n * @returns {Promise<Array.<Object>>}\n */\nconst getM3U8 = async(url, options) => {\n  url = new URL(url, BASE_URL);\n  const body = await utils.exposedMiniget(url.toString(), options).text();\n  let formats = {};\n  body\n    .split('\\n')\n    .filter(line => /^https?:\\/\\//.test(line))\n    .forEach(line => {\n      const itag = parseInt(line.match(/\\/itag\\/(\\d+)\\//)[1]);\n      formats[line] = { itag, url: line };\n    });\n  return formats;\n};\n\n\n// Cache get info functions.\n// In case a user wants to get a video's info before downloading.\nfor (let funcName of ['getBasicInfo', 'getInfo']) {\n  /**\n   * @param {string} link\n   * @param {Object} options\n   * @returns {Promise<Object>}\n   */\n  const func = exports[funcName];\n  exports[funcName] = async(link, options = {}) => {\n    utils.checkForUpdates();\n    let id = await urlUtils.getVideoID(link);\n    const key = [funcName, id, options.lang].join('-');\n    return exports.cache.getOrSet(key, () => func(id, options));\n  };\n}\n\n\n// Export a few helpers.\nexports.validateID = urlUtils.validateID;\nexports.validateURL = urlUtils.validateURL;\nexports.getURLVideoID = urlUtils.getURLVideoID;\nexports.getVideoID = urlUtils.getVideoID;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMveXRkbC1jb3JlL2xpYi9pbmZvLmpzIiwibWFwcGluZ3MiOiJBQUFBLG9CQUFvQixtQkFBTyxDQUFDLGdDQUFhO0FBQ3pDLFlBQVksbUJBQU8sQ0FBQyxnREFBSztBQUN6QixnQkFBZ0IsbUJBQU8sQ0FBQywyREFBUztBQUNqQyxjQUFjLG1CQUFPLENBQUMsNERBQVM7QUFDL0I7QUFDQSxRQUFRLGFBQWEsRUFBRSxtQkFBTyxDQUFDLHNCQUFRO0FBQ3ZDLG9CQUFvQixtQkFBTyxDQUFDLDBFQUFnQjtBQUM1QyxpQkFBaUIsbUJBQU8sQ0FBQyxvRUFBYTtBQUN0QyxlQUFlLG1CQUFPLENBQUMsd0VBQWU7QUFDdEMsWUFBWSxtQkFBTyxDQUFDLHdEQUFPO0FBQzNCLGNBQWMsbUJBQU8sQ0FBQyw0REFBUzs7O0FBRy9COzs7QUFHQTtBQUNBLGFBQWE7QUFDYixtQkFBbUI7QUFDbkIsc0JBQXNCO0FBQ3RCO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsdUNBQXVDO0FBQ3ZDLDJDQUEyQyw0QkFBNEI7QUFDdkUsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQSxtREFBbUQsT0FBTztBQUMxRCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSw0Q0FBNEMsY0FBYyxNQUFNLHFCQUFxQjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLHNCQUFzQixlQUFlLE1BQU0scUJBQXFCO0FBQ2hFO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0IsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsUUFBUTtBQUNuQixXQUFXLGtCQUFrQjtBQUM3QixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsZ0JBQWdCO0FBQzNCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sbUNBQW1DLFNBQVMsS0FBSyxPQUFPLElBQUksWUFBWTtBQUN4RTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxTQUFTLEtBQUssT0FBTztBQUN2RDtBQUNBLHdEQUF3RCxZQUFZLEVBQUUsUUFBUTtBQUM5RTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSw0Q0FBNEMsNkJBQTZCO0FBQ3pFO0FBQ0EscUNBQXFDLGFBQWE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFO0FBQzVFO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLGlDQUFpQyw0QkFBNEI7QUFDN0Q7QUFDQSwrQ0FBK0MsbUJBQW1CO0FBQ2xFLElBQUk7QUFDSiwwRkFBMEYsa0JBQWtCO0FBQzVHO0FBQ0E7QUFDQSwwRkFBMEYsbUJBQW1CO0FBQzdHO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsVUFBVSxFQUFFLFVBQVU7QUFDdkQ7QUFDQTtBQUNBLG1DQUFtQyxlQUFlO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix5QkFBeUIsVUFBVSx1QkFBdUI7QUFDakYsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHNCQUFzQjtBQUNsRDtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLEtBQUs7QUFDTDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsZUFBZTtBQUNmO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLGtCQUFrQjtBQUNsQixtQkFBbUI7QUFDbkIscUJBQXFCO0FBQ3JCLGtCQUFrQiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxhZ2d5bVxcT25lRHJpdmVcXERlc2t0b3BcXHByb2plY3RzXFx5b3V0dWJlX3N1bW1hcml6ZXJcXG5vZGVfbW9kdWxlc1xceXRkbC1jb3JlXFxsaWJcXGluZm8uanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgcXVlcnlzdHJpbmcgPSByZXF1aXJlKCdxdWVyeXN0cmluZycpO1xuY29uc3Qgc2F4ID0gcmVxdWlyZSgnc2F4Jyk7XG5jb25zdCBtaW5pZ2V0ID0gcmVxdWlyZSgnbWluaWdldCcpO1xuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG4vLyBGb3JjZXMgTm9kZSBKUyB2ZXJzaW9uIG9mIHNldFRpbWVvdXQgZm9yIEVsZWN0cm9uIGJhc2VkIGFwcGxpY2F0aW9uc1xuY29uc3QgeyBzZXRUaW1lb3V0IH0gPSByZXF1aXJlKCd0aW1lcnMnKTtcbmNvbnN0IGZvcm1hdFV0aWxzID0gcmVxdWlyZSgnLi9mb3JtYXQtdXRpbHMnKTtcbmNvbnN0IHVybFV0aWxzID0gcmVxdWlyZSgnLi91cmwtdXRpbHMnKTtcbmNvbnN0IGV4dHJhcyA9IHJlcXVpcmUoJy4vaW5mby1leHRyYXMnKTtcbmNvbnN0IHNpZyA9IHJlcXVpcmUoJy4vc2lnJyk7XG5jb25zdCBDYWNoZSA9IHJlcXVpcmUoJy4vY2FjaGUnKTtcblxuXG5jb25zdCBCQVNFX1VSTCA9ICdodHRwczovL3d3dy55b3V0dWJlLmNvbS93YXRjaD92PSc7XG5cblxuLy8gQ2FjaGVkIGZvciBzdG9yaW5nIGJhc2ljL2Z1bGwgaW5mby5cbmV4cG9ydHMuY2FjaGUgPSBuZXcgQ2FjaGUoKTtcbmV4cG9ydHMuY29va2llQ2FjaGUgPSBuZXcgQ2FjaGUoMTAwMCAqIDYwICogNjAgKiAyNCk7XG5leHBvcnRzLndhdGNoUGFnZUNhY2hlID0gbmV3IENhY2hlKCk7XG4vLyBDYWNoZSBmb3IgY3ZlciB1c2VkIGluIGdldFZpZGVvSW5mb1BhZ2VcbmxldCBjdmVyID0gJzIuMjAyMTA2MjIuMTAuMDAnO1xuXG5cbi8vIFNwZWNpYWwgZXJyb3IgY2xhc3MgdXNlZCB0byBkZXRlcm1pbmUgaWYgYW4gZXJyb3IgaXMgdW5yZWNvdmVyYWJsZSxcbi8vIGFzIGluLCB5dGRsLWNvcmUgc2hvdWxkIG5vdCB0cnkgYWdhaW4gdG8gZmV0Y2ggdGhlIHZpZGVvIG1ldGFkYXRhLlxuLy8gSW4gdGhpcyBjYXNlLCB0aGUgdmlkZW8gaXMgdXN1YWxseSB1bmF2YWlsYWJsZSBpbiBzb21lIHdheS5cbmNsYXNzIFVucmVjb3ZlcmFibGVFcnJvciBleHRlbmRzIEVycm9yIHt9XG5cblxuLy8gTGlzdCBvZiBVUkxzIHRoYXQgc2hvdyB1cCBpbiBgbm90aWNlX3VybGAgZm9yIGFnZSByZXN0cmljdGVkIHZpZGVvcy5cbmNvbnN0IEFHRV9SRVNUUklDVEVEX1VSTFMgPSBbXG4gICdzdXBwb3J0Lmdvb2dsZS5jb20veW91dHViZS8/cD1hZ2VfcmVzdHJpY3Rpb25zJyxcbiAgJ3lvdXR1YmUuY29tL3QvY29tbXVuaXR5X2d1aWRlbGluZXMnLFxuXTtcblxuXG4vKipcbiAqIEdldHMgaW5mbyBmcm9tIGEgdmlkZW8gd2l0aG91dCBnZXR0aW5nIGFkZGl0aW9uYWwgZm9ybWF0cy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gaWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fVxuKi9cbmV4cG9ydHMuZ2V0QmFzaWNJbmZvID0gYXN5bmMoaWQsIG9wdGlvbnMpID0+IHtcbiAgaWYgKG9wdGlvbnMuSVB2NkJsb2NrKSB7XG4gICAgb3B0aW9ucy5yZXF1ZXN0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMucmVxdWVzdE9wdGlvbnMsIHtcbiAgICAgIGZhbWlseTogNixcbiAgICAgIGxvY2FsQWRkcmVzczogdXRpbHMuZ2V0UmFuZG9tSVB2NihvcHRpb25zLklQdjZCbG9jayksXG4gICAgfSk7XG4gIH1cbiAgY29uc3QgcmV0cnlPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgbWluaWdldC5kZWZhdWx0T3B0aW9ucywgb3B0aW9ucy5yZXF1ZXN0T3B0aW9ucyk7XG4gIG9wdGlvbnMucmVxdWVzdE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLnJlcXVlc3RPcHRpb25zLCB7fSk7XG4gIG9wdGlvbnMucmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oe30sXG4gICAge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1sZW5cbiAgICAgICdVc2VyLUFnZW50JzogJ01vemlsbGEvNS4wIChXaW5kb3dzIE5UIDEwLjA7IFdpbjY0OyB4NjQpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIENocm9tZS84Ny4wLjQyODAuMTAxIFNhZmFyaS81MzcuMzYnLFxuICAgIH0sIG9wdGlvbnMucmVxdWVzdE9wdGlvbnMuaGVhZGVycyk7XG4gIGNvbnN0IHZhbGlkYXRlID0gaW5mbyA9PiB7XG4gICAgbGV0IHBsYXlFcnIgPSB1dGlscy5wbGF5RXJyb3IoaW5mby5wbGF5ZXJfcmVzcG9uc2UsIFsnRVJST1InXSwgVW5yZWNvdmVyYWJsZUVycm9yKTtcbiAgICBsZXQgcHJpdmF0ZUVyciA9IHByaXZhdGVWaWRlb0Vycm9yKGluZm8ucGxheWVyX3Jlc3BvbnNlKTtcbiAgICBpZiAocGxheUVyciB8fCBwcml2YXRlRXJyKSB7XG4gICAgICB0aHJvdyBwbGF5RXJyIHx8IHByaXZhdGVFcnI7XG4gICAgfVxuICAgIHJldHVybiBpbmZvICYmIGluZm8ucGxheWVyX3Jlc3BvbnNlICYmIChcbiAgICAgIGluZm8ucGxheWVyX3Jlc3BvbnNlLnN0cmVhbWluZ0RhdGEgfHwgaXNSZW50YWwoaW5mby5wbGF5ZXJfcmVzcG9uc2UpIHx8IGlzTm90WWV0QnJvYWRjYXN0ZWQoaW5mby5wbGF5ZXJfcmVzcG9uc2UpXG4gICAgKTtcbiAgfTtcbiAgbGV0IGluZm8gPSBhd2FpdCBwaXBlbGluZShbaWQsIG9wdGlvbnNdLCB2YWxpZGF0ZSwgcmV0cnlPcHRpb25zLCBbXG4gICAgZ2V0V2F0Y2hIVE1MUGFnZSxcbiAgICBnZXRXYXRjaEpTT05QYWdlLFxuICAgIGdldFZpZGVvSW5mb1BhZ2UsXG4gIF0pO1xuXG4gIE9iamVjdC5hc3NpZ24oaW5mbywge1xuICAgIGZvcm1hdHM6IHBhcnNlRm9ybWF0cyhpbmZvLnBsYXllcl9yZXNwb25zZSksXG4gICAgcmVsYXRlZF92aWRlb3M6IGV4dHJhcy5nZXRSZWxhdGVkVmlkZW9zKGluZm8pLFxuICB9KTtcblxuICAvLyBBZGQgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIHRvIGluZm8uXG4gIGNvbnN0IG1lZGlhID0gZXh0cmFzLmdldE1lZGlhKGluZm8pO1xuICBjb25zdCBhZGRpdGlvbmFsID0ge1xuICAgIGF1dGhvcjogZXh0cmFzLmdldEF1dGhvcihpbmZvKSxcbiAgICBtZWRpYSxcbiAgICBsaWtlczogZXh0cmFzLmdldExpa2VzKGluZm8pLFxuICAgIGRpc2xpa2VzOiBleHRyYXMuZ2V0RGlzbGlrZXMoaW5mbyksXG4gICAgYWdlX3Jlc3RyaWN0ZWQ6ICEhKG1lZGlhICYmIEFHRV9SRVNUUklDVEVEX1VSTFMuc29tZSh1cmwgPT5cbiAgICAgIE9iamVjdC52YWx1ZXMobWVkaWEpLnNvbWUodiA9PiB0eXBlb2YgdiA9PT0gJ3N0cmluZycgJiYgdi5pbmNsdWRlcyh1cmwpKSlcbiAgICApLFxuXG4gICAgLy8gR2l2ZSB0aGUgc3RhbmRhcmQgbGluayB0byB0aGUgdmlkZW8uXG4gICAgdmlkZW9fdXJsOiBCQVNFX1VSTCArIGlkLFxuICAgIHN0b3J5Ym9hcmRzOiBleHRyYXMuZ2V0U3Rvcnlib2FyZHMoaW5mbyksXG4gICAgY2hhcHRlcnM6IGV4dHJhcy5nZXRDaGFwdGVycyhpbmZvKSxcbiAgfTtcblxuICBpbmZvLnZpZGVvRGV0YWlscyA9IGV4dHJhcy5jbGVhblZpZGVvRGV0YWlscyhPYmplY3QuYXNzaWduKHt9LFxuICAgIGluZm8ucGxheWVyX3Jlc3BvbnNlICYmIGluZm8ucGxheWVyX3Jlc3BvbnNlLm1pY3JvZm9ybWF0ICYmXG4gICAgaW5mby5wbGF5ZXJfcmVzcG9uc2UubWljcm9mb3JtYXQucGxheWVyTWljcm9mb3JtYXRSZW5kZXJlcixcbiAgICBpbmZvLnBsYXllcl9yZXNwb25zZSAmJiBpbmZvLnBsYXllcl9yZXNwb25zZS52aWRlb0RldGFpbHMsIGFkZGl0aW9uYWwpLCBpbmZvKTtcblxuICByZXR1cm4gaW5mbztcbn07XG5cbmNvbnN0IHByaXZhdGVWaWRlb0Vycm9yID0gcGxheWVyX3Jlc3BvbnNlID0+IHtcbiAgbGV0IHBsYXlhYmlsaXR5ID0gcGxheWVyX3Jlc3BvbnNlICYmIHBsYXllcl9yZXNwb25zZS5wbGF5YWJpbGl0eVN0YXR1cztcbiAgaWYgKHBsYXlhYmlsaXR5ICYmIHBsYXlhYmlsaXR5LnN0YXR1cyA9PT0gJ0xPR0lOX1JFUVVJUkVEJyAmJiBwbGF5YWJpbGl0eS5tZXNzYWdlcyAmJlxuICAgIHBsYXlhYmlsaXR5Lm1lc3NhZ2VzLmZpbHRlcihtID0+IC9UaGlzIGlzIGEgcHJpdmF0ZSB2aWRlby8udGVzdChtKSkubGVuZ3RoKSB7XG4gICAgcmV0dXJuIG5ldyBVbnJlY292ZXJhYmxlRXJyb3IocGxheWFiaWxpdHkucmVhc29uIHx8IChwbGF5YWJpbGl0eS5tZXNzYWdlcyAmJiBwbGF5YWJpbGl0eS5tZXNzYWdlc1swXSkpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59O1xuXG5cbmNvbnN0IGlzUmVudGFsID0gcGxheWVyX3Jlc3BvbnNlID0+IHtcbiAgbGV0IHBsYXlhYmlsaXR5ID0gcGxheWVyX3Jlc3BvbnNlLnBsYXlhYmlsaXR5U3RhdHVzO1xuICByZXR1cm4gcGxheWFiaWxpdHkgJiYgcGxheWFiaWxpdHkuc3RhdHVzID09PSAnVU5QTEFZQUJMRScgJiZcbiAgICBwbGF5YWJpbGl0eS5lcnJvclNjcmVlbiAmJiBwbGF5YWJpbGl0eS5lcnJvclNjcmVlbi5wbGF5ZXJMZWdhY3lEZXNrdG9wWXBjT2ZmZXJSZW5kZXJlcjtcbn07XG5cblxuY29uc3QgaXNOb3RZZXRCcm9hZGNhc3RlZCA9IHBsYXllcl9yZXNwb25zZSA9PiB7XG4gIGxldCBwbGF5YWJpbGl0eSA9IHBsYXllcl9yZXNwb25zZS5wbGF5YWJpbGl0eVN0YXR1cztcbiAgcmV0dXJuIHBsYXlhYmlsaXR5ICYmIHBsYXlhYmlsaXR5LnN0YXR1cyA9PT0gJ0xJVkVfU1RSRUFNX09GRkxJTkUnO1xufTtcblxuXG5jb25zdCBnZXRXYXRjaEhUTUxVUkwgPSAoaWQsIG9wdGlvbnMpID0+IGAke0JBU0VfVVJMICsgaWR9JmhsPSR7b3B0aW9ucy5sYW5nIHx8ICdlbid9YDtcbmNvbnN0IGdldFdhdGNoSFRNTFBhZ2VCb2R5ID0gKGlkLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHVybCA9IGdldFdhdGNoSFRNTFVSTChpZCwgb3B0aW9ucyk7XG4gIHJldHVybiBleHBvcnRzLndhdGNoUGFnZUNhY2hlLmdldE9yU2V0KHVybCwgKCkgPT4gdXRpbHMuZXhwb3NlZE1pbmlnZXQodXJsLCBvcHRpb25zKS50ZXh0KCkpO1xufTtcblxuXG5jb25zdCBFTUJFRF9VUkwgPSAnaHR0cHM6Ly93d3cueW91dHViZS5jb20vZW1iZWQvJztcbmNvbnN0IGdldEVtYmVkUGFnZUJvZHkgPSAoaWQsIG9wdGlvbnMpID0+IHtcbiAgY29uc3QgZW1iZWRVcmwgPSBgJHtFTUJFRF9VUkwgKyBpZH0/aGw9JHtvcHRpb25zLmxhbmcgfHwgJ2VuJ31gO1xuICByZXR1cm4gdXRpbHMuZXhwb3NlZE1pbmlnZXQoZW1iZWRVcmwsIG9wdGlvbnMpLnRleHQoKTtcbn07XG5cblxuY29uc3QgZ2V0SFRNTDVwbGF5ZXIgPSBib2R5ID0+IHtcbiAgbGV0IGh0bWw1cGxheWVyUmVzID1cbiAgICAvPHNjcmlwdFxccytzcmM9XCIoW15cIl0rKVwiKD86XFxzK3R5cGU9XCJ0ZXh0XFwvamF2YXNjcmlwdFwiKT9cXHMrbmFtZT1cInBsYXllcl9pYXNcXC9iYXNlXCJcXHMqPnxcImpzVXJsXCI6XCIoW15cIl0rKVwiL1xuICAgICAgLmV4ZWMoYm9keSk7XG4gIHJldHVybiBodG1sNXBsYXllclJlcyA/IGh0bWw1cGxheWVyUmVzWzFdIHx8IGh0bWw1cGxheWVyUmVzWzJdIDogbnVsbDtcbn07XG5cblxuY29uc3QgZ2V0SWRlbnRpdHlUb2tlbiA9IChpZCwgb3B0aW9ucywga2V5LCB0aHJvd0lmTm90Rm91bmQpID0+XG4gIGV4cG9ydHMuY29va2llQ2FjaGUuZ2V0T3JTZXQoa2V5LCBhc3luYygpID0+IHtcbiAgICBsZXQgcGFnZSA9IGF3YWl0IGdldFdhdGNoSFRNTFBhZ2VCb2R5KGlkLCBvcHRpb25zKTtcbiAgICBsZXQgbWF0Y2ggPSBwYWdlLm1hdGNoKC8oW1wiJ10pSURfVE9LRU5cXDFbOixdXFxzP1wiKFteXCJdKylcIi8pO1xuICAgIGlmICghbWF0Y2ggJiYgdGhyb3dJZk5vdEZvdW5kKSB7XG4gICAgICB0aHJvdyBuZXcgVW5yZWNvdmVyYWJsZUVycm9yKCdDb29raWUgaGVhZGVyIHVzZWQgaW4gcmVxdWVzdCwgYnV0IHVuYWJsZSB0byBmaW5kIFlvdVR1YmUgaWRlbnRpdHkgdG9rZW4nKTtcbiAgICB9XG4gICAgcmV0dXJuIG1hdGNoICYmIG1hdGNoWzJdO1xuICB9KTtcblxuXG4vKipcbiAqIEdvZXMgdGhyb3VnaCBlYWNoIGVuZHBvaW50IGluIHRoZSBwaXBlbGluZSwgcmV0cnlpbmcgb24gZmFpbHVyZSBpZiB0aGUgZXJyb3IgaXMgcmVjb3ZlcmFibGUuXG4gKiBJZiB1bmFibGUgdG8gc3VjY2VlZCB3aXRoIG9uZSBlbmRwb2ludCwgbW92ZXMgb250byB0aGUgbmV4dCBvbmUuXG4gKlxuICogQHBhcmFtIHtBcnJheS48T2JqZWN0Pn0gYXJnc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gdmFsaWRhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSByZXRyeU9wdGlvbnNcbiAqIEBwYXJhbSB7QXJyYXkuPEZ1bmN0aW9uPn0gZW5kcG9pbnRzXG4gKiBAcmV0dXJucyB7W09iamVjdCwgT2JqZWN0LCBPYmplY3RdfVxuICovXG5jb25zdCBwaXBlbGluZSA9IGFzeW5jKGFyZ3MsIHZhbGlkYXRlLCByZXRyeU9wdGlvbnMsIGVuZHBvaW50cykgPT4ge1xuICBsZXQgaW5mbztcbiAgZm9yIChsZXQgZnVuYyBvZiBlbmRwb2ludHMpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgbmV3SW5mbyA9IGF3YWl0IHJldHJ5RnVuYyhmdW5jLCBhcmdzLmNvbmNhdChbaW5mb10pLCByZXRyeU9wdGlvbnMpO1xuICAgICAgaWYgKG5ld0luZm8ucGxheWVyX3Jlc3BvbnNlKSB7XG4gICAgICAgIG5ld0luZm8ucGxheWVyX3Jlc3BvbnNlLnZpZGVvRGV0YWlscyA9IGFzc2lnbihcbiAgICAgICAgICBpbmZvICYmIGluZm8ucGxheWVyX3Jlc3BvbnNlICYmIGluZm8ucGxheWVyX3Jlc3BvbnNlLnZpZGVvRGV0YWlscyxcbiAgICAgICAgICBuZXdJbmZvLnBsYXllcl9yZXNwb25zZS52aWRlb0RldGFpbHMpO1xuICAgICAgICBuZXdJbmZvLnBsYXllcl9yZXNwb25zZSA9IGFzc2lnbihpbmZvICYmIGluZm8ucGxheWVyX3Jlc3BvbnNlLCBuZXdJbmZvLnBsYXllcl9yZXNwb25zZSk7XG4gICAgICB9XG4gICAgICBpbmZvID0gYXNzaWduKGluZm8sIG5ld0luZm8pO1xuICAgICAgaWYgKHZhbGlkYXRlKGluZm8sIGZhbHNlKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBVbnJlY292ZXJhYmxlRXJyb3IgfHwgZnVuYyA9PT0gZW5kcG9pbnRzW2VuZHBvaW50cy5sZW5ndGggLSAxXSkge1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgICAvLyBVbmFibGUgdG8gZmluZCB2aWRlbyBtZXRhZGF0YS4uLiBzbyB0cnkgbmV4dCBlbmRwb2ludC5cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGluZm87XG59O1xuXG5cbi8qKlxuICogTGlrZSBPYmplY3QuYXNzaWduKCksIGJ1dCBpZ25vcmVzIGBudWxsYCBhbmQgYHVuZGVmaW5lZGAgZnJvbSBgc291cmNlYC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICovXG5jb25zdCBhc3NpZ24gPSAodGFyZ2V0LCBzb3VyY2UpID0+IHtcbiAgaWYgKCF0YXJnZXQgfHwgIXNvdXJjZSkgeyByZXR1cm4gdGFyZ2V0IHx8IHNvdXJjZTsgfVxuICBmb3IgKGxldCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoc291cmNlKSkge1xuICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0YXJnZXRba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufTtcblxuXG4vKipcbiAqIEdpdmVuIGEgZnVuY3Rpb24sIGNhbGxzIGl0IHdpdGggYGFyZ3NgIHVudGlsIGl0J3Mgc3VjY2Vzc2Z1bCxcbiAqIG9yIHVudGlsIGl0IGVuY291bnRlcnMgYW4gdW5yZWNvdmVyYWJsZSBlcnJvci5cbiAqIEN1cnJlbnRseSwgYW55IGVycm9yIGZyb20gbWluaWdldCBpcyBjb25zaWRlcmVkIHVucmVjb3ZlcmFibGUuIEVycm9ycyBzdWNoIGFzXG4gKiB0b28gbWFueSByZWRpcmVjdHMsIGludmFsaWQgVVJMLCBzdGF0dXMgY29kZSA0MDQsIHN0YXR1cyBjb2RlIDUwMi5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jXG4gKiBAcGFyYW0ge0FycmF5LjxPYmplY3Q+fSBhcmdzXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMubWF4UmV0cmllc1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuYmFja29mZlxuICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuYmFja29mZi5pbmNcbiAqL1xuY29uc3QgcmV0cnlGdW5jID0gYXN5bmMoZnVuYywgYXJncywgb3B0aW9ucykgPT4ge1xuICBsZXQgY3VycmVudFRyeSA9IDAsIHJlc3VsdDtcbiAgd2hpbGUgKGN1cnJlbnRUcnkgPD0gb3B0aW9ucy5tYXhSZXRyaWVzKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJlc3VsdCA9IGF3YWl0IGZ1bmMoLi4uYXJncyk7XG4gICAgICBicmVhaztcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBVbnJlY292ZXJhYmxlRXJyb3IgfHxcbiAgICAgICAgKGVyciBpbnN0YW5jZW9mIG1pbmlnZXQuTWluaWdldEVycm9yICYmIGVyci5zdGF0dXNDb2RlIDwgNTAwKSB8fCBjdXJyZW50VHJ5ID49IG9wdGlvbnMubWF4UmV0cmllcykge1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgICBsZXQgd2FpdCA9IE1hdGgubWluKCsrY3VycmVudFRyeSAqIG9wdGlvbnMuYmFja29mZi5pbmMsIG9wdGlvbnMuYmFja29mZi5tYXgpO1xuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIHdhaXQpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuY29uc3QganNvbkNsb3NpbmdDaGFycyA9IC9eWylcXF19J1xcc10rLztcbmNvbnN0IHBhcnNlSlNPTiA9IChzb3VyY2UsIHZhck5hbWUsIGpzb24pID0+IHtcbiAgaWYgKCFqc29uIHx8IHR5cGVvZiBqc29uID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBqc29uO1xuICB9IGVsc2Uge1xuICAgIHRyeSB7XG4gICAgICBqc29uID0ganNvbi5yZXBsYWNlKGpzb25DbG9zaW5nQ2hhcnMsICcnKTtcbiAgICAgIHJldHVybiBKU09OLnBhcnNlKGpzb24pO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhyb3cgRXJyb3IoYEVycm9yIHBhcnNpbmcgJHt2YXJOYW1lfSBpbiAke3NvdXJjZX06ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgfVxuICB9XG59O1xuXG5cbmNvbnN0IGZpbmRKU09OID0gKHNvdXJjZSwgdmFyTmFtZSwgYm9keSwgbGVmdCwgcmlnaHQsIHByZXBlbmRKU09OKSA9PiB7XG4gIGxldCBqc29uU3RyID0gdXRpbHMuYmV0d2Vlbihib2R5LCBsZWZ0LCByaWdodCk7XG4gIGlmICghanNvblN0cikge1xuICAgIHRocm93IEVycm9yKGBDb3VsZCBub3QgZmluZCAke3Zhck5hbWV9IGluICR7c291cmNlfWApO1xuICB9XG4gIHJldHVybiBwYXJzZUpTT04oc291cmNlLCB2YXJOYW1lLCB1dGlscy5jdXRBZnRlckpTKGAke3ByZXBlbmRKU09OfSR7anNvblN0cn1gKSk7XG59O1xuXG5cbmNvbnN0IGZpbmRQbGF5ZXJSZXNwb25zZSA9IChzb3VyY2UsIGluZm8pID0+IHtcbiAgY29uc3QgcGxheWVyX3Jlc3BvbnNlID0gaW5mbyAmJiAoXG4gICAgKGluZm8uYXJncyAmJiBpbmZvLmFyZ3MucGxheWVyX3Jlc3BvbnNlKSB8fFxuICAgIGluZm8ucGxheWVyX3Jlc3BvbnNlIHx8IGluZm8ucGxheWVyUmVzcG9uc2UgfHwgaW5mby5lbWJlZGRlZF9wbGF5ZXJfcmVzcG9uc2UpO1xuICByZXR1cm4gcGFyc2VKU09OKHNvdXJjZSwgJ3BsYXllcl9yZXNwb25zZScsIHBsYXllcl9yZXNwb25zZSk7XG59O1xuXG5cbmNvbnN0IGdldFdhdGNoSlNPTlVSTCA9IChpZCwgb3B0aW9ucykgPT4gYCR7Z2V0V2F0Y2hIVE1MVVJMKGlkLCBvcHRpb25zKX0mcGJqPTFgO1xuY29uc3QgZ2V0V2F0Y2hKU09OUGFnZSA9IGFzeW5jKGlkLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHJlcU9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHsgaGVhZGVyczoge30gfSwgb3B0aW9ucy5yZXF1ZXN0T3B0aW9ucyk7XG4gIGxldCBjb29raWUgPSByZXFPcHRpb25zLmhlYWRlcnMuQ29va2llIHx8IHJlcU9wdGlvbnMuaGVhZGVycy5jb29raWU7XG4gIHJlcU9wdGlvbnMuaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICd4LXlvdXR1YmUtY2xpZW50LW5hbWUnOiAnMScsXG4gICAgJ3gteW91dHViZS1jbGllbnQtdmVyc2lvbic6IGN2ZXIsXG4gICAgJ3gteW91dHViZS1pZGVudGl0eS10b2tlbic6IGV4cG9ydHMuY29va2llQ2FjaGUuZ2V0KGNvb2tpZSB8fCAnYnJvd3NlcicpIHx8ICcnLFxuICB9LCByZXFPcHRpb25zLmhlYWRlcnMpO1xuXG4gIGNvbnN0IHNldElkZW50aXR5VG9rZW4gPSBhc3luYyhrZXksIHRocm93SWZOb3RGb3VuZCkgPT4ge1xuICAgIGlmIChyZXFPcHRpb25zLmhlYWRlcnNbJ3gteW91dHViZS1pZGVudGl0eS10b2tlbiddKSB7IHJldHVybjsgfVxuICAgIHJlcU9wdGlvbnMuaGVhZGVyc1sneC15b3V0dWJlLWlkZW50aXR5LXRva2VuJ10gPSBhd2FpdCBnZXRJZGVudGl0eVRva2VuKGlkLCBvcHRpb25zLCBrZXksIHRocm93SWZOb3RGb3VuZCk7XG4gIH07XG5cbiAgaWYgKGNvb2tpZSkge1xuICAgIGF3YWl0IHNldElkZW50aXR5VG9rZW4oY29va2llLCB0cnVlKTtcbiAgfVxuXG4gIGNvbnN0IGpzb25VcmwgPSBnZXRXYXRjaEpTT05VUkwoaWQsIG9wdGlvbnMpO1xuICBjb25zdCBib2R5ID0gYXdhaXQgdXRpbHMuZXhwb3NlZE1pbmlnZXQoanNvblVybCwgb3B0aW9ucywgcmVxT3B0aW9ucykudGV4dCgpO1xuICBsZXQgcGFyc2VkQm9keSA9IHBhcnNlSlNPTignd2F0Y2guanNvbicsICdib2R5JywgYm9keSk7XG4gIGlmIChwYXJzZWRCb2R5LnJlbG9hZCA9PT0gJ25vdycpIHtcbiAgICBhd2FpdCBzZXRJZGVudGl0eVRva2VuKCdicm93c2VyJywgZmFsc2UpO1xuICB9XG4gIGlmIChwYXJzZWRCb2R5LnJlbG9hZCA9PT0gJ25vdycgfHwgIUFycmF5LmlzQXJyYXkocGFyc2VkQm9keSkpIHtcbiAgICB0aHJvdyBFcnJvcignVW5hYmxlIHRvIHJldHJpZXZlIHZpZGVvIG1ldGFkYXRhIGluIHdhdGNoLmpzb24nKTtcbiAgfVxuICBsZXQgaW5mbyA9IHBhcnNlZEJvZHkucmVkdWNlKChwYXJ0LCBjdXJyKSA9PiBPYmplY3QuYXNzaWduKGN1cnIsIHBhcnQpLCB7fSk7XG4gIGluZm8ucGxheWVyX3Jlc3BvbnNlID0gZmluZFBsYXllclJlc3BvbnNlKCd3YXRjaC5qc29uJywgaW5mbyk7XG4gIGluZm8uaHRtbDVwbGF5ZXIgPSBpbmZvLnBsYXllciAmJiBpbmZvLnBsYXllci5hc3NldHMgJiYgaW5mby5wbGF5ZXIuYXNzZXRzLmpzO1xuXG4gIHJldHVybiBpbmZvO1xufTtcblxuXG5jb25zdCBnZXRXYXRjaEhUTUxQYWdlID0gYXN5bmMoaWQsIG9wdGlvbnMpID0+IHtcbiAgbGV0IGJvZHkgPSBhd2FpdCBnZXRXYXRjaEhUTUxQYWdlQm9keShpZCwgb3B0aW9ucyk7XG4gIGxldCBpbmZvID0geyBwYWdlOiAnd2F0Y2gnIH07XG4gIHRyeSB7XG4gICAgY3ZlciA9IHV0aWxzLmJldHdlZW4oYm9keSwgJ3tcImtleVwiOlwiY3ZlclwiLFwidmFsdWVcIjpcIicsICdcIn0nKTtcbiAgICBpbmZvLnBsYXllcl9yZXNwb25zZSA9IGZpbmRKU09OKCd3YXRjaC5odG1sJywgJ3BsYXllcl9yZXNwb25zZScsXG4gICAgICBib2R5LCAvXFxieXRJbml0aWFsUGxheWVyUmVzcG9uc2VcXHMqPVxccypcXHsvaSwgJzwvc2NyaXB0PicsICd7Jyk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGxldCBhcmdzID0gZmluZEpTT04oJ3dhdGNoLmh0bWwnLCAncGxheWVyX3Jlc3BvbnNlJywgYm9keSwgL1xcYnl0cGxheWVyXFwuY29uZmlnXFxzKj1cXHMqey8sICc8L3NjcmlwdD4nLCAneycpO1xuICAgIGluZm8ucGxheWVyX3Jlc3BvbnNlID0gZmluZFBsYXllclJlc3BvbnNlKCd3YXRjaC5odG1sJywgYXJncyk7XG4gIH1cbiAgaW5mby5yZXNwb25zZSA9IGZpbmRKU09OKCd3YXRjaC5odG1sJywgJ3Jlc3BvbnNlJywgYm9keSwgL1xcYnl0SW5pdGlhbERhdGEoXCJcXF0pP1xccyo9XFxzKlxcey9pLCAnPC9zY3JpcHQ+JywgJ3snKTtcbiAgaW5mby5odG1sNXBsYXllciA9IGdldEhUTUw1cGxheWVyKGJvZHkpO1xuICByZXR1cm4gaW5mbztcbn07XG5cblxuY29uc3QgSU5GT19IT1NUID0gJ3d3dy55b3V0dWJlLmNvbSc7XG5jb25zdCBJTkZPX1BBVEggPSAnL2dldF92aWRlb19pbmZvJztcbmNvbnN0IFZJREVPX0VVUkwgPSAnaHR0cHM6Ly95b3V0dWJlLmdvb2dsZWFwaXMuY29tL3YvJztcbmNvbnN0IGdldFZpZGVvSW5mb1BhZ2UgPSBhc3luYyhpZCwgb3B0aW9ucykgPT4ge1xuICBjb25zdCB1cmwgPSBuZXcgVVJMKGBodHRwczovLyR7SU5GT19IT1NUfSR7SU5GT19QQVRIfWApO1xuICB1cmwuc2VhcmNoUGFyYW1zLnNldCgndmlkZW9faWQnLCBpZCk7XG4gIHVybC5zZWFyY2hQYXJhbXMuc2V0KCdjJywgJ1RWSFRNTDUnKTtcbiAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoJ2N2ZXInLCBgNyR7Y3Zlci5zdWJzdHIoMSl9YCk7XG4gIHVybC5zZWFyY2hQYXJhbXMuc2V0KCdldXJsJywgVklERU9fRVVSTCArIGlkKTtcbiAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoJ3BzJywgJ2RlZmF1bHQnKTtcbiAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoJ2dsJywgJ1VTJyk7XG4gIHVybC5zZWFyY2hQYXJhbXMuc2V0KCdobCcsIG9wdGlvbnMubGFuZyB8fCAnZW4nKTtcbiAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoJ2h0bWw1JywgJzEnKTtcbiAgY29uc3QgYm9keSA9IGF3YWl0IHV0aWxzLmV4cG9zZWRNaW5pZ2V0KHVybC50b1N0cmluZygpLCBvcHRpb25zKS50ZXh0KCk7XG4gIGxldCBpbmZvID0gcXVlcnlzdHJpbmcucGFyc2UoYm9keSk7XG4gIGluZm8ucGxheWVyX3Jlc3BvbnNlID0gZmluZFBsYXllclJlc3BvbnNlKCdnZXRfdmlkZW9faW5mbycsIGluZm8pO1xuICByZXR1cm4gaW5mbztcbn07XG5cblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdH0gcGxheWVyX3Jlc3BvbnNlXG4gKiBAcmV0dXJucyB7QXJyYXkuPE9iamVjdD59XG4gKi9cbmNvbnN0IHBhcnNlRm9ybWF0cyA9IHBsYXllcl9yZXNwb25zZSA9PiB7XG4gIGxldCBmb3JtYXRzID0gW107XG4gIGlmIChwbGF5ZXJfcmVzcG9uc2UgJiYgcGxheWVyX3Jlc3BvbnNlLnN0cmVhbWluZ0RhdGEpIHtcbiAgICBmb3JtYXRzID0gZm9ybWF0c1xuICAgICAgLmNvbmNhdChwbGF5ZXJfcmVzcG9uc2Uuc3RyZWFtaW5nRGF0YS5mb3JtYXRzIHx8IFtdKVxuICAgICAgLmNvbmNhdChwbGF5ZXJfcmVzcG9uc2Uuc3RyZWFtaW5nRGF0YS5hZGFwdGl2ZUZvcm1hdHMgfHwgW10pO1xuICB9XG4gIHJldHVybiBmb3JtYXRzO1xufTtcblxuXG4vKipcbiAqIEdldHMgaW5mbyBmcm9tIGEgdmlkZW8gYWRkaXRpb25hbCBmb3JtYXRzIGFuZCBkZWNpcGhlcmVkIFVSTHMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGlkXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn1cbiAqL1xuZXhwb3J0cy5nZXRJbmZvID0gYXN5bmMoaWQsIG9wdGlvbnMpID0+IHtcbiAgbGV0IGluZm8gPSBhd2FpdCBleHBvcnRzLmdldEJhc2ljSW5mbyhpZCwgb3B0aW9ucyk7XG4gIGNvbnN0IGhhc01hbmlmZXN0ID1cbiAgICBpbmZvLnBsYXllcl9yZXNwb25zZSAmJiBpbmZvLnBsYXllcl9yZXNwb25zZS5zdHJlYW1pbmdEYXRhICYmIChcbiAgICAgIGluZm8ucGxheWVyX3Jlc3BvbnNlLnN0cmVhbWluZ0RhdGEuZGFzaE1hbmlmZXN0VXJsIHx8XG4gICAgICBpbmZvLnBsYXllcl9yZXNwb25zZS5zdHJlYW1pbmdEYXRhLmhsc01hbmlmZXN0VXJsXG4gICAgKTtcbiAgbGV0IGZ1bmNzID0gW107XG4gIGlmIChpbmZvLmZvcm1hdHMubGVuZ3RoKSB7XG4gICAgaW5mby5odG1sNXBsYXllciA9IGluZm8uaHRtbDVwbGF5ZXIgfHxcbiAgICAgIGdldEhUTUw1cGxheWVyKGF3YWl0IGdldFdhdGNoSFRNTFBhZ2VCb2R5KGlkLCBvcHRpb25zKSkgfHwgZ2V0SFRNTDVwbGF5ZXIoYXdhaXQgZ2V0RW1iZWRQYWdlQm9keShpZCwgb3B0aW9ucykpO1xuICAgIGlmICghaW5mby5odG1sNXBsYXllcikge1xuICAgICAgdGhyb3cgRXJyb3IoJ1VuYWJsZSB0byBmaW5kIGh0bWw1cGxheWVyIGZpbGUnKTtcbiAgICB9XG4gICAgY29uc3QgaHRtbDVwbGF5ZXIgPSBuZXcgVVJMKGluZm8uaHRtbDVwbGF5ZXIsIEJBU0VfVVJMKS50b1N0cmluZygpO1xuICAgIGZ1bmNzLnB1c2goc2lnLmRlY2lwaGVyRm9ybWF0cyhpbmZvLmZvcm1hdHMsIGh0bWw1cGxheWVyLCBvcHRpb25zKSk7XG4gIH1cbiAgaWYgKGhhc01hbmlmZXN0ICYmIGluZm8ucGxheWVyX3Jlc3BvbnNlLnN0cmVhbWluZ0RhdGEuZGFzaE1hbmlmZXN0VXJsKSB7XG4gICAgbGV0IHVybCA9IGluZm8ucGxheWVyX3Jlc3BvbnNlLnN0cmVhbWluZ0RhdGEuZGFzaE1hbmlmZXN0VXJsO1xuICAgIGZ1bmNzLnB1c2goZ2V0RGFzaE1hbmlmZXN0KHVybCwgb3B0aW9ucykpO1xuICB9XG4gIGlmIChoYXNNYW5pZmVzdCAmJiBpbmZvLnBsYXllcl9yZXNwb25zZS5zdHJlYW1pbmdEYXRhLmhsc01hbmlmZXN0VXJsKSB7XG4gICAgbGV0IHVybCA9IGluZm8ucGxheWVyX3Jlc3BvbnNlLnN0cmVhbWluZ0RhdGEuaGxzTWFuaWZlc3RVcmw7XG4gICAgZnVuY3MucHVzaChnZXRNM1U4KHVybCwgb3B0aW9ucykpO1xuICB9XG5cbiAgbGV0IHJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbChmdW5jcyk7XG4gIGluZm8uZm9ybWF0cyA9IE9iamVjdC52YWx1ZXMoT2JqZWN0LmFzc2lnbih7fSwgLi4ucmVzdWx0cykpO1xuICBpbmZvLmZvcm1hdHMgPSBpbmZvLmZvcm1hdHMubWFwKGZvcm1hdFV0aWxzLmFkZEZvcm1hdE1ldGEpO1xuICBpbmZvLmZvcm1hdHMuc29ydChmb3JtYXRVdGlscy5zb3J0Rm9ybWF0cyk7XG4gIGluZm8uZnVsbCA9IHRydWU7XG4gIHJldHVybiBpbmZvO1xufTtcblxuXG4vKipcbiAqIEdldHMgYWRkaXRpb25hbCBEQVNIIGZvcm1hdHMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm5zIHtQcm9taXNlPEFycmF5LjxPYmplY3Q+Pn1cbiAqL1xuY29uc3QgZ2V0RGFzaE1hbmlmZXN0ID0gKHVybCwgb3B0aW9ucykgPT4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICBsZXQgZm9ybWF0cyA9IHt9O1xuICBjb25zdCBwYXJzZXIgPSBzYXgucGFyc2VyKGZhbHNlKTtcbiAgcGFyc2VyLm9uZXJyb3IgPSByZWplY3Q7XG4gIGxldCBhZGFwdGF0aW9uU2V0O1xuICBwYXJzZXIub25vcGVudGFnID0gbm9kZSA9PiB7XG4gICAgaWYgKG5vZGUubmFtZSA9PT0gJ0FEQVBUQVRJT05TRVQnKSB7XG4gICAgICBhZGFwdGF0aW9uU2V0ID0gbm9kZS5hdHRyaWJ1dGVzO1xuICAgIH0gZWxzZSBpZiAobm9kZS5uYW1lID09PSAnUkVQUkVTRU5UQVRJT04nKSB7XG4gICAgICBjb25zdCBpdGFnID0gcGFyc2VJbnQobm9kZS5hdHRyaWJ1dGVzLklEKTtcbiAgICAgIGlmICghaXNOYU4oaXRhZykpIHtcbiAgICAgICAgZm9ybWF0c1t1cmxdID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgaXRhZywgdXJsLFxuICAgICAgICAgIGJpdHJhdGU6IHBhcnNlSW50KG5vZGUuYXR0cmlidXRlcy5CQU5EV0lEVEgpLFxuICAgICAgICAgIG1pbWVUeXBlOiBgJHthZGFwdGF0aW9uU2V0Lk1JTUVUWVBFfTsgY29kZWNzPVwiJHtub2RlLmF0dHJpYnV0ZXMuQ09ERUNTfVwiYCxcbiAgICAgICAgfSwgbm9kZS5hdHRyaWJ1dGVzLkhFSUdIVCA/IHtcbiAgICAgICAgICB3aWR0aDogcGFyc2VJbnQobm9kZS5hdHRyaWJ1dGVzLldJRFRIKSxcbiAgICAgICAgICBoZWlnaHQ6IHBhcnNlSW50KG5vZGUuYXR0cmlidXRlcy5IRUlHSFQpLFxuICAgICAgICAgIGZwczogcGFyc2VJbnQobm9kZS5hdHRyaWJ1dGVzLkZSQU1FUkFURSksXG4gICAgICAgIH0gOiB7XG4gICAgICAgICAgYXVkaW9TYW1wbGVSYXRlOiBub2RlLmF0dHJpYnV0ZXMuQVVESU9TQU1QTElOR1JBVEUsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgcGFyc2VyLm9uZW5kID0gKCkgPT4geyByZXNvbHZlKGZvcm1hdHMpOyB9O1xuICBjb25zdCByZXEgPSB1dGlscy5leHBvc2VkTWluaWdldChuZXcgVVJMKHVybCwgQkFTRV9VUkwpLnRvU3RyaW5nKCksIG9wdGlvbnMpO1xuICByZXEuc2V0RW5jb2RpbmcoJ3V0ZjgnKTtcbiAgcmVxLm9uKCdlcnJvcicsIHJlamVjdCk7XG4gIHJlcS5vbignZGF0YScsIGNodW5rID0+IHsgcGFyc2VyLndyaXRlKGNodW5rKTsgfSk7XG4gIHJlcS5vbignZW5kJywgcGFyc2VyLmNsb3NlLmJpbmQocGFyc2VyKSk7XG59KTtcblxuXG4vKipcbiAqIEdldHMgYWRkaXRpb25hbCBmb3JtYXRzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxBcnJheS48T2JqZWN0Pj59XG4gKi9cbmNvbnN0IGdldE0zVTggPSBhc3luYyh1cmwsIG9wdGlvbnMpID0+IHtcbiAgdXJsID0gbmV3IFVSTCh1cmwsIEJBU0VfVVJMKTtcbiAgY29uc3QgYm9keSA9IGF3YWl0IHV0aWxzLmV4cG9zZWRNaW5pZ2V0KHVybC50b1N0cmluZygpLCBvcHRpb25zKS50ZXh0KCk7XG4gIGxldCBmb3JtYXRzID0ge307XG4gIGJvZHlcbiAgICAuc3BsaXQoJ1xcbicpXG4gICAgLmZpbHRlcihsaW5lID0+IC9eaHR0cHM/OlxcL1xcLy8udGVzdChsaW5lKSlcbiAgICAuZm9yRWFjaChsaW5lID0+IHtcbiAgICAgIGNvbnN0IGl0YWcgPSBwYXJzZUludChsaW5lLm1hdGNoKC9cXC9pdGFnXFwvKFxcZCspXFwvLylbMV0pO1xuICAgICAgZm9ybWF0c1tsaW5lXSA9IHsgaXRhZywgdXJsOiBsaW5lIH07XG4gICAgfSk7XG4gIHJldHVybiBmb3JtYXRzO1xufTtcblxuXG4vLyBDYWNoZSBnZXQgaW5mbyBmdW5jdGlvbnMuXG4vLyBJbiBjYXNlIGEgdXNlciB3YW50cyB0byBnZXQgYSB2aWRlbydzIGluZm8gYmVmb3JlIGRvd25sb2FkaW5nLlxuZm9yIChsZXQgZnVuY05hbWUgb2YgWydnZXRCYXNpY0luZm8nLCAnZ2V0SW5mbyddKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGlua1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fVxuICAgKi9cbiAgY29uc3QgZnVuYyA9IGV4cG9ydHNbZnVuY05hbWVdO1xuICBleHBvcnRzW2Z1bmNOYW1lXSA9IGFzeW5jKGxpbmssIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgIHV0aWxzLmNoZWNrRm9yVXBkYXRlcygpO1xuICAgIGxldCBpZCA9IGF3YWl0IHVybFV0aWxzLmdldFZpZGVvSUQobGluayk7XG4gICAgY29uc3Qga2V5ID0gW2Z1bmNOYW1lLCBpZCwgb3B0aW9ucy5sYW5nXS5qb2luKCctJyk7XG4gICAgcmV0dXJuIGV4cG9ydHMuY2FjaGUuZ2V0T3JTZXQoa2V5LCAoKSA9PiBmdW5jKGlkLCBvcHRpb25zKSk7XG4gIH07XG59XG5cblxuLy8gRXhwb3J0IGEgZmV3IGhlbHBlcnMuXG5leHBvcnRzLnZhbGlkYXRlSUQgPSB1cmxVdGlscy52YWxpZGF0ZUlEO1xuZXhwb3J0cy52YWxpZGF0ZVVSTCA9IHVybFV0aWxzLnZhbGlkYXRlVVJMO1xuZXhwb3J0cy5nZXRVUkxWaWRlb0lEID0gdXJsVXRpbHMuZ2V0VVJMVmlkZW9JRDtcbmV4cG9ydHMuZ2V0VmlkZW9JRCA9IHVybFV0aWxzLmdldFZpZGVvSUQ7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ytdl-core/lib/info.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ytdl-core/lib/sig.js":
/*!*******************************************!*\
  !*** ./node_modules/ytdl-core/lib/sig.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("const querystring = __webpack_require__(/*! querystring */ \"querystring\");\nconst Cache = __webpack_require__(/*! ./cache */ \"(rsc)/./node_modules/ytdl-core/lib/cache.js\");\nconst utils = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/ytdl-core/lib/utils.js\");\nconst vm = __webpack_require__(/*! vm */ \"vm\");\n\n// A shared cache to keep track of html5player js functions.\nexports.cache = new Cache();\n\n/**\n * Extract signature deciphering and n parameter transform functions from html5player file.\n *\n * @param {string} html5playerfile\n * @param {Object} options\n * @returns {Promise<Array.<string>>}\n */\nexports.getFunctions = (html5playerfile, options) => exports.cache.getOrSet(html5playerfile, async() => {\n  const body = await utils.exposedMiniget(html5playerfile, options).text();\n  const functions = exports.extractFunctions(body);\n  if (!functions || !functions.length) {\n    throw Error('Could not extract functions');\n  }\n  exports.cache.set(html5playerfile, functions);\n  return functions;\n});\n\n/**\n * Extracts the actions that should be taken to decipher a signature\n * and tranform the n parameter\n *\n * @param {string} body\n * @returns {Array.<string>}\n */\nexports.extractFunctions = body => {\n  const functions = [];\n  const extractManipulations = caller => {\n    const functionName = utils.between(caller, `a=a.split(\"\");`, `.`);\n    if (!functionName) return '';\n    const functionStart = `var ${functionName}={`;\n    const ndx = body.indexOf(functionStart);\n    if (ndx < 0) return '';\n    const subBody = body.slice(ndx + functionStart.length - 1);\n    return `var ${functionName}=${utils.cutAfterJS(subBody)}`;\n  };\n  const extractDecipher = () => {\n    const functionName = utils.between(body, `a.set(\"alr\",\"yes\");c&&(c=`, `(decodeURIC`);\n    if (functionName && functionName.length) {\n      const functionStart = `${functionName}=function(a)`;\n      const ndx = body.indexOf(functionStart);\n      if (ndx >= 0) {\n        const subBody = body.slice(ndx + functionStart.length);\n        let functionBody = `var ${functionStart}${utils.cutAfterJS(subBody)}`;\n        functionBody = `${extractManipulations(functionBody)};${functionBody};${functionName}(sig);`;\n        functions.push(functionBody);\n      }\n    }\n  };\n  const extractNCode = () => {\n    let functionName = utils.between(body, `&&(b=a.get(\"n\"))&&(b=`, `(b)`);\n    if (functionName.includes('[')) functionName = utils.between(body, `var ${functionName.split('[')[0]}=[`, `]`);\n    if (functionName && functionName.length) {\n      const functionStart = `${functionName}=function(a)`;\n      const ndx = body.indexOf(functionStart);\n      if (ndx >= 0) {\n        const subBody = body.slice(ndx + functionStart.length);\n        const functionBody = `var ${functionStart}${utils.cutAfterJS(subBody)};${functionName}(ncode);`;\n        functions.push(functionBody);\n      }\n    }\n  };\n  extractDecipher();\n  extractNCode();\n  return functions;\n};\n\n/**\n * Apply decipher and n-transform to individual format\n *\n * @param {Object} format\n * @param {vm.Script} decipherScript\n * @param {vm.Script} nTransformScript\n */\nexports.setDownloadURL = (format, decipherScript, nTransformScript) => {\n  const decipher = url => {\n    const args = querystring.parse(url);\n    if (!args.s || !decipherScript) return args.url;\n    const components = new URL(decodeURIComponent(args.url));\n    components.searchParams.set(args.sp ? args.sp : 'signature',\n      decipherScript.runInNewContext({ sig: decodeURIComponent(args.s) }));\n    return components.toString();\n  };\n  const ncode = url => {\n    const components = new URL(decodeURIComponent(url));\n    const n = components.searchParams.get('n');\n    if (!n || !nTransformScript) return url;\n    components.searchParams.set('n', nTransformScript.runInNewContext({ ncode: n }));\n    return components.toString();\n  };\n  const cipher = !format.url;\n  const url = format.url || format.signatureCipher || format.cipher;\n  format.url = cipher ? ncode(decipher(url)) : ncode(url);\n  delete format.signatureCipher;\n  delete format.cipher;\n};\n\n/**\n * Applies decipher and n parameter transforms to all format URL's.\n *\n * @param {Array.<Object>} formats\n * @param {string} html5player\n * @param {Object} options\n */\nexports.decipherFormats = async(formats, html5player, options) => {\n  let decipheredFormats = {};\n  let functions = await exports.getFunctions(html5player, options);\n  const decipherScript = functions.length ? new vm.Script(functions[0]) : null;\n  const nTransformScript = functions.length > 1 ? new vm.Script(functions[1]) : null;\n  formats.forEach(format => {\n    exports.setDownloadURL(format, decipherScript, nTransformScript);\n    decipheredFormats[format.url] = format;\n  });\n  return decipheredFormats;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMveXRkbC1jb3JlL2xpYi9zaWcuanMiLCJtYXBwaW5ncyI6IkFBQUEsb0JBQW9CLG1CQUFPLENBQUMsZ0NBQWE7QUFDekMsY0FBYyxtQkFBTyxDQUFDLDREQUFTO0FBQy9CLGNBQWMsbUJBQU8sQ0FBQyw0REFBUztBQUMvQixXQUFXLG1CQUFPLENBQUMsY0FBSTs7QUFFdkI7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBLGlDQUFpQyxhQUFhLEVBQUU7QUFDaEQ7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGFBQWEsR0FBRywwQkFBMEI7QUFDNUQ7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBLCtCQUErQixhQUFhO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxjQUFjLEVBQUUsMEJBQTBCO0FBQzVFLDBCQUEwQixvQ0FBb0MsRUFBRSxjQUFjLEVBQUUsYUFBYSxNQUFNO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSwyQkFBMkI7QUFDekc7QUFDQSwrQkFBK0IsYUFBYTtBQUM1QztBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsY0FBYyxFQUFFLDJCQUEyQixFQUFFLGFBQWEsUUFBUTtBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFdBQVc7QUFDdEIsV0FBVyxXQUFXO0FBQ3RCO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsaUNBQWlDO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxVQUFVO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0IsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGFnZ3ltXFxPbmVEcml2ZVxcRGVza3RvcFxccHJvamVjdHNcXHlvdXR1YmVfc3VtbWFyaXplclxcbm9kZV9tb2R1bGVzXFx5dGRsLWNvcmVcXGxpYlxcc2lnLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHF1ZXJ5c3RyaW5nID0gcmVxdWlyZSgncXVlcnlzdHJpbmcnKTtcbmNvbnN0IENhY2hlID0gcmVxdWlyZSgnLi9jYWNoZScpO1xuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5jb25zdCB2bSA9IHJlcXVpcmUoJ3ZtJyk7XG5cbi8vIEEgc2hhcmVkIGNhY2hlIHRvIGtlZXAgdHJhY2sgb2YgaHRtbDVwbGF5ZXIganMgZnVuY3Rpb25zLlxuZXhwb3J0cy5jYWNoZSA9IG5ldyBDYWNoZSgpO1xuXG4vKipcbiAqIEV4dHJhY3Qgc2lnbmF0dXJlIGRlY2lwaGVyaW5nIGFuZCBuIHBhcmFtZXRlciB0cmFuc2Zvcm0gZnVuY3Rpb25zIGZyb20gaHRtbDVwbGF5ZXIgZmlsZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gaHRtbDVwbGF5ZXJmaWxlXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybnMge1Byb21pc2U8QXJyYXkuPHN0cmluZz4+fVxuICovXG5leHBvcnRzLmdldEZ1bmN0aW9ucyA9IChodG1sNXBsYXllcmZpbGUsIG9wdGlvbnMpID0+IGV4cG9ydHMuY2FjaGUuZ2V0T3JTZXQoaHRtbDVwbGF5ZXJmaWxlLCBhc3luYygpID0+IHtcbiAgY29uc3QgYm9keSA9IGF3YWl0IHV0aWxzLmV4cG9zZWRNaW5pZ2V0KGh0bWw1cGxheWVyZmlsZSwgb3B0aW9ucykudGV4dCgpO1xuICBjb25zdCBmdW5jdGlvbnMgPSBleHBvcnRzLmV4dHJhY3RGdW5jdGlvbnMoYm9keSk7XG4gIGlmICghZnVuY3Rpb25zIHx8ICFmdW5jdGlvbnMubGVuZ3RoKSB7XG4gICAgdGhyb3cgRXJyb3IoJ0NvdWxkIG5vdCBleHRyYWN0IGZ1bmN0aW9ucycpO1xuICB9XG4gIGV4cG9ydHMuY2FjaGUuc2V0KGh0bWw1cGxheWVyZmlsZSwgZnVuY3Rpb25zKTtcbiAgcmV0dXJuIGZ1bmN0aW9ucztcbn0pO1xuXG4vKipcbiAqIEV4dHJhY3RzIHRoZSBhY3Rpb25zIHRoYXQgc2hvdWxkIGJlIHRha2VuIHRvIGRlY2lwaGVyIGEgc2lnbmF0dXJlXG4gKiBhbmQgdHJhbmZvcm0gdGhlIG4gcGFyYW1ldGVyXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGJvZHlcbiAqIEByZXR1cm5zIHtBcnJheS48c3RyaW5nPn1cbiAqL1xuZXhwb3J0cy5leHRyYWN0RnVuY3Rpb25zID0gYm9keSA9PiB7XG4gIGNvbnN0IGZ1bmN0aW9ucyA9IFtdO1xuICBjb25zdCBleHRyYWN0TWFuaXB1bGF0aW9ucyA9IGNhbGxlciA9PiB7XG4gICAgY29uc3QgZnVuY3Rpb25OYW1lID0gdXRpbHMuYmV0d2VlbihjYWxsZXIsIGBhPWEuc3BsaXQoXCJcIik7YCwgYC5gKTtcbiAgICBpZiAoIWZ1bmN0aW9uTmFtZSkgcmV0dXJuICcnO1xuICAgIGNvbnN0IGZ1bmN0aW9uU3RhcnQgPSBgdmFyICR7ZnVuY3Rpb25OYW1lfT17YDtcbiAgICBjb25zdCBuZHggPSBib2R5LmluZGV4T2YoZnVuY3Rpb25TdGFydCk7XG4gICAgaWYgKG5keCA8IDApIHJldHVybiAnJztcbiAgICBjb25zdCBzdWJCb2R5ID0gYm9keS5zbGljZShuZHggKyBmdW5jdGlvblN0YXJ0Lmxlbmd0aCAtIDEpO1xuICAgIHJldHVybiBgdmFyICR7ZnVuY3Rpb25OYW1lfT0ke3V0aWxzLmN1dEFmdGVySlMoc3ViQm9keSl9YDtcbiAgfTtcbiAgY29uc3QgZXh0cmFjdERlY2lwaGVyID0gKCkgPT4ge1xuICAgIGNvbnN0IGZ1bmN0aW9uTmFtZSA9IHV0aWxzLmJldHdlZW4oYm9keSwgYGEuc2V0KFwiYWxyXCIsXCJ5ZXNcIik7YyYmKGM9YCwgYChkZWNvZGVVUklDYCk7XG4gICAgaWYgKGZ1bmN0aW9uTmFtZSAmJiBmdW5jdGlvbk5hbWUubGVuZ3RoKSB7XG4gICAgICBjb25zdCBmdW5jdGlvblN0YXJ0ID0gYCR7ZnVuY3Rpb25OYW1lfT1mdW5jdGlvbihhKWA7XG4gICAgICBjb25zdCBuZHggPSBib2R5LmluZGV4T2YoZnVuY3Rpb25TdGFydCk7XG4gICAgICBpZiAobmR4ID49IDApIHtcbiAgICAgICAgY29uc3Qgc3ViQm9keSA9IGJvZHkuc2xpY2UobmR4ICsgZnVuY3Rpb25TdGFydC5sZW5ndGgpO1xuICAgICAgICBsZXQgZnVuY3Rpb25Cb2R5ID0gYHZhciAke2Z1bmN0aW9uU3RhcnR9JHt1dGlscy5jdXRBZnRlckpTKHN1YkJvZHkpfWA7XG4gICAgICAgIGZ1bmN0aW9uQm9keSA9IGAke2V4dHJhY3RNYW5pcHVsYXRpb25zKGZ1bmN0aW9uQm9keSl9OyR7ZnVuY3Rpb25Cb2R5fTske2Z1bmN0aW9uTmFtZX0oc2lnKTtgO1xuICAgICAgICBmdW5jdGlvbnMucHVzaChmdW5jdGlvbkJvZHkpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgY29uc3QgZXh0cmFjdE5Db2RlID0gKCkgPT4ge1xuICAgIGxldCBmdW5jdGlvbk5hbWUgPSB1dGlscy5iZXR3ZWVuKGJvZHksIGAmJihiPWEuZ2V0KFwiblwiKSkmJihiPWAsIGAoYilgKTtcbiAgICBpZiAoZnVuY3Rpb25OYW1lLmluY2x1ZGVzKCdbJykpIGZ1bmN0aW9uTmFtZSA9IHV0aWxzLmJldHdlZW4oYm9keSwgYHZhciAke2Z1bmN0aW9uTmFtZS5zcGxpdCgnWycpWzBdfT1bYCwgYF1gKTtcbiAgICBpZiAoZnVuY3Rpb25OYW1lICYmIGZ1bmN0aW9uTmFtZS5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGZ1bmN0aW9uU3RhcnQgPSBgJHtmdW5jdGlvbk5hbWV9PWZ1bmN0aW9uKGEpYDtcbiAgICAgIGNvbnN0IG5keCA9IGJvZHkuaW5kZXhPZihmdW5jdGlvblN0YXJ0KTtcbiAgICAgIGlmIChuZHggPj0gMCkge1xuICAgICAgICBjb25zdCBzdWJCb2R5ID0gYm9keS5zbGljZShuZHggKyBmdW5jdGlvblN0YXJ0Lmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IGZ1bmN0aW9uQm9keSA9IGB2YXIgJHtmdW5jdGlvblN0YXJ0fSR7dXRpbHMuY3V0QWZ0ZXJKUyhzdWJCb2R5KX07JHtmdW5jdGlvbk5hbWV9KG5jb2RlKTtgO1xuICAgICAgICBmdW5jdGlvbnMucHVzaChmdW5jdGlvbkJvZHkpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgZXh0cmFjdERlY2lwaGVyKCk7XG4gIGV4dHJhY3ROQ29kZSgpO1xuICByZXR1cm4gZnVuY3Rpb25zO1xufTtcblxuLyoqXG4gKiBBcHBseSBkZWNpcGhlciBhbmQgbi10cmFuc2Zvcm0gdG8gaW5kaXZpZHVhbCBmb3JtYXRcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZm9ybWF0XG4gKiBAcGFyYW0ge3ZtLlNjcmlwdH0gZGVjaXBoZXJTY3JpcHRcbiAqIEBwYXJhbSB7dm0uU2NyaXB0fSBuVHJhbnNmb3JtU2NyaXB0XG4gKi9cbmV4cG9ydHMuc2V0RG93bmxvYWRVUkwgPSAoZm9ybWF0LCBkZWNpcGhlclNjcmlwdCwgblRyYW5zZm9ybVNjcmlwdCkgPT4ge1xuICBjb25zdCBkZWNpcGhlciA9IHVybCA9PiB7XG4gICAgY29uc3QgYXJncyA9IHF1ZXJ5c3RyaW5nLnBhcnNlKHVybCk7XG4gICAgaWYgKCFhcmdzLnMgfHwgIWRlY2lwaGVyU2NyaXB0KSByZXR1cm4gYXJncy51cmw7XG4gICAgY29uc3QgY29tcG9uZW50cyA9IG5ldyBVUkwoZGVjb2RlVVJJQ29tcG9uZW50KGFyZ3MudXJsKSk7XG4gICAgY29tcG9uZW50cy5zZWFyY2hQYXJhbXMuc2V0KGFyZ3Muc3AgPyBhcmdzLnNwIDogJ3NpZ25hdHVyZScsXG4gICAgICBkZWNpcGhlclNjcmlwdC5ydW5Jbk5ld0NvbnRleHQoeyBzaWc6IGRlY29kZVVSSUNvbXBvbmVudChhcmdzLnMpIH0pKTtcbiAgICByZXR1cm4gY29tcG9uZW50cy50b1N0cmluZygpO1xuICB9O1xuICBjb25zdCBuY29kZSA9IHVybCA9PiB7XG4gICAgY29uc3QgY29tcG9uZW50cyA9IG5ldyBVUkwoZGVjb2RlVVJJQ29tcG9uZW50KHVybCkpO1xuICAgIGNvbnN0IG4gPSBjb21wb25lbnRzLnNlYXJjaFBhcmFtcy5nZXQoJ24nKTtcbiAgICBpZiAoIW4gfHwgIW5UcmFuc2Zvcm1TY3JpcHQpIHJldHVybiB1cmw7XG4gICAgY29tcG9uZW50cy5zZWFyY2hQYXJhbXMuc2V0KCduJywgblRyYW5zZm9ybVNjcmlwdC5ydW5Jbk5ld0NvbnRleHQoeyBuY29kZTogbiB9KSk7XG4gICAgcmV0dXJuIGNvbXBvbmVudHMudG9TdHJpbmcoKTtcbiAgfTtcbiAgY29uc3QgY2lwaGVyID0gIWZvcm1hdC51cmw7XG4gIGNvbnN0IHVybCA9IGZvcm1hdC51cmwgfHwgZm9ybWF0LnNpZ25hdHVyZUNpcGhlciB8fCBmb3JtYXQuY2lwaGVyO1xuICBmb3JtYXQudXJsID0gY2lwaGVyID8gbmNvZGUoZGVjaXBoZXIodXJsKSkgOiBuY29kZSh1cmwpO1xuICBkZWxldGUgZm9ybWF0LnNpZ25hdHVyZUNpcGhlcjtcbiAgZGVsZXRlIGZvcm1hdC5jaXBoZXI7XG59O1xuXG4vKipcbiAqIEFwcGxpZXMgZGVjaXBoZXIgYW5kIG4gcGFyYW1ldGVyIHRyYW5zZm9ybXMgdG8gYWxsIGZvcm1hdCBVUkwncy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5LjxPYmplY3Q+fSBmb3JtYXRzXG4gKiBAcGFyYW0ge3N0cmluZ30gaHRtbDVwbGF5ZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKi9cbmV4cG9ydHMuZGVjaXBoZXJGb3JtYXRzID0gYXN5bmMoZm9ybWF0cywgaHRtbDVwbGF5ZXIsIG9wdGlvbnMpID0+IHtcbiAgbGV0IGRlY2lwaGVyZWRGb3JtYXRzID0ge307XG4gIGxldCBmdW5jdGlvbnMgPSBhd2FpdCBleHBvcnRzLmdldEZ1bmN0aW9ucyhodG1sNXBsYXllciwgb3B0aW9ucyk7XG4gIGNvbnN0IGRlY2lwaGVyU2NyaXB0ID0gZnVuY3Rpb25zLmxlbmd0aCA/IG5ldyB2bS5TY3JpcHQoZnVuY3Rpb25zWzBdKSA6IG51bGw7XG4gIGNvbnN0IG5UcmFuc2Zvcm1TY3JpcHQgPSBmdW5jdGlvbnMubGVuZ3RoID4gMSA/IG5ldyB2bS5TY3JpcHQoZnVuY3Rpb25zWzFdKSA6IG51bGw7XG4gIGZvcm1hdHMuZm9yRWFjaChmb3JtYXQgPT4ge1xuICAgIGV4cG9ydHMuc2V0RG93bmxvYWRVUkwoZm9ybWF0LCBkZWNpcGhlclNjcmlwdCwgblRyYW5zZm9ybVNjcmlwdCk7XG4gICAgZGVjaXBoZXJlZEZvcm1hdHNbZm9ybWF0LnVybF0gPSBmb3JtYXQ7XG4gIH0pO1xuICByZXR1cm4gZGVjaXBoZXJlZEZvcm1hdHM7XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ytdl-core/lib/sig.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ytdl-core/lib/url-utils.js":
/*!*************************************************!*\
  !*** ./node_modules/ytdl-core/lib/url-utils.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/**\n * Get video ID.\n *\n * There are a few type of video URL formats.\n *  - https://www.youtube.com/watch?v=VIDEO_ID\n *  - https://m.youtube.com/watch?v=VIDEO_ID\n *  - https://youtu.be/VIDEO_ID\n *  - https://www.youtube.com/v/VIDEO_ID\n *  - https://www.youtube.com/embed/VIDEO_ID\n *  - https://music.youtube.com/watch?v=VIDEO_ID\n *  - https://gaming.youtube.com/watch?v=VIDEO_ID\n *\n * @param {string} link\n * @return {string}\n * @throws {Error} If unable to find a id\n * @throws {TypeError} If videoid doesn't match specs\n */\nconst validQueryDomains = new Set([\n  'youtube.com',\n  'www.youtube.com',\n  'm.youtube.com',\n  'music.youtube.com',\n  'gaming.youtube.com',\n]);\nconst validPathDomains = /^https?:\\/\\/(youtu\\.be\\/|(www\\.)?youtube\\.com\\/(embed|v|shorts)\\/)/;\nexports.getURLVideoID = link => {\n  const parsed = new URL(link.trim());\n  let id = parsed.searchParams.get('v');\n  if (validPathDomains.test(link.trim()) && !id) {\n    const paths = parsed.pathname.split('/');\n    id = parsed.host === 'youtu.be' ? paths[1] : paths[2];\n  } else if (parsed.hostname && !validQueryDomains.has(parsed.hostname)) {\n    throw Error('Not a YouTube domain');\n  }\n  if (!id) {\n    throw Error(`No video id found: \"${link}\"`);\n  }\n  id = id.substring(0, 11);\n  if (!exports.validateID(id)) {\n    throw TypeError(`Video id (${id}) does not match expected ` +\n      `format (${idRegex.toString()})`);\n  }\n  return id;\n};\n\n\n/**\n * Gets video ID either from a url or by checking if the given string\n * matches the video ID format.\n *\n * @param {string} str\n * @returns {string}\n * @throws {Error} If unable to find a id\n * @throws {TypeError} If videoid doesn't match specs\n */\nconst urlRegex = /^https?:\\/\\//;\nexports.getVideoID = str => {\n  if (exports.validateID(str)) {\n    return str;\n  } else if (urlRegex.test(str.trim())) {\n    return exports.getURLVideoID(str);\n  } else {\n    throw Error(`No video id found: ${str}`);\n  }\n};\n\n\n/**\n * Returns true if given id satifies YouTube's id format.\n *\n * @param {string} id\n * @return {boolean}\n */\nconst idRegex = /^[a-zA-Z0-9-_]{11}$/;\nexports.validateID = id => idRegex.test(id.trim());\n\n\n/**\n * Checks wether the input string includes a valid id.\n *\n * @param {string} string\n * @returns {boolean}\n */\nexports.validateURL = string => {\n  try {\n    exports.getURLVideoID(string);\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMveXRkbC1jb3JlL2xpYi91cmwtdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWixZQUFZLE9BQU87QUFDbkIsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxLQUFLO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxHQUFHO0FBQ3BDLGlCQUFpQixtQkFBbUI7QUFDcEM7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2IsWUFBWSxPQUFPO0FBQ25CLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0osc0NBQXNDLElBQUk7QUFDMUM7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBLGdDQUFnQyxHQUFHO0FBQ25DLGtCQUFrQjs7O0FBR2xCO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxhZ2d5bVxcT25lRHJpdmVcXERlc2t0b3BcXHByb2plY3RzXFx5b3V0dWJlX3N1bW1hcml6ZXJcXG5vZGVfbW9kdWxlc1xceXRkbC1jb3JlXFxsaWJcXHVybC11dGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEdldCB2aWRlbyBJRC5cbiAqXG4gKiBUaGVyZSBhcmUgYSBmZXcgdHlwZSBvZiB2aWRlbyBVUkwgZm9ybWF0cy5cbiAqICAtIGh0dHBzOi8vd3d3LnlvdXR1YmUuY29tL3dhdGNoP3Y9VklERU9fSURcbiAqICAtIGh0dHBzOi8vbS55b3V0dWJlLmNvbS93YXRjaD92PVZJREVPX0lEXG4gKiAgLSBodHRwczovL3lvdXR1LmJlL1ZJREVPX0lEXG4gKiAgLSBodHRwczovL3d3dy55b3V0dWJlLmNvbS92L1ZJREVPX0lEXG4gKiAgLSBodHRwczovL3d3dy55b3V0dWJlLmNvbS9lbWJlZC9WSURFT19JRFxuICogIC0gaHR0cHM6Ly9tdXNpYy55b3V0dWJlLmNvbS93YXRjaD92PVZJREVPX0lEXG4gKiAgLSBodHRwczovL2dhbWluZy55b3V0dWJlLmNvbS93YXRjaD92PVZJREVPX0lEXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGxpbmtcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB1bmFibGUgdG8gZmluZCBhIGlkXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIHZpZGVvaWQgZG9lc24ndCBtYXRjaCBzcGVjc1xuICovXG5jb25zdCB2YWxpZFF1ZXJ5RG9tYWlucyA9IG5ldyBTZXQoW1xuICAneW91dHViZS5jb20nLFxuICAnd3d3LnlvdXR1YmUuY29tJyxcbiAgJ20ueW91dHViZS5jb20nLFxuICAnbXVzaWMueW91dHViZS5jb20nLFxuICAnZ2FtaW5nLnlvdXR1YmUuY29tJyxcbl0pO1xuY29uc3QgdmFsaWRQYXRoRG9tYWlucyA9IC9eaHR0cHM/OlxcL1xcLyh5b3V0dVxcLmJlXFwvfCh3d3dcXC4pP3lvdXR1YmVcXC5jb21cXC8oZW1iZWR8dnxzaG9ydHMpXFwvKS87XG5leHBvcnRzLmdldFVSTFZpZGVvSUQgPSBsaW5rID0+IHtcbiAgY29uc3QgcGFyc2VkID0gbmV3IFVSTChsaW5rLnRyaW0oKSk7XG4gIGxldCBpZCA9IHBhcnNlZC5zZWFyY2hQYXJhbXMuZ2V0KCd2Jyk7XG4gIGlmICh2YWxpZFBhdGhEb21haW5zLnRlc3QobGluay50cmltKCkpICYmICFpZCkge1xuICAgIGNvbnN0IHBhdGhzID0gcGFyc2VkLnBhdGhuYW1lLnNwbGl0KCcvJyk7XG4gICAgaWQgPSBwYXJzZWQuaG9zdCA9PT0gJ3lvdXR1LmJlJyA/IHBhdGhzWzFdIDogcGF0aHNbMl07XG4gIH0gZWxzZSBpZiAocGFyc2VkLmhvc3RuYW1lICYmICF2YWxpZFF1ZXJ5RG9tYWlucy5oYXMocGFyc2VkLmhvc3RuYW1lKSkge1xuICAgIHRocm93IEVycm9yKCdOb3QgYSBZb3VUdWJlIGRvbWFpbicpO1xuICB9XG4gIGlmICghaWQpIHtcbiAgICB0aHJvdyBFcnJvcihgTm8gdmlkZW8gaWQgZm91bmQ6IFwiJHtsaW5rfVwiYCk7XG4gIH1cbiAgaWQgPSBpZC5zdWJzdHJpbmcoMCwgMTEpO1xuICBpZiAoIWV4cG9ydHMudmFsaWRhdGVJRChpZCkpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoYFZpZGVvIGlkICgke2lkfSkgZG9lcyBub3QgbWF0Y2ggZXhwZWN0ZWQgYCArXG4gICAgICBgZm9ybWF0ICgke2lkUmVnZXgudG9TdHJpbmcoKX0pYCk7XG4gIH1cbiAgcmV0dXJuIGlkO1xufTtcblxuXG4vKipcbiAqIEdldHMgdmlkZW8gSUQgZWl0aGVyIGZyb20gYSB1cmwgb3IgYnkgY2hlY2tpbmcgaWYgdGhlIGdpdmVuIHN0cmluZ1xuICogbWF0Y2hlcyB0aGUgdmlkZW8gSUQgZm9ybWF0LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdW5hYmxlIHRvIGZpbmQgYSBpZFxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiB2aWRlb2lkIGRvZXNuJ3QgbWF0Y2ggc3BlY3NcbiAqL1xuY29uc3QgdXJsUmVnZXggPSAvXmh0dHBzPzpcXC9cXC8vO1xuZXhwb3J0cy5nZXRWaWRlb0lEID0gc3RyID0+IHtcbiAgaWYgKGV4cG9ydHMudmFsaWRhdGVJRChzdHIpKSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfSBlbHNlIGlmICh1cmxSZWdleC50ZXN0KHN0ci50cmltKCkpKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuZ2V0VVJMVmlkZW9JRChzdHIpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IEVycm9yKGBObyB2aWRlbyBpZCBmb3VuZDogJHtzdHJ9YCk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgZ2l2ZW4gaWQgc2F0aWZpZXMgWW91VHViZSdzIGlkIGZvcm1hdC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gaWRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmNvbnN0IGlkUmVnZXggPSAvXlthLXpBLVowLTktX117MTF9JC87XG5leHBvcnRzLnZhbGlkYXRlSUQgPSBpZCA9PiBpZFJlZ2V4LnRlc3QoaWQudHJpbSgpKTtcblxuXG4vKipcbiAqIENoZWNrcyB3ZXRoZXIgdGhlIGlucHV0IHN0cmluZyBpbmNsdWRlcyBhIHZhbGlkIGlkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5leHBvcnRzLnZhbGlkYXRlVVJMID0gc3RyaW5nID0+IHtcbiAgdHJ5IHtcbiAgICBleHBvcnRzLmdldFVSTFZpZGVvSUQoc3RyaW5nKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ytdl-core/lib/url-utils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ytdl-core/lib/utils.js":
/*!*********************************************!*\
  !*** ./node_modules/ytdl-core/lib/utils.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("const miniget = __webpack_require__(/*! miniget */ \"(rsc)/./node_modules/miniget/dist/index.js\");\n\n\n/**\n * Extract string inbetween another.\n *\n * @param {string} haystack\n * @param {string} left\n * @param {string} right\n * @returns {string}\n */\nexports.between = (haystack, left, right) => {\n  let pos;\n  if (left instanceof RegExp) {\n    const match = haystack.match(left);\n    if (!match) { return ''; }\n    pos = match.index + match[0].length;\n  } else {\n    pos = haystack.indexOf(left);\n    if (pos === -1) { return ''; }\n    pos += left.length;\n  }\n  haystack = haystack.slice(pos);\n  pos = haystack.indexOf(right);\n  if (pos === -1) { return ''; }\n  haystack = haystack.slice(0, pos);\n  return haystack;\n};\n\n\n/**\n * Get a number from an abbreviated number string.\n *\n * @param {string} string\n * @returns {number}\n */\nexports.parseAbbreviatedNumber = string => {\n  const match = string\n    .replace(',', '.')\n    .replace(' ', '')\n    .match(/([\\d,.]+)([MK]?)/);\n  if (match) {\n    let [, num, multi] = match;\n    num = parseFloat(num);\n    return Math.round(multi === 'M' ? num * 1000000 :\n      multi === 'K' ? num * 1000 : num);\n  }\n  return null;\n};\n\n/**\n * Escape sequences for cutAfterJS\n * @param {string} start the character string the escape sequence\n * @param {string} end the character string to stop the escape seequence\n * @param {undefined|Regex} startPrefix a regex to check against the preceding 10 characters\n */\nconst ESCAPING_SEQUENZES = [\n  // Strings\n  { start: '\"', end: '\"' },\n  { start: \"'\", end: \"'\" },\n  { start: '`', end: '`' },\n  // RegeEx\n  { start: '/', end: '/', startPrefix: /(^|[[{:;,/])\\s?$/ },\n];\n\n/**\n * Match begin and end braces of input JS, return only JS\n *\n * @param {string} mixedJson\n * @returns {string}\n*/\nexports.cutAfterJS = mixedJson => {\n  // Define the general open and closing tag\n  let open, close;\n  if (mixedJson[0] === '[') {\n    open = '[';\n    close = ']';\n  } else if (mixedJson[0] === '{') {\n    open = '{';\n    close = '}';\n  }\n\n  if (!open) {\n    throw new Error(`Can't cut unsupported JSON (need to begin with [ or { ) but got: ${mixedJson[0]}`);\n  }\n\n  // States if the loop is currently inside an escaped js object\n  let isEscapedObject = null;\n\n  // States if the current character is treated as escaped or not\n  let isEscaped = false;\n\n  // Current open brackets to be closed\n  let counter = 0;\n\n  let i;\n  // Go through all characters from the start\n  for (i = 0; i < mixedJson.length; i++) {\n    // End of current escaped object\n    if (!isEscaped && isEscapedObject !== null && mixedJson[i] === isEscapedObject.end) {\n      isEscapedObject = null;\n      continue;\n    // Might be the start of a new escaped object\n    } else if (!isEscaped && isEscapedObject === null) {\n      for (const escaped of ESCAPING_SEQUENZES) {\n        if (mixedJson[i] !== escaped.start) continue;\n        // Test startPrefix against last 10 characters\n        if (!escaped.startPrefix || mixedJson.substring(i - 10, i).match(escaped.startPrefix)) {\n          isEscapedObject = escaped;\n          break;\n        }\n      }\n      // Continue if we found a new escaped object\n      if (isEscapedObject !== null) {\n        continue;\n      }\n    }\n\n    // Toggle the isEscaped boolean for every backslash\n    // Reset for every regular character\n    isEscaped = mixedJson[i] === '\\\\' && !isEscaped;\n\n    if (isEscapedObject !== null) continue;\n\n    if (mixedJson[i] === open) {\n      counter++;\n    } else if (mixedJson[i] === close) {\n      counter--;\n    }\n\n    // All brackets have been closed, thus end of JSON is reached\n    if (counter === 0) {\n      // Return the cut JSON\n      return mixedJson.substring(0, i + 1);\n    }\n  }\n\n  // We ran through the whole string and ended up with an unclosed bracket\n  throw Error(\"Can't cut unsupported JSON (no matching closing bracket found)\");\n};\n\n\n/**\n * Checks if there is a playability error.\n *\n * @param {Object} player_response\n * @param {Array.<string>} statuses\n * @param {Error} ErrorType\n * @returns {!Error}\n */\nexports.playError = (player_response, statuses, ErrorType = Error) => {\n  let playability = player_response && player_response.playabilityStatus;\n  if (playability && statuses.includes(playability.status)) {\n    return new ErrorType(playability.reason || (playability.messages && playability.messages[0]));\n  }\n  return null;\n};\n\n/**\n * Does a miniget request and calls options.requestCallback if present\n *\n * @param {string} url the request url\n * @param {Object} options an object with optional requestOptions and requestCallback parameters\n * @param {Object} requestOptionsOverwrite overwrite of options.requestOptions\n * @returns {miniget.Stream}\n */\nexports.exposedMiniget = (url, options = {}, requestOptionsOverwrite) => {\n  const req = miniget(url, requestOptionsOverwrite || options.requestOptions);\n  if (typeof options.requestCallback === 'function') options.requestCallback(req);\n  return req;\n};\n\n/**\n * Temporary helper to help deprecating a few properties.\n *\n * @param {Object} obj\n * @param {string} prop\n * @param {Object} value\n * @param {string} oldPath\n * @param {string} newPath\n */\nexports.deprecate = (obj, prop, value, oldPath, newPath) => {\n  Object.defineProperty(obj, prop, {\n    get: () => {\n      console.warn(`\\`${oldPath}\\` will be removed in a near future release, ` +\n        `use \\`${newPath}\\` instead.`);\n      return value;\n    },\n  });\n};\n\n\n// Check for updates.\nconst pkg = __webpack_require__(/*! ../package.json */ \"(rsc)/./node_modules/ytdl-core/package.json\");\nconst UPDATE_INTERVAL = 1000 * 60 * 60 * 12;\nexports.lastUpdateCheck = 0;\nexports.checkForUpdates = () => {\n  if (!process.env.YTDL_NO_UPDATE && !pkg.version.startsWith('0.0.0-') &&\n    Date.now() - exports.lastUpdateCheck >= UPDATE_INTERVAL) {\n    exports.lastUpdateCheck = Date.now();\n    return miniget('https://api.github.com/repos/fent/node-ytdl-core/releases/latest', {\n      headers: { 'User-Agent': 'ytdl-core' },\n    }).text().then(response => {\n      if (JSON.parse(response).tag_name !== `v${pkg.version}`) {\n        console.warn('\\x1b[33mWARNING:\\x1B[0m ytdl-core is out of date! Update with \"npm install ytdl-core@latest\".');\n      }\n    }, err => {\n      console.warn('Error checking for updates:', err.message);\n      console.warn('You can disable this check by setting the `YTDL_NO_UPDATE` env variable.');\n    });\n  }\n  return null;\n};\n\n\n/**\n * Gets random IPv6 Address from a block\n *\n * @param {string} ip the IPv6 block in CIDR-Notation\n * @returns {string}\n */\nexports.getRandomIPv6 = ip => {\n  // Start with a fast Regex-Check\n  if (!isIPv6(ip)) throw Error('Invalid IPv6 format');\n  // Start by splitting and normalizing addr and mask\n  const [rawAddr, rawMask] = ip.split('/');\n  let base10Mask = parseInt(rawMask);\n  if (!base10Mask || base10Mask > 128 || base10Mask < 24) throw Error('Invalid IPv6 subnet');\n  const base10addr = normalizeIP(rawAddr);\n  // Get random addr to pad with\n  // using Math.random since we're not requiring high level of randomness\n  const randomAddr = new Array(8).fill(1).map(() => Math.floor(Math.random() * 0xffff));\n\n  // Merge base10addr with randomAddr\n  const mergedAddr = randomAddr.map((randomItem, idx) => {\n    // Calculate the amount of static bits\n    const staticBits = Math.min(base10Mask, 16);\n    // Adjust the bitmask with the staticBits\n    base10Mask -= staticBits;\n    // Calculate the bitmask\n    // lsb makes the calculation way more complicated\n    const mask = 0xffff - ((2 ** (16 - staticBits)) - 1);\n    // Combine base10addr and random\n    return (base10addr[idx] & mask) + (randomItem & (mask ^ 0xffff));\n  });\n  // Return new addr\n  return mergedAddr.map(x => x.toString('16')).join(':');\n};\n\n\n// eslint-disable-next-line max-len\nconst IPV6_REGEX = /^(([0-9a-f]{1,4}:)(:[0-9a-f]{1,4}){1,6}|([0-9a-f]{1,4}:){1,2}(:[0-9a-f]{1,4}){1,5}|([0-9a-f]{1,4}:){1,3}(:[0-9a-f]{1,4}){1,4}|([0-9a-f]{1,4}:){1,4}(:[0-9a-f]{1,4}){1,3}|([0-9a-f]{1,4}:){1,5}(:[0-9a-f]{1,4}){1,2}|([0-9a-f]{1,4}:){1,6}(:[0-9a-f]{1,4})|([0-9a-f]{1,4}:){1,7}(([0-9a-f]{1,4})|:))\\/(1[0-1]\\d|12[0-8]|\\d{1,2})$/;\n/**\n * Quick check for a valid IPv6\n * The Regex only accepts a subset of all IPv6 Addresses\n *\n * @param {string} ip the IPv6 block in CIDR-Notation to test\n * @returns {boolean} true if valid\n */\nconst isIPv6 = exports.isIPv6 = ip => IPV6_REGEX.test(ip);\n\n\n/**\n * Normalise an IP Address\n *\n * @param {string} ip the IPv6 Addr\n * @returns {number[]} the 8 parts of the IPv6 as Integers\n */\nconst normalizeIP = exports.normalizeIP = ip => {\n  // Split by fill position\n  const parts = ip.split('::').map(x => x.split(':'));\n  // Normalize start and end\n  const partStart = parts[0] || [];\n  const partEnd = parts[1] || [];\n  partEnd.reverse();\n  // Placeholder for full ip\n  const fullIP = new Array(8).fill(0);\n  // Fill in start and end parts\n  for (let i = 0; i < Math.min(partStart.length, 8); i++) {\n    fullIP[i] = parseInt(partStart[i], 16) || 0;\n  }\n  for (let i = 0; i < Math.min(partEnd.length, 8); i++) {\n    fullIP[7 - i] = parseInt(partEnd[i], 16) || 0;\n  }\n  return fullIP;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMveXRkbC1jb3JlL2xpYi91dGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxnQkFBZ0IsbUJBQU8sQ0FBQywyREFBUzs7O0FBR2pDO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxJQUFJO0FBQ0o7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLGlCQUFpQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxJQUFJLHNCQUFzQjtBQUMxQixJQUFJLHNCQUFzQjtBQUMxQixJQUFJLHNCQUFzQjtBQUMxQjtBQUNBLElBQUksMENBQTBDLEVBQUUsV0FBVztBQUMzRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDRCQUE0QjtBQUNoQyxhQUFhO0FBQ2IsY0FBYztBQUNkOztBQUVBO0FBQ0EsMkVBQTJFLGFBQWEsYUFBYTtBQUNyRzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxzQkFBc0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLGdCQUFnQjtBQUMzQixXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQSxzQkFBc0IscUJBQXFCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7O0FBR0E7QUFDQSxZQUFZLG1CQUFPLENBQUMsb0VBQWlCO0FBQ3JDO0FBQ0EsdUJBQXVCO0FBQ3ZCLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsSUFBSSx1QkFBdUI7QUFDM0I7QUFDQSxpQkFBaUIsMkJBQTJCO0FBQzVDLEtBQUs7QUFDTCxnREFBZ0QsWUFBWTtBQUM1RDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLGdDQUFnQyxJQUFJLGFBQWEsSUFBSSxFQUFFLElBQUksV0FBVyxJQUFJLEdBQUcsSUFBSSxXQUFXLElBQUksRUFBRSxJQUFJLFdBQVcsSUFBSSxHQUFHLElBQUksV0FBVyxJQUFJLEVBQUUsSUFBSSxXQUFXLElBQUksR0FBRyxJQUFJLFdBQVcsSUFBSSxFQUFFLElBQUksV0FBVyxJQUFJLEdBQUcsSUFBSSxXQUFXLElBQUksRUFBRSxJQUFJLFdBQVcsSUFBSSxHQUFHLElBQUksV0FBVyxJQUFJLFlBQVksSUFBSSxHQUFHLElBQUksV0FBVyxJQUFJLDRCQUE0QixJQUFJO0FBQ2xWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsU0FBUztBQUN0QjtBQUNBLGVBQWUsY0FBYzs7O0FBRzdCO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFVBQVU7QUFDdkI7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtQ0FBbUM7QUFDckQ7QUFDQTtBQUNBLGtCQUFrQixpQ0FBaUM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcYWdneW1cXE9uZURyaXZlXFxEZXNrdG9wXFxwcm9qZWN0c1xceW91dHViZV9zdW1tYXJpemVyXFxub2RlX21vZHVsZXNcXHl0ZGwtY29yZVxcbGliXFx1dGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBtaW5pZ2V0ID0gcmVxdWlyZSgnbWluaWdldCcpO1xuXG5cbi8qKlxuICogRXh0cmFjdCBzdHJpbmcgaW5iZXR3ZWVuIGFub3RoZXIuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGhheXN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30gbGVmdFxuICogQHBhcmFtIHtzdHJpbmd9IHJpZ2h0XG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5leHBvcnRzLmJldHdlZW4gPSAoaGF5c3RhY2ssIGxlZnQsIHJpZ2h0KSA9PiB7XG4gIGxldCBwb3M7XG4gIGlmIChsZWZ0IGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgY29uc3QgbWF0Y2ggPSBoYXlzdGFjay5tYXRjaChsZWZ0KTtcbiAgICBpZiAoIW1hdGNoKSB7IHJldHVybiAnJzsgfVxuICAgIHBvcyA9IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICB9IGVsc2Uge1xuICAgIHBvcyA9IGhheXN0YWNrLmluZGV4T2YobGVmdCk7XG4gICAgaWYgKHBvcyA9PT0gLTEpIHsgcmV0dXJuICcnOyB9XG4gICAgcG9zICs9IGxlZnQubGVuZ3RoO1xuICB9XG4gIGhheXN0YWNrID0gaGF5c3RhY2suc2xpY2UocG9zKTtcbiAgcG9zID0gaGF5c3RhY2suaW5kZXhPZihyaWdodCk7XG4gIGlmIChwb3MgPT09IC0xKSB7IHJldHVybiAnJzsgfVxuICBoYXlzdGFjayA9IGhheXN0YWNrLnNsaWNlKDAsIHBvcyk7XG4gIHJldHVybiBoYXlzdGFjaztcbn07XG5cblxuLyoqXG4gKiBHZXQgYSBudW1iZXIgZnJvbSBhbiBhYmJyZXZpYXRlZCBudW1iZXIgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydHMucGFyc2VBYmJyZXZpYXRlZE51bWJlciA9IHN0cmluZyA9PiB7XG4gIGNvbnN0IG1hdGNoID0gc3RyaW5nXG4gICAgLnJlcGxhY2UoJywnLCAnLicpXG4gICAgLnJlcGxhY2UoJyAnLCAnJylcbiAgICAubWF0Y2goLyhbXFxkLC5dKykoW01LXT8pLyk7XG4gIGlmIChtYXRjaCkge1xuICAgIGxldCBbLCBudW0sIG11bHRpXSA9IG1hdGNoO1xuICAgIG51bSA9IHBhcnNlRmxvYXQobnVtKTtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtdWx0aSA9PT0gJ00nID8gbnVtICogMTAwMDAwMCA6XG4gICAgICBtdWx0aSA9PT0gJ0snID8gbnVtICogMTAwMCA6IG51bSk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIEVzY2FwZSBzZXF1ZW5jZXMgZm9yIGN1dEFmdGVySlNcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdGFydCB0aGUgY2hhcmFjdGVyIHN0cmluZyB0aGUgZXNjYXBlIHNlcXVlbmNlXG4gKiBAcGFyYW0ge3N0cmluZ30gZW5kIHRoZSBjaGFyYWN0ZXIgc3RyaW5nIHRvIHN0b3AgdGhlIGVzY2FwZSBzZWVxdWVuY2VcbiAqIEBwYXJhbSB7dW5kZWZpbmVkfFJlZ2V4fSBzdGFydFByZWZpeCBhIHJlZ2V4IHRvIGNoZWNrIGFnYWluc3QgdGhlIHByZWNlZGluZyAxMCBjaGFyYWN0ZXJzXG4gKi9cbmNvbnN0IEVTQ0FQSU5HX1NFUVVFTlpFUyA9IFtcbiAgLy8gU3RyaW5nc1xuICB7IHN0YXJ0OiAnXCInLCBlbmQ6ICdcIicgfSxcbiAgeyBzdGFydDogXCInXCIsIGVuZDogXCInXCIgfSxcbiAgeyBzdGFydDogJ2AnLCBlbmQ6ICdgJyB9LFxuICAvLyBSZWdlRXhcbiAgeyBzdGFydDogJy8nLCBlbmQ6ICcvJywgc3RhcnRQcmVmaXg6IC8oXnxbW3s6OywvXSlcXHM/JC8gfSxcbl07XG5cbi8qKlxuICogTWF0Y2ggYmVnaW4gYW5kIGVuZCBicmFjZXMgb2YgaW5wdXQgSlMsIHJldHVybiBvbmx5IEpTXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1peGVkSnNvblxuICogQHJldHVybnMge3N0cmluZ31cbiovXG5leHBvcnRzLmN1dEFmdGVySlMgPSBtaXhlZEpzb24gPT4ge1xuICAvLyBEZWZpbmUgdGhlIGdlbmVyYWwgb3BlbiBhbmQgY2xvc2luZyB0YWdcbiAgbGV0IG9wZW4sIGNsb3NlO1xuICBpZiAobWl4ZWRKc29uWzBdID09PSAnWycpIHtcbiAgICBvcGVuID0gJ1snO1xuICAgIGNsb3NlID0gJ10nO1xuICB9IGVsc2UgaWYgKG1peGVkSnNvblswXSA9PT0gJ3snKSB7XG4gICAgb3BlbiA9ICd7JztcbiAgICBjbG9zZSA9ICd9JztcbiAgfVxuXG4gIGlmICghb3Blbikge1xuICAgIHRocm93IG5ldyBFcnJvcihgQ2FuJ3QgY3V0IHVuc3VwcG9ydGVkIEpTT04gKG5lZWQgdG8gYmVnaW4gd2l0aCBbIG9yIHsgKSBidXQgZ290OiAke21peGVkSnNvblswXX1gKTtcbiAgfVxuXG4gIC8vIFN0YXRlcyBpZiB0aGUgbG9vcCBpcyBjdXJyZW50bHkgaW5zaWRlIGFuIGVzY2FwZWQganMgb2JqZWN0XG4gIGxldCBpc0VzY2FwZWRPYmplY3QgPSBudWxsO1xuXG4gIC8vIFN0YXRlcyBpZiB0aGUgY3VycmVudCBjaGFyYWN0ZXIgaXMgdHJlYXRlZCBhcyBlc2NhcGVkIG9yIG5vdFxuICBsZXQgaXNFc2NhcGVkID0gZmFsc2U7XG5cbiAgLy8gQ3VycmVudCBvcGVuIGJyYWNrZXRzIHRvIGJlIGNsb3NlZFxuICBsZXQgY291bnRlciA9IDA7XG5cbiAgbGV0IGk7XG4gIC8vIEdvIHRocm91Z2ggYWxsIGNoYXJhY3RlcnMgZnJvbSB0aGUgc3RhcnRcbiAgZm9yIChpID0gMDsgaSA8IG1peGVkSnNvbi5sZW5ndGg7IGkrKykge1xuICAgIC8vIEVuZCBvZiBjdXJyZW50IGVzY2FwZWQgb2JqZWN0XG4gICAgaWYgKCFpc0VzY2FwZWQgJiYgaXNFc2NhcGVkT2JqZWN0ICE9PSBudWxsICYmIG1peGVkSnNvbltpXSA9PT0gaXNFc2NhcGVkT2JqZWN0LmVuZCkge1xuICAgICAgaXNFc2NhcGVkT2JqZWN0ID0gbnVsbDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIC8vIE1pZ2h0IGJlIHRoZSBzdGFydCBvZiBhIG5ldyBlc2NhcGVkIG9iamVjdFxuICAgIH0gZWxzZSBpZiAoIWlzRXNjYXBlZCAmJiBpc0VzY2FwZWRPYmplY3QgPT09IG51bGwpIHtcbiAgICAgIGZvciAoY29uc3QgZXNjYXBlZCBvZiBFU0NBUElOR19TRVFVRU5aRVMpIHtcbiAgICAgICAgaWYgKG1peGVkSnNvbltpXSAhPT0gZXNjYXBlZC5zdGFydCkgY29udGludWU7XG4gICAgICAgIC8vIFRlc3Qgc3RhcnRQcmVmaXggYWdhaW5zdCBsYXN0IDEwIGNoYXJhY3RlcnNcbiAgICAgICAgaWYgKCFlc2NhcGVkLnN0YXJ0UHJlZml4IHx8IG1peGVkSnNvbi5zdWJzdHJpbmcoaSAtIDEwLCBpKS5tYXRjaChlc2NhcGVkLnN0YXJ0UHJlZml4KSkge1xuICAgICAgICAgIGlzRXNjYXBlZE9iamVjdCA9IGVzY2FwZWQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIENvbnRpbnVlIGlmIHdlIGZvdW5kIGEgbmV3IGVzY2FwZWQgb2JqZWN0XG4gICAgICBpZiAoaXNFc2NhcGVkT2JqZWN0ICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRvZ2dsZSB0aGUgaXNFc2NhcGVkIGJvb2xlYW4gZm9yIGV2ZXJ5IGJhY2tzbGFzaFxuICAgIC8vIFJlc2V0IGZvciBldmVyeSByZWd1bGFyIGNoYXJhY3RlclxuICAgIGlzRXNjYXBlZCA9IG1peGVkSnNvbltpXSA9PT0gJ1xcXFwnICYmICFpc0VzY2FwZWQ7XG5cbiAgICBpZiAoaXNFc2NhcGVkT2JqZWN0ICE9PSBudWxsKSBjb250aW51ZTtcblxuICAgIGlmIChtaXhlZEpzb25baV0gPT09IG9wZW4pIHtcbiAgICAgIGNvdW50ZXIrKztcbiAgICB9IGVsc2UgaWYgKG1peGVkSnNvbltpXSA9PT0gY2xvc2UpIHtcbiAgICAgIGNvdW50ZXItLTtcbiAgICB9XG5cbiAgICAvLyBBbGwgYnJhY2tldHMgaGF2ZSBiZWVuIGNsb3NlZCwgdGh1cyBlbmQgb2YgSlNPTiBpcyByZWFjaGVkXG4gICAgaWYgKGNvdW50ZXIgPT09IDApIHtcbiAgICAgIC8vIFJldHVybiB0aGUgY3V0IEpTT05cbiAgICAgIHJldHVybiBtaXhlZEpzb24uc3Vic3RyaW5nKDAsIGkgKyAxKTtcbiAgICB9XG4gIH1cblxuICAvLyBXZSByYW4gdGhyb3VnaCB0aGUgd2hvbGUgc3RyaW5nIGFuZCBlbmRlZCB1cCB3aXRoIGFuIHVuY2xvc2VkIGJyYWNrZXRcbiAgdGhyb3cgRXJyb3IoXCJDYW4ndCBjdXQgdW5zdXBwb3J0ZWQgSlNPTiAobm8gbWF0Y2hpbmcgY2xvc2luZyBicmFja2V0IGZvdW5kKVwiKTtcbn07XG5cblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlcmUgaXMgYSBwbGF5YWJpbGl0eSBlcnJvci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGxheWVyX3Jlc3BvbnNlXG4gKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBzdGF0dXNlc1xuICogQHBhcmFtIHtFcnJvcn0gRXJyb3JUeXBlXG4gKiBAcmV0dXJucyB7IUVycm9yfVxuICovXG5leHBvcnRzLnBsYXlFcnJvciA9IChwbGF5ZXJfcmVzcG9uc2UsIHN0YXR1c2VzLCBFcnJvclR5cGUgPSBFcnJvcikgPT4ge1xuICBsZXQgcGxheWFiaWxpdHkgPSBwbGF5ZXJfcmVzcG9uc2UgJiYgcGxheWVyX3Jlc3BvbnNlLnBsYXlhYmlsaXR5U3RhdHVzO1xuICBpZiAocGxheWFiaWxpdHkgJiYgc3RhdHVzZXMuaW5jbHVkZXMocGxheWFiaWxpdHkuc3RhdHVzKSkge1xuICAgIHJldHVybiBuZXcgRXJyb3JUeXBlKHBsYXlhYmlsaXR5LnJlYXNvbiB8fCAocGxheWFiaWxpdHkubWVzc2FnZXMgJiYgcGxheWFiaWxpdHkubWVzc2FnZXNbMF0pKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cbi8qKlxuICogRG9lcyBhIG1pbmlnZXQgcmVxdWVzdCBhbmQgY2FsbHMgb3B0aW9ucy5yZXF1ZXN0Q2FsbGJhY2sgaWYgcHJlc2VudFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgdGhlIHJlcXVlc3QgdXJsXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBhbiBvYmplY3Qgd2l0aCBvcHRpb25hbCByZXF1ZXN0T3B0aW9ucyBhbmQgcmVxdWVzdENhbGxiYWNrIHBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7T2JqZWN0fSByZXF1ZXN0T3B0aW9uc092ZXJ3cml0ZSBvdmVyd3JpdGUgb2Ygb3B0aW9ucy5yZXF1ZXN0T3B0aW9uc1xuICogQHJldHVybnMge21pbmlnZXQuU3RyZWFtfVxuICovXG5leHBvcnRzLmV4cG9zZWRNaW5pZ2V0ID0gKHVybCwgb3B0aW9ucyA9IHt9LCByZXF1ZXN0T3B0aW9uc092ZXJ3cml0ZSkgPT4ge1xuICBjb25zdCByZXEgPSBtaW5pZ2V0KHVybCwgcmVxdWVzdE9wdGlvbnNPdmVyd3JpdGUgfHwgb3B0aW9ucy5yZXF1ZXN0T3B0aW9ucyk7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5yZXF1ZXN0Q2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIG9wdGlvbnMucmVxdWVzdENhbGxiYWNrKHJlcSk7XG4gIHJldHVybiByZXE7XG59O1xuXG4vKipcbiAqIFRlbXBvcmFyeSBoZWxwZXIgdG8gaGVscCBkZXByZWNhdGluZyBhIGZldyBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBvbGRQYXRoXG4gKiBAcGFyYW0ge3N0cmluZ30gbmV3UGF0aFxuICovXG5leHBvcnRzLmRlcHJlY2F0ZSA9IChvYmosIHByb3AsIHZhbHVlLCBvbGRQYXRoLCBuZXdQYXRoKSA9PiB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIHByb3AsIHtcbiAgICBnZXQ6ICgpID0+IHtcbiAgICAgIGNvbnNvbGUud2FybihgXFxgJHtvbGRQYXRofVxcYCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBuZWFyIGZ1dHVyZSByZWxlYXNlLCBgICtcbiAgICAgICAgYHVzZSBcXGAke25ld1BhdGh9XFxgIGluc3RlYWQuYCk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbiAgfSk7XG59O1xuXG5cbi8vIENoZWNrIGZvciB1cGRhdGVzLlxuY29uc3QgcGtnID0gcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJyk7XG5jb25zdCBVUERBVEVfSU5URVJWQUwgPSAxMDAwICogNjAgKiA2MCAqIDEyO1xuZXhwb3J0cy5sYXN0VXBkYXRlQ2hlY2sgPSAwO1xuZXhwb3J0cy5jaGVja0ZvclVwZGF0ZXMgPSAoKSA9PiB7XG4gIGlmICghcHJvY2Vzcy5lbnYuWVRETF9OT19VUERBVEUgJiYgIXBrZy52ZXJzaW9uLnN0YXJ0c1dpdGgoJzAuMC4wLScpICYmXG4gICAgRGF0ZS5ub3coKSAtIGV4cG9ydHMubGFzdFVwZGF0ZUNoZWNrID49IFVQREFURV9JTlRFUlZBTCkge1xuICAgIGV4cG9ydHMubGFzdFVwZGF0ZUNoZWNrID0gRGF0ZS5ub3coKTtcbiAgICByZXR1cm4gbWluaWdldCgnaHR0cHM6Ly9hcGkuZ2l0aHViLmNvbS9yZXBvcy9mZW50L25vZGUteXRkbC1jb3JlL3JlbGVhc2VzL2xhdGVzdCcsIHtcbiAgICAgIGhlYWRlcnM6IHsgJ1VzZXItQWdlbnQnOiAneXRkbC1jb3JlJyB9LFxuICAgIH0pLnRleHQoKS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgIGlmIChKU09OLnBhcnNlKHJlc3BvbnNlKS50YWdfbmFtZSAhPT0gYHYke3BrZy52ZXJzaW9ufWApIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdcXHgxYlszM21XQVJOSU5HOlxceDFCWzBtIHl0ZGwtY29yZSBpcyBvdXQgb2YgZGF0ZSEgVXBkYXRlIHdpdGggXCJucG0gaW5zdGFsbCB5dGRsLWNvcmVAbGF0ZXN0XCIuJyk7XG4gICAgICB9XG4gICAgfSwgZXJyID0+IHtcbiAgICAgIGNvbnNvbGUud2FybignRXJyb3IgY2hlY2tpbmcgZm9yIHVwZGF0ZXM6JywgZXJyLm1lc3NhZ2UpO1xuICAgICAgY29uc29sZS53YXJuKCdZb3UgY2FuIGRpc2FibGUgdGhpcyBjaGVjayBieSBzZXR0aW5nIHRoZSBgWVRETF9OT19VUERBVEVgIGVudiB2YXJpYWJsZS4nKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cblxuLyoqXG4gKiBHZXRzIHJhbmRvbSBJUHY2IEFkZHJlc3MgZnJvbSBhIGJsb2NrXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGlwIHRoZSBJUHY2IGJsb2NrIGluIENJRFItTm90YXRpb25cbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmV4cG9ydHMuZ2V0UmFuZG9tSVB2NiA9IGlwID0+IHtcbiAgLy8gU3RhcnQgd2l0aCBhIGZhc3QgUmVnZXgtQ2hlY2tcbiAgaWYgKCFpc0lQdjYoaXApKSB0aHJvdyBFcnJvcignSW52YWxpZCBJUHY2IGZvcm1hdCcpO1xuICAvLyBTdGFydCBieSBzcGxpdHRpbmcgYW5kIG5vcm1hbGl6aW5nIGFkZHIgYW5kIG1hc2tcbiAgY29uc3QgW3Jhd0FkZHIsIHJhd01hc2tdID0gaXAuc3BsaXQoJy8nKTtcbiAgbGV0IGJhc2UxME1hc2sgPSBwYXJzZUludChyYXdNYXNrKTtcbiAgaWYgKCFiYXNlMTBNYXNrIHx8IGJhc2UxME1hc2sgPiAxMjggfHwgYmFzZTEwTWFzayA8IDI0KSB0aHJvdyBFcnJvcignSW52YWxpZCBJUHY2IHN1Ym5ldCcpO1xuICBjb25zdCBiYXNlMTBhZGRyID0gbm9ybWFsaXplSVAocmF3QWRkcik7XG4gIC8vIEdldCByYW5kb20gYWRkciB0byBwYWQgd2l0aFxuICAvLyB1c2luZyBNYXRoLnJhbmRvbSBzaW5jZSB3ZSdyZSBub3QgcmVxdWlyaW5nIGhpZ2ggbGV2ZWwgb2YgcmFuZG9tbmVzc1xuICBjb25zdCByYW5kb21BZGRyID0gbmV3IEFycmF5KDgpLmZpbGwoMSkubWFwKCgpID0+IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDB4ZmZmZikpO1xuXG4gIC8vIE1lcmdlIGJhc2UxMGFkZHIgd2l0aCByYW5kb21BZGRyXG4gIGNvbnN0IG1lcmdlZEFkZHIgPSByYW5kb21BZGRyLm1hcCgocmFuZG9tSXRlbSwgaWR4KSA9PiB7XG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBhbW91bnQgb2Ygc3RhdGljIGJpdHNcbiAgICBjb25zdCBzdGF0aWNCaXRzID0gTWF0aC5taW4oYmFzZTEwTWFzaywgMTYpO1xuICAgIC8vIEFkanVzdCB0aGUgYml0bWFzayB3aXRoIHRoZSBzdGF0aWNCaXRzXG4gICAgYmFzZTEwTWFzayAtPSBzdGF0aWNCaXRzO1xuICAgIC8vIENhbGN1bGF0ZSB0aGUgYml0bWFza1xuICAgIC8vIGxzYiBtYWtlcyB0aGUgY2FsY3VsYXRpb24gd2F5IG1vcmUgY29tcGxpY2F0ZWRcbiAgICBjb25zdCBtYXNrID0gMHhmZmZmIC0gKCgyICoqICgxNiAtIHN0YXRpY0JpdHMpKSAtIDEpO1xuICAgIC8vIENvbWJpbmUgYmFzZTEwYWRkciBhbmQgcmFuZG9tXG4gICAgcmV0dXJuIChiYXNlMTBhZGRyW2lkeF0gJiBtYXNrKSArIChyYW5kb21JdGVtICYgKG1hc2sgXiAweGZmZmYpKTtcbiAgfSk7XG4gIC8vIFJldHVybiBuZXcgYWRkclxuICByZXR1cm4gbWVyZ2VkQWRkci5tYXAoeCA9PiB4LnRvU3RyaW5nKCcxNicpKS5qb2luKCc6Jyk7XG59O1xuXG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuXG5jb25zdCBJUFY2X1JFR0VYID0gL14oKFswLTlhLWZdezEsNH06KSg6WzAtOWEtZl17MSw0fSl7MSw2fXwoWzAtOWEtZl17MSw0fTopezEsMn0oOlswLTlhLWZdezEsNH0pezEsNX18KFswLTlhLWZdezEsNH06KXsxLDN9KDpbMC05YS1mXXsxLDR9KXsxLDR9fChbMC05YS1mXXsxLDR9Oil7MSw0fSg6WzAtOWEtZl17MSw0fSl7MSwzfXwoWzAtOWEtZl17MSw0fTopezEsNX0oOlswLTlhLWZdezEsNH0pezEsMn18KFswLTlhLWZdezEsNH06KXsxLDZ9KDpbMC05YS1mXXsxLDR9KXwoWzAtOWEtZl17MSw0fTopezEsN30oKFswLTlhLWZdezEsNH0pfDopKVxcLygxWzAtMV1cXGR8MTJbMC04XXxcXGR7MSwyfSkkLztcbi8qKlxuICogUXVpY2sgY2hlY2sgZm9yIGEgdmFsaWQgSVB2NlxuICogVGhlIFJlZ2V4IG9ubHkgYWNjZXB0cyBhIHN1YnNldCBvZiBhbGwgSVB2NiBBZGRyZXNzZXNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gaXAgdGhlIElQdjYgYmxvY2sgaW4gQ0lEUi1Ob3RhdGlvbiB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB2YWxpZFxuICovXG5jb25zdCBpc0lQdjYgPSBleHBvcnRzLmlzSVB2NiA9IGlwID0+IElQVjZfUkVHRVgudGVzdChpcCk7XG5cblxuLyoqXG4gKiBOb3JtYWxpc2UgYW4gSVAgQWRkcmVzc1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBpcCB0aGUgSVB2NiBBZGRyXG4gKiBAcmV0dXJucyB7bnVtYmVyW119IHRoZSA4IHBhcnRzIG9mIHRoZSBJUHY2IGFzIEludGVnZXJzXG4gKi9cbmNvbnN0IG5vcm1hbGl6ZUlQID0gZXhwb3J0cy5ub3JtYWxpemVJUCA9IGlwID0+IHtcbiAgLy8gU3BsaXQgYnkgZmlsbCBwb3NpdGlvblxuICBjb25zdCBwYXJ0cyA9IGlwLnNwbGl0KCc6OicpLm1hcCh4ID0+IHguc3BsaXQoJzonKSk7XG4gIC8vIE5vcm1hbGl6ZSBzdGFydCBhbmQgZW5kXG4gIGNvbnN0IHBhcnRTdGFydCA9IHBhcnRzWzBdIHx8IFtdO1xuICBjb25zdCBwYXJ0RW5kID0gcGFydHNbMV0gfHwgW107XG4gIHBhcnRFbmQucmV2ZXJzZSgpO1xuICAvLyBQbGFjZWhvbGRlciBmb3IgZnVsbCBpcFxuICBjb25zdCBmdWxsSVAgPSBuZXcgQXJyYXkoOCkuZmlsbCgwKTtcbiAgLy8gRmlsbCBpbiBzdGFydCBhbmQgZW5kIHBhcnRzXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgTWF0aC5taW4ocGFydFN0YXJ0Lmxlbmd0aCwgOCk7IGkrKykge1xuICAgIGZ1bGxJUFtpXSA9IHBhcnNlSW50KHBhcnRTdGFydFtpXSwgMTYpIHx8IDA7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBNYXRoLm1pbihwYXJ0RW5kLmxlbmd0aCwgOCk7IGkrKykge1xuICAgIGZ1bGxJUFs3IC0gaV0gPSBwYXJzZUludChwYXJ0RW5kW2ldLCAxNikgfHwgMDtcbiAgfVxuICByZXR1cm4gZnVsbElQO1xufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ytdl-core/lib/utils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ytdl-core/package.json":
/*!*********************************************!*\
  !*** ./node_modules/ytdl-core/package.json ***!
  \*********************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"name":"ytdl-core","description":"YouTube video downloader in pure javascript.","keywords":["youtube","video","download"],"version":"4.11.5","repository":{"type":"git","url":"git://github.com/fent/node-ytdl-core.git"},"author":"fent <fentbox@gmail.com> (https://github.com/fent)","contributors":["Tobias Kutscha (https://github.com/TimeForANinja)","Andrew Kelley (https://github.com/andrewrk)","Mauricio Allende (https://github.com/mallendeo)","Rodrigo Altamirano (https://github.com/raltamirano)","Jim Buck (https://github.com/JimmyBoh)","Pawe Ruciski (https://github.com/Roki100)","Alexander Paolini (https://github.com/Million900o)"],"main":"./lib/index.js","types":"./typings/index.d.ts","files":["lib","typings"],"scripts":{"test":"nyc --reporter=lcov --reporter=text-summary npm run test:unit","test:unit":"mocha --ignore test/irl-test.js test/*-test.js --timeout 4000","test:irl":"mocha --timeout 16000 test/irl-test.js","lint":"eslint ./","lint:fix":"eslint --fix ./","lint:typings":"tslint typings/index.d.ts","lint:typings:fix":"tslint --fix typings/index.d.ts"},"dependencies":{"m3u8stream":"^0.8.6","miniget":"^4.2.2","sax":"^1.1.3"},"devDependencies":{"@types/node":"^13.1.0","assert-diff":"^3.0.1","dtslint":"^3.6.14","eslint":"^6.8.0","mocha":"^7.0.0","muk-require":"^1.2.0","nock":"^13.0.4","nyc":"^15.0.0","sinon":"^9.0.0","stream-equal":"~1.1.0","typescript":"^3.9.7"},"engines":{"node":">=12"},"license":"MIT"}');

/***/ })

};
;
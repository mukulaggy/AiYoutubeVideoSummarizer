"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/m3u8stream";
exports.ids = ["vendor-chunks/m3u8stream"];
exports.modules = {

/***/ "(rsc)/./node_modules/m3u8stream/dist/dash-mpd-parser.js":
/*!*********************************************************!*\
  !*** ./node_modules/m3u8stream/dist/dash-mpd-parser.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst stream_1 = __webpack_require__(/*! stream */ \"stream\");\nconst sax_1 = __importDefault(__webpack_require__(/*! sax */ \"(rsc)/./node_modules/sax/lib/sax.js\"));\nconst parse_time_1 = __webpack_require__(/*! ./parse-time */ \"(rsc)/./node_modules/m3u8stream/dist/parse-time.js\");\n/**\n * A wrapper around sax that emits segments.\n */\nclass DashMPDParser extends stream_1.Writable {\n    constructor(targetID) {\n        super();\n        this._parser = sax_1.default.createStream(false, { lowercase: true });\n        this._parser.on('error', this.destroy.bind(this));\n        let lastTag;\n        let currtime = 0;\n        let seq = 0;\n        let segmentTemplate;\n        let timescale, offset, duration, baseURL;\n        let timeline = [];\n        let getSegments = false;\n        let gotSegments = false;\n        let isStatic;\n        let treeLevel;\n        let periodStart;\n        const tmpl = (str) => {\n            const context = {\n                RepresentationID: targetID,\n                Number: seq,\n                Time: currtime,\n            };\n            return str.replace(/\\$(\\w+)\\$/g, (m, p1) => `${context[p1]}`);\n        };\n        this._parser.on('opentag', node => {\n            switch (node.name) {\n                case 'mpd':\n                    currtime =\n                        node.attributes.availabilitystarttime ?\n                            new Date(node.attributes.availabilitystarttime).getTime() : 0;\n                    isStatic = node.attributes.type !== 'dynamic';\n                    break;\n                case 'period':\n                    // Reset everything on <Period> tag.\n                    seq = 0;\n                    timescale = 1000;\n                    duration = 0;\n                    offset = 0;\n                    baseURL = [];\n                    treeLevel = 0;\n                    periodStart = parse_time_1.durationStr(node.attributes.start) || 0;\n                    break;\n                case 'segmentlist':\n                    seq = parseInt(node.attributes.startnumber) || seq;\n                    timescale = parseInt(node.attributes.timescale) || timescale;\n                    duration = parseInt(node.attributes.duration) || duration;\n                    offset = parseInt(node.attributes.presentationtimeoffset) || offset;\n                    break;\n                case 'segmenttemplate':\n                    segmentTemplate = node.attributes;\n                    seq = parseInt(node.attributes.startnumber) || seq;\n                    timescale = parseInt(node.attributes.timescale) || timescale;\n                    break;\n                case 'segmenttimeline':\n                case 'baseurl':\n                    lastTag = node.name;\n                    break;\n                case 's':\n                    timeline.push({\n                        duration: parseInt(node.attributes.d),\n                        repeat: parseInt(node.attributes.r),\n                        time: parseInt(node.attributes.t),\n                    });\n                    break;\n                case 'adaptationset':\n                case 'representation':\n                    treeLevel++;\n                    if (!targetID) {\n                        targetID = node.attributes.id;\n                    }\n                    getSegments = node.attributes.id === `${targetID}`;\n                    if (getSegments) {\n                        if (periodStart) {\n                            currtime += periodStart;\n                        }\n                        if (offset) {\n                            currtime -= offset / timescale * 1000;\n                        }\n                        this.emit('starttime', currtime);\n                    }\n                    break;\n                case 'initialization':\n                    if (getSegments) {\n                        this.emit('item', {\n                            url: baseURL.filter(s => !!s).join('') + node.attributes.sourceurl,\n                            seq: seq,\n                            init: true,\n                            duration: 0,\n                        });\n                    }\n                    break;\n                case 'segmenturl':\n                    if (getSegments) {\n                        gotSegments = true;\n                        let tl = timeline.shift();\n                        let segmentDuration = ((tl === null || tl === void 0 ? void 0 : tl.duration) || duration) / timescale * 1000;\n                        this.emit('item', {\n                            url: baseURL.filter(s => !!s).join('') + node.attributes.media,\n                            seq: seq++,\n                            duration: segmentDuration,\n                        });\n                        currtime += segmentDuration;\n                    }\n                    break;\n            }\n        });\n        const onEnd = () => {\n            if (isStatic) {\n                this.emit('endlist');\n            }\n            if (!getSegments) {\n                this.destroy(Error(`Representation '${targetID}' not found`));\n            }\n            else {\n                this.emit('end');\n            }\n        };\n        this._parser.on('closetag', tagName => {\n            switch (tagName) {\n                case 'adaptationset':\n                case 'representation':\n                    treeLevel--;\n                    if (segmentTemplate && timeline.length) {\n                        gotSegments = true;\n                        if (segmentTemplate.initialization) {\n                            this.emit('item', {\n                                url: baseURL.filter(s => !!s).join('') +\n                                    tmpl(segmentTemplate.initialization),\n                                seq: seq,\n                                init: true,\n                                duration: 0,\n                            });\n                        }\n                        for (let { duration: itemDuration, repeat, time } of timeline) {\n                            itemDuration = itemDuration / timescale * 1000;\n                            repeat = repeat || 1;\n                            currtime = time || currtime;\n                            for (let i = 0; i < repeat; i++) {\n                                this.emit('item', {\n                                    url: baseURL.filter(s => !!s).join('') +\n                                        tmpl(segmentTemplate.media),\n                                    seq: seq++,\n                                    duration: itemDuration,\n                                });\n                                currtime += itemDuration;\n                            }\n                        }\n                    }\n                    if (gotSegments) {\n                        this.emit('endearly');\n                        onEnd();\n                        this._parser.removeAllListeners();\n                        this.removeAllListeners('finish');\n                    }\n                    break;\n            }\n        });\n        this._parser.on('text', text => {\n            if (lastTag === 'baseurl') {\n                baseURL[treeLevel] = text;\n                lastTag = null;\n            }\n        });\n        this.on('finish', onEnd);\n    }\n    _write(chunk, encoding, callback) {\n        this._parser.write(chunk);\n        callback();\n    }\n}\nexports[\"default\"] = DashMPDParser;\n//# sourceMappingURL=dash-mpd-parser.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbTN1OHN0cmVhbS9kaXN0L2Rhc2gtbXBkLXBhcnNlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlCQUFpQixtQkFBTyxDQUFDLHNCQUFRO0FBQ2pDLDhCQUE4QixtQkFBTyxDQUFDLGdEQUFLO0FBQzNDLHFCQUFxQixtQkFBTyxDQUFDLHdFQUFjO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxpQkFBaUI7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELFlBQVk7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELFNBQVM7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsU0FBUztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLG1DQUFtQyx1Q0FBdUM7QUFDMUU7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFlBQVk7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcYWdneW1cXE9uZURyaXZlXFxEZXNrdG9wXFxwcm9qZWN0c1xceW91dHViZV9zdW1tYXJpemVyXFxub2RlX21vZHVsZXNcXG0zdThzdHJlYW1cXGRpc3RcXGRhc2gtbXBkLXBhcnNlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHN0cmVhbV8xID0gcmVxdWlyZShcInN0cmVhbVwiKTtcbmNvbnN0IHNheF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJzYXhcIikpO1xuY29uc3QgcGFyc2VfdGltZV8xID0gcmVxdWlyZShcIi4vcGFyc2UtdGltZVwiKTtcbi8qKlxuICogQSB3cmFwcGVyIGFyb3VuZCBzYXggdGhhdCBlbWl0cyBzZWdtZW50cy5cbiAqL1xuY2xhc3MgRGFzaE1QRFBhcnNlciBleHRlbmRzIHN0cmVhbV8xLldyaXRhYmxlIHtcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXRJRCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9wYXJzZXIgPSBzYXhfMS5kZWZhdWx0LmNyZWF0ZVN0cmVhbShmYWxzZSwgeyBsb3dlcmNhc2U6IHRydWUgfSk7XG4gICAgICAgIHRoaXMuX3BhcnNlci5vbignZXJyb3InLCB0aGlzLmRlc3Ryb3kuYmluZCh0aGlzKSk7XG4gICAgICAgIGxldCBsYXN0VGFnO1xuICAgICAgICBsZXQgY3VycnRpbWUgPSAwO1xuICAgICAgICBsZXQgc2VxID0gMDtcbiAgICAgICAgbGV0IHNlZ21lbnRUZW1wbGF0ZTtcbiAgICAgICAgbGV0IHRpbWVzY2FsZSwgb2Zmc2V0LCBkdXJhdGlvbiwgYmFzZVVSTDtcbiAgICAgICAgbGV0IHRpbWVsaW5lID0gW107XG4gICAgICAgIGxldCBnZXRTZWdtZW50cyA9IGZhbHNlO1xuICAgICAgICBsZXQgZ290U2VnbWVudHMgPSBmYWxzZTtcbiAgICAgICAgbGV0IGlzU3RhdGljO1xuICAgICAgICBsZXQgdHJlZUxldmVsO1xuICAgICAgICBsZXQgcGVyaW9kU3RhcnQ7XG4gICAgICAgIGNvbnN0IHRtcGwgPSAoc3RyKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICAgICAgICAgIFJlcHJlc2VudGF0aW9uSUQ6IHRhcmdldElELFxuICAgICAgICAgICAgICAgIE51bWJlcjogc2VxLFxuICAgICAgICAgICAgICAgIFRpbWU6IGN1cnJ0aW1lLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBzdHIucmVwbGFjZSgvXFwkKFxcdyspXFwkL2csIChtLCBwMSkgPT4gYCR7Y29udGV4dFtwMV19YCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3BhcnNlci5vbignb3BlbnRhZycsIG5vZGUgPT4ge1xuICAgICAgICAgICAgc3dpdGNoIChub2RlLm5hbWUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdtcGQnOlxuICAgICAgICAgICAgICAgICAgICBjdXJydGltZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLmF0dHJpYnV0ZXMuYXZhaWxhYmlsaXR5c3RhcnR0aW1lID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgRGF0ZShub2RlLmF0dHJpYnV0ZXMuYXZhaWxhYmlsaXR5c3RhcnR0aW1lKS5nZXRUaW1lKCkgOiAwO1xuICAgICAgICAgICAgICAgICAgICBpc1N0YXRpYyA9IG5vZGUuYXR0cmlidXRlcy50eXBlICE9PSAnZHluYW1pYyc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3BlcmlvZCc6XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlc2V0IGV2ZXJ5dGhpbmcgb24gPFBlcmlvZD4gdGFnLlxuICAgICAgICAgICAgICAgICAgICBzZXEgPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aW1lc2NhbGUgPSAxMDAwO1xuICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbiA9IDA7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGJhc2VVUkwgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgdHJlZUxldmVsID0gMDtcbiAgICAgICAgICAgICAgICAgICAgcGVyaW9kU3RhcnQgPSBwYXJzZV90aW1lXzEuZHVyYXRpb25TdHIobm9kZS5hdHRyaWJ1dGVzLnN0YXJ0KSB8fCAwO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdzZWdtZW50bGlzdCc6XG4gICAgICAgICAgICAgICAgICAgIHNlcSA9IHBhcnNlSW50KG5vZGUuYXR0cmlidXRlcy5zdGFydG51bWJlcikgfHwgc2VxO1xuICAgICAgICAgICAgICAgICAgICB0aW1lc2NhbGUgPSBwYXJzZUludChub2RlLmF0dHJpYnV0ZXMudGltZXNjYWxlKSB8fCB0aW1lc2NhbGU7XG4gICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uID0gcGFyc2VJbnQobm9kZS5hdHRyaWJ1dGVzLmR1cmF0aW9uKSB8fCBkdXJhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gcGFyc2VJbnQobm9kZS5hdHRyaWJ1dGVzLnByZXNlbnRhdGlvbnRpbWVvZmZzZXQpIHx8IG9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnc2VnbWVudHRlbXBsYXRlJzpcbiAgICAgICAgICAgICAgICAgICAgc2VnbWVudFRlbXBsYXRlID0gbm9kZS5hdHRyaWJ1dGVzO1xuICAgICAgICAgICAgICAgICAgICBzZXEgPSBwYXJzZUludChub2RlLmF0dHJpYnV0ZXMuc3RhcnRudW1iZXIpIHx8IHNlcTtcbiAgICAgICAgICAgICAgICAgICAgdGltZXNjYWxlID0gcGFyc2VJbnQobm9kZS5hdHRyaWJ1dGVzLnRpbWVzY2FsZSkgfHwgdGltZXNjYWxlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdzZWdtZW50dGltZWxpbmUnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jhc2V1cmwnOlxuICAgICAgICAgICAgICAgICAgICBsYXN0VGFnID0gbm9kZS5uYW1lO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdzJzpcbiAgICAgICAgICAgICAgICAgICAgdGltZWxpbmUucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbjogcGFyc2VJbnQobm9kZS5hdHRyaWJ1dGVzLmQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVwZWF0OiBwYXJzZUludChub2RlLmF0dHJpYnV0ZXMuciksXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lOiBwYXJzZUludChub2RlLmF0dHJpYnV0ZXMudCksXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdhZGFwdGF0aW9uc2V0JzpcbiAgICAgICAgICAgICAgICBjYXNlICdyZXByZXNlbnRhdGlvbic6XG4gICAgICAgICAgICAgICAgICAgIHRyZWVMZXZlbCsrO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRhcmdldElEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRJRCA9IG5vZGUuYXR0cmlidXRlcy5pZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBnZXRTZWdtZW50cyA9IG5vZGUuYXR0cmlidXRlcy5pZCA9PT0gYCR7dGFyZ2V0SUR9YDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdldFNlZ21lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGVyaW9kU3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJydGltZSArPSBwZXJpb2RTdGFydDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJydGltZSAtPSBvZmZzZXQgLyB0aW1lc2NhbGUgKiAxMDAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdzdGFydHRpbWUnLCBjdXJydGltZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnaW5pdGlhbGl6YXRpb24nOlxuICAgICAgICAgICAgICAgICAgICBpZiAoZ2V0U2VnbWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnaXRlbScsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IGJhc2VVUkwuZmlsdGVyKHMgPT4gISFzKS5qb2luKCcnKSArIG5vZGUuYXR0cmlidXRlcy5zb3VyY2V1cmwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VxOiBzZXEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5pdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbjogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3NlZ21lbnR1cmwnOlxuICAgICAgICAgICAgICAgICAgICBpZiAoZ2V0U2VnbWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdvdFNlZ21lbnRzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0bCA9IHRpbWVsaW5lLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc2VnbWVudER1cmF0aW9uID0gKCh0bCA9PT0gbnVsbCB8fCB0bCA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGwuZHVyYXRpb24pIHx8IGR1cmF0aW9uKSAvIHRpbWVzY2FsZSAqIDEwMDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2l0ZW0nLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBiYXNlVVJMLmZpbHRlcihzID0+ICEhcykuam9pbignJykgKyBub2RlLmF0dHJpYnV0ZXMubWVkaWEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VxOiBzZXErKyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbjogc2VnbWVudER1cmF0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJydGltZSArPSBzZWdtZW50RHVyYXRpb247XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBvbkVuZCA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmIChpc1N0YXRpYykge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZW5kbGlzdCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFnZXRTZWdtZW50cykge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVzdHJveShFcnJvcihgUmVwcmVzZW50YXRpb24gJyR7dGFyZ2V0SUR9JyBub3QgZm91bmRgKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2VuZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9wYXJzZXIub24oJ2Nsb3NldGFnJywgdGFnTmFtZSA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZ05hbWUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdhZGFwdGF0aW9uc2V0JzpcbiAgICAgICAgICAgICAgICBjYXNlICdyZXByZXNlbnRhdGlvbic6XG4gICAgICAgICAgICAgICAgICAgIHRyZWVMZXZlbC0tO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VnbWVudFRlbXBsYXRlICYmIHRpbWVsaW5lLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ290U2VnbWVudHMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlZ21lbnRUZW1wbGF0ZS5pbml0aWFsaXphdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnaXRlbScsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBiYXNlVVJMLmZpbHRlcihzID0+ICEhcykuam9pbignJykgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1wbChzZWdtZW50VGVtcGxhdGUuaW5pdGlhbGl6YXRpb24pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXE6IHNlcSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5pdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHVyYXRpb246IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCB7IGR1cmF0aW9uOiBpdGVtRHVyYXRpb24sIHJlcGVhdCwgdGltZSB9IG9mIHRpbWVsaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbUR1cmF0aW9uID0gaXRlbUR1cmF0aW9uIC8gdGltZXNjYWxlICogMTAwMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBlYXQgPSByZXBlYXQgfHwgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJydGltZSA9IHRpbWUgfHwgY3VycnRpbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXBlYXQ7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2l0ZW0nLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IGJhc2VVUkwuZmlsdGVyKHMgPT4gISFzKS5qb2luKCcnKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1wbChzZWdtZW50VGVtcGxhdGUubWVkaWEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VxOiBzZXErKyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uOiBpdGVtRHVyYXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJydGltZSArPSBpdGVtRHVyYXRpb247XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChnb3RTZWdtZW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdlbmRlYXJseScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb25FbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlci5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdmaW5pc2gnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3BhcnNlci5vbigndGV4dCcsIHRleHQgPT4ge1xuICAgICAgICAgICAgaWYgKGxhc3RUYWcgPT09ICdiYXNldXJsJykge1xuICAgICAgICAgICAgICAgIGJhc2VVUkxbdHJlZUxldmVsXSA9IHRleHQ7XG4gICAgICAgICAgICAgICAgbGFzdFRhZyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm9uKCdmaW5pc2gnLCBvbkVuZCk7XG4gICAgfVxuICAgIF93cml0ZShjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuX3BhcnNlci53cml0ZShjaHVuayk7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gRGFzaE1QRFBhcnNlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhc2gtbXBkLXBhcnNlci5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/m3u8stream/dist/dash-mpd-parser.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/m3u8stream/dist/index.js":
/*!***********************************************!*\
  !*** ./node_modules/m3u8stream/dist/index.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nconst stream_1 = __webpack_require__(/*! stream */ \"stream\");\nconst miniget_1 = __importDefault(__webpack_require__(/*! miniget */ \"(rsc)/./node_modules/miniget/dist/index.js\"));\nconst m3u8_parser_1 = __importDefault(__webpack_require__(/*! ./m3u8-parser */ \"(rsc)/./node_modules/m3u8stream/dist/m3u8-parser.js\"));\nconst dash_mpd_parser_1 = __importDefault(__webpack_require__(/*! ./dash-mpd-parser */ \"(rsc)/./node_modules/m3u8stream/dist/dash-mpd-parser.js\"));\nconst queue_1 = __webpack_require__(/*! ./queue */ \"(rsc)/./node_modules/m3u8stream/dist/queue.js\");\nconst parse_time_1 = __webpack_require__(/*! ./parse-time */ \"(rsc)/./node_modules/m3u8stream/dist/parse-time.js\");\nconst supportedParsers = {\n    m3u8: m3u8_parser_1.default,\n    'dash-mpd': dash_mpd_parser_1.default,\n};\nlet m3u8stream = ((playlistURL, options = {}) => {\n    const stream = new stream_1.PassThrough({ highWaterMark: options.highWaterMark });\n    const chunkReadahead = options.chunkReadahead || 3;\n    // 20 seconds.\n    const liveBuffer = options.liveBuffer || 20000;\n    const requestOptions = options.requestOptions;\n    const Parser = supportedParsers[options.parser || (/\\.mpd$/.test(playlistURL) ? 'dash-mpd' : 'm3u8')];\n    if (!Parser) {\n        throw TypeError(`parser '${options.parser}' not supported`);\n    }\n    let begin = 0;\n    if (typeof options.begin !== 'undefined') {\n        begin = typeof options.begin === 'string' ?\n            parse_time_1.humanStr(options.begin) :\n            Math.max(options.begin - liveBuffer, 0);\n    }\n    const forwardEvents = (req) => {\n        for (let event of ['abort', 'request', 'response', 'redirect', 'retry', 'reconnect']) {\n            req.on(event, stream.emit.bind(stream, event));\n        }\n    };\n    let currSegment;\n    const streamQueue = new queue_1.Queue((req, callback) => {\n        currSegment = req;\n        // Count the size manually, since the `content-length` header is not\n        // always there.\n        let size = 0;\n        req.on('data', (chunk) => size += chunk.length);\n        req.pipe(stream, { end: false });\n        req.on('end', () => callback(null, size));\n    }, { concurrency: 1 });\n    let segmentNumber = 0;\n    let downloaded = 0;\n    const requestQueue = new queue_1.Queue((segment, callback) => {\n        let reqOptions = Object.assign({}, requestOptions);\n        if (segment.range) {\n            reqOptions.headers = Object.assign({}, reqOptions.headers, {\n                Range: `bytes=${segment.range.start}-${segment.range.end}`,\n            });\n        }\n        let req = miniget_1.default(new URL(segment.url, playlistURL).toString(), reqOptions);\n        req.on('error', callback);\n        forwardEvents(req);\n        streamQueue.push(req, (_, size) => {\n            downloaded += +size;\n            stream.emit('progress', {\n                num: ++segmentNumber,\n                size: size,\n                duration: segment.duration,\n                url: segment.url,\n            }, requestQueue.total, downloaded);\n            callback(null);\n        });\n    }, { concurrency: chunkReadahead });\n    const onError = (err) => {\n        stream.emit('error', err);\n        // Stop on any error.\n        stream.end();\n    };\n    // When to look for items again.\n    let refreshThreshold;\n    let minRefreshTime;\n    let refreshTimeout;\n    let fetchingPlaylist = true;\n    let ended = false;\n    let isStatic = false;\n    let lastRefresh;\n    const onQueuedEnd = (err) => {\n        currSegment = null;\n        if (err) {\n            onError(err);\n        }\n        else if (!fetchingPlaylist && !ended && !isStatic &&\n            requestQueue.tasks.length + requestQueue.active <= refreshThreshold) {\n            let ms = Math.max(0, minRefreshTime - (Date.now() - lastRefresh));\n            fetchingPlaylist = true;\n            refreshTimeout = setTimeout(refreshPlaylist, ms);\n        }\n        else if ((ended || isStatic) &&\n            !requestQueue.tasks.length && !requestQueue.active) {\n            stream.end();\n        }\n    };\n    let currPlaylist;\n    let lastSeq;\n    let starttime = 0;\n    const refreshPlaylist = () => {\n        lastRefresh = Date.now();\n        currPlaylist = miniget_1.default(playlistURL, requestOptions);\n        currPlaylist.on('error', onError);\n        forwardEvents(currPlaylist);\n        const parser = currPlaylist.pipe(new Parser(options.id));\n        parser.on('starttime', (a) => {\n            if (starttime) {\n                return;\n            }\n            starttime = a;\n            if (typeof options.begin === 'string' && begin >= 0) {\n                begin += starttime;\n            }\n        });\n        parser.on('endlist', () => { isStatic = true; });\n        parser.on('endearly', currPlaylist.unpipe.bind(currPlaylist, parser));\n        let addedItems = [];\n        const addItem = (item) => {\n            if (!item.init) {\n                if (item.seq <= lastSeq) {\n                    return;\n                }\n                lastSeq = item.seq;\n            }\n            begin = item.time;\n            requestQueue.push(item, onQueuedEnd);\n            addedItems.push(item);\n        };\n        let tailedItems = [], tailedItemsDuration = 0;\n        parser.on('item', (item) => {\n            let timedItem = Object.assign({ time: starttime }, item);\n            if (begin <= timedItem.time) {\n                addItem(timedItem);\n            }\n            else {\n                tailedItems.push(timedItem);\n                tailedItemsDuration += timedItem.duration;\n                // Only keep the last `liveBuffer` of items.\n                while (tailedItems.length > 1 &&\n                    tailedItemsDuration - tailedItems[0].duration > liveBuffer) {\n                    const lastItem = tailedItems.shift();\n                    tailedItemsDuration -= lastItem.duration;\n                }\n            }\n            starttime += timedItem.duration;\n        });\n        parser.on('end', () => {\n            currPlaylist = null;\n            // If we are too ahead of the stream, make sure to get the\n            // latest available items with a small buffer.\n            if (!addedItems.length && tailedItems.length) {\n                tailedItems.forEach(item => { addItem(item); });\n            }\n            // Refresh the playlist when remaining segments get low.\n            refreshThreshold = Math.max(1, Math.ceil(addedItems.length * 0.01));\n            // Throttle refreshing the playlist by looking at the duration\n            // of live items added on this refresh.\n            minRefreshTime =\n                addedItems.reduce((total, item) => item.duration + total, 0);\n            fetchingPlaylist = false;\n            onQueuedEnd(null);\n        });\n    };\n    refreshPlaylist();\n    stream.end = () => {\n        ended = true;\n        streamQueue.die();\n        requestQueue.die();\n        clearTimeout(refreshTimeout);\n        currPlaylist === null || currPlaylist === void 0 ? void 0 : currPlaylist.destroy();\n        currSegment === null || currSegment === void 0 ? void 0 : currSegment.destroy();\n        stream_1.PassThrough.prototype.end.call(stream, null);\n        return stream;\n    };\n    return stream;\n});\nm3u8stream.parseTimestamp = parse_time_1.humanStr;\nmodule.exports = m3u8stream;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbTN1OHN0cmVhbS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSxpQkFBaUIsbUJBQU8sQ0FBQyxzQkFBUTtBQUNqQyxrQ0FBa0MsbUJBQU8sQ0FBQywyREFBUztBQUNuRCxzQ0FBc0MsbUJBQU8sQ0FBQywwRUFBZTtBQUM3RCwwQ0FBMEMsbUJBQU8sQ0FBQyxrRkFBbUI7QUFDckUsZ0JBQWdCLG1CQUFPLENBQUMsOERBQVM7QUFDakMscUJBQXFCLG1CQUFPLENBQUMsd0VBQWM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUMsOENBQThDLHNDQUFzQztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsZUFBZTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixZQUFZO0FBQ3ZDO0FBQ0EsS0FBSyxJQUFJLGdCQUFnQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQSxpREFBaUQ7QUFDakQsZ0NBQWdDLG9CQUFvQixHQUFHLGtCQUFrQjtBQUN6RSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVCxLQUFLLElBQUksNkJBQTZCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULHFDQUFxQyxrQkFBa0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGlCQUFpQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsZ0JBQWdCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcYWdneW1cXE9uZURyaXZlXFxEZXNrdG9wXFxwcm9qZWN0c1xceW91dHViZV9zdW1tYXJpemVyXFxub2RlX21vZHVsZXNcXG0zdThzdHJlYW1cXGRpc3RcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuY29uc3Qgc3RyZWFtXzEgPSByZXF1aXJlKFwic3RyZWFtXCIpO1xuY29uc3QgbWluaWdldF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJtaW5pZ2V0XCIpKTtcbmNvbnN0IG0zdThfcGFyc2VyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vbTN1OC1wYXJzZXJcIikpO1xuY29uc3QgZGFzaF9tcGRfcGFyc2VyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vZGFzaC1tcGQtcGFyc2VyXCIpKTtcbmNvbnN0IHF1ZXVlXzEgPSByZXF1aXJlKFwiLi9xdWV1ZVwiKTtcbmNvbnN0IHBhcnNlX3RpbWVfMSA9IHJlcXVpcmUoXCIuL3BhcnNlLXRpbWVcIik7XG5jb25zdCBzdXBwb3J0ZWRQYXJzZXJzID0ge1xuICAgIG0zdTg6IG0zdThfcGFyc2VyXzEuZGVmYXVsdCxcbiAgICAnZGFzaC1tcGQnOiBkYXNoX21wZF9wYXJzZXJfMS5kZWZhdWx0LFxufTtcbmxldCBtM3U4c3RyZWFtID0gKChwbGF5bGlzdFVSTCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgY29uc3Qgc3RyZWFtID0gbmV3IHN0cmVhbV8xLlBhc3NUaHJvdWdoKHsgaGlnaFdhdGVyTWFyazogb3B0aW9ucy5oaWdoV2F0ZXJNYXJrIH0pO1xuICAgIGNvbnN0IGNodW5rUmVhZGFoZWFkID0gb3B0aW9ucy5jaHVua1JlYWRhaGVhZCB8fCAzO1xuICAgIC8vIDIwIHNlY29uZHMuXG4gICAgY29uc3QgbGl2ZUJ1ZmZlciA9IG9wdGlvbnMubGl2ZUJ1ZmZlciB8fCAyMDAwMDtcbiAgICBjb25zdCByZXF1ZXN0T3B0aW9ucyA9IG9wdGlvbnMucmVxdWVzdE9wdGlvbnM7XG4gICAgY29uc3QgUGFyc2VyID0gc3VwcG9ydGVkUGFyc2Vyc1tvcHRpb25zLnBhcnNlciB8fCAoL1xcLm1wZCQvLnRlc3QocGxheWxpc3RVUkwpID8gJ2Rhc2gtbXBkJyA6ICdtM3U4JyldO1xuICAgIGlmICghUGFyc2VyKSB7XG4gICAgICAgIHRocm93IFR5cGVFcnJvcihgcGFyc2VyICcke29wdGlvbnMucGFyc2VyfScgbm90IHN1cHBvcnRlZGApO1xuICAgIH1cbiAgICBsZXQgYmVnaW4gPSAwO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5iZWdpbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgYmVnaW4gPSB0eXBlb2Ygb3B0aW9ucy5iZWdpbiA9PT0gJ3N0cmluZycgP1xuICAgICAgICAgICAgcGFyc2VfdGltZV8xLmh1bWFuU3RyKG9wdGlvbnMuYmVnaW4pIDpcbiAgICAgICAgICAgIE1hdGgubWF4KG9wdGlvbnMuYmVnaW4gLSBsaXZlQnVmZmVyLCAwKTtcbiAgICB9XG4gICAgY29uc3QgZm9yd2FyZEV2ZW50cyA9IChyZXEpID0+IHtcbiAgICAgICAgZm9yIChsZXQgZXZlbnQgb2YgWydhYm9ydCcsICdyZXF1ZXN0JywgJ3Jlc3BvbnNlJywgJ3JlZGlyZWN0JywgJ3JldHJ5JywgJ3JlY29ubmVjdCddKSB7XG4gICAgICAgICAgICByZXEub24oZXZlbnQsIHN0cmVhbS5lbWl0LmJpbmQoc3RyZWFtLCBldmVudCkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBsZXQgY3VyclNlZ21lbnQ7XG4gICAgY29uc3Qgc3RyZWFtUXVldWUgPSBuZXcgcXVldWVfMS5RdWV1ZSgocmVxLCBjYWxsYmFjaykgPT4ge1xuICAgICAgICBjdXJyU2VnbWVudCA9IHJlcTtcbiAgICAgICAgLy8gQ291bnQgdGhlIHNpemUgbWFudWFsbHksIHNpbmNlIHRoZSBgY29udGVudC1sZW5ndGhgIGhlYWRlciBpcyBub3RcbiAgICAgICAgLy8gYWx3YXlzIHRoZXJlLlxuICAgICAgICBsZXQgc2l6ZSA9IDA7XG4gICAgICAgIHJlcS5vbignZGF0YScsIChjaHVuaykgPT4gc2l6ZSArPSBjaHVuay5sZW5ndGgpO1xuICAgICAgICByZXEucGlwZShzdHJlYW0sIHsgZW5kOiBmYWxzZSB9KTtcbiAgICAgICAgcmVxLm9uKCdlbmQnLCAoKSA9PiBjYWxsYmFjayhudWxsLCBzaXplKSk7XG4gICAgfSwgeyBjb25jdXJyZW5jeTogMSB9KTtcbiAgICBsZXQgc2VnbWVudE51bWJlciA9IDA7XG4gICAgbGV0IGRvd25sb2FkZWQgPSAwO1xuICAgIGNvbnN0IHJlcXVlc3RRdWV1ZSA9IG5ldyBxdWV1ZV8xLlF1ZXVlKChzZWdtZW50LCBjYWxsYmFjaykgPT4ge1xuICAgICAgICBsZXQgcmVxT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIHJlcXVlc3RPcHRpb25zKTtcbiAgICAgICAgaWYgKHNlZ21lbnQucmFuZ2UpIHtcbiAgICAgICAgICAgIHJlcU9wdGlvbnMuaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oe30sIHJlcU9wdGlvbnMuaGVhZGVycywge1xuICAgICAgICAgICAgICAgIFJhbmdlOiBgYnl0ZXM9JHtzZWdtZW50LnJhbmdlLnN0YXJ0fS0ke3NlZ21lbnQucmFuZ2UuZW5kfWAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVxID0gbWluaWdldF8xLmRlZmF1bHQobmV3IFVSTChzZWdtZW50LnVybCwgcGxheWxpc3RVUkwpLnRvU3RyaW5nKCksIHJlcU9wdGlvbnMpO1xuICAgICAgICByZXEub24oJ2Vycm9yJywgY2FsbGJhY2spO1xuICAgICAgICBmb3J3YXJkRXZlbnRzKHJlcSk7XG4gICAgICAgIHN0cmVhbVF1ZXVlLnB1c2gocmVxLCAoXywgc2l6ZSkgPT4ge1xuICAgICAgICAgICAgZG93bmxvYWRlZCArPSArc2l6ZTtcbiAgICAgICAgICAgIHN0cmVhbS5lbWl0KCdwcm9ncmVzcycsIHtcbiAgICAgICAgICAgICAgICBudW06ICsrc2VnbWVudE51bWJlcixcbiAgICAgICAgICAgICAgICBzaXplOiBzaXplLFxuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiBzZWdtZW50LmR1cmF0aW9uLFxuICAgICAgICAgICAgICAgIHVybDogc2VnbWVudC51cmwsXG4gICAgICAgICAgICB9LCByZXF1ZXN0UXVldWUudG90YWwsIGRvd25sb2FkZWQpO1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCk7XG4gICAgICAgIH0pO1xuICAgIH0sIHsgY29uY3VycmVuY3k6IGNodW5rUmVhZGFoZWFkIH0pO1xuICAgIGNvbnN0IG9uRXJyb3IgPSAoZXJyKSA9PiB7XG4gICAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICAgIC8vIFN0b3Agb24gYW55IGVycm9yLlxuICAgICAgICBzdHJlYW0uZW5kKCk7XG4gICAgfTtcbiAgICAvLyBXaGVuIHRvIGxvb2sgZm9yIGl0ZW1zIGFnYWluLlxuICAgIGxldCByZWZyZXNoVGhyZXNob2xkO1xuICAgIGxldCBtaW5SZWZyZXNoVGltZTtcbiAgICBsZXQgcmVmcmVzaFRpbWVvdXQ7XG4gICAgbGV0IGZldGNoaW5nUGxheWxpc3QgPSB0cnVlO1xuICAgIGxldCBlbmRlZCA9IGZhbHNlO1xuICAgIGxldCBpc1N0YXRpYyA9IGZhbHNlO1xuICAgIGxldCBsYXN0UmVmcmVzaDtcbiAgICBjb25zdCBvblF1ZXVlZEVuZCA9IChlcnIpID0+IHtcbiAgICAgICAgY3VyclNlZ21lbnQgPSBudWxsO1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBvbkVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWZldGNoaW5nUGxheWxpc3QgJiYgIWVuZGVkICYmICFpc1N0YXRpYyAmJlxuICAgICAgICAgICAgcmVxdWVzdFF1ZXVlLnRhc2tzLmxlbmd0aCArIHJlcXVlc3RRdWV1ZS5hY3RpdmUgPD0gcmVmcmVzaFRocmVzaG9sZCkge1xuICAgICAgICAgICAgbGV0IG1zID0gTWF0aC5tYXgoMCwgbWluUmVmcmVzaFRpbWUgLSAoRGF0ZS5ub3coKSAtIGxhc3RSZWZyZXNoKSk7XG4gICAgICAgICAgICBmZXRjaGluZ1BsYXlsaXN0ID0gdHJ1ZTtcbiAgICAgICAgICAgIHJlZnJlc2hUaW1lb3V0ID0gc2V0VGltZW91dChyZWZyZXNoUGxheWxpc3QsIG1zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoZW5kZWQgfHwgaXNTdGF0aWMpICYmXG4gICAgICAgICAgICAhcmVxdWVzdFF1ZXVlLnRhc2tzLmxlbmd0aCAmJiAhcmVxdWVzdFF1ZXVlLmFjdGl2ZSkge1xuICAgICAgICAgICAgc3RyZWFtLmVuZCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBsZXQgY3VyclBsYXlsaXN0O1xuICAgIGxldCBsYXN0U2VxO1xuICAgIGxldCBzdGFydHRpbWUgPSAwO1xuICAgIGNvbnN0IHJlZnJlc2hQbGF5bGlzdCA9ICgpID0+IHtcbiAgICAgICAgbGFzdFJlZnJlc2ggPSBEYXRlLm5vdygpO1xuICAgICAgICBjdXJyUGxheWxpc3QgPSBtaW5pZ2V0XzEuZGVmYXVsdChwbGF5bGlzdFVSTCwgcmVxdWVzdE9wdGlvbnMpO1xuICAgICAgICBjdXJyUGxheWxpc3Qub24oJ2Vycm9yJywgb25FcnJvcik7XG4gICAgICAgIGZvcndhcmRFdmVudHMoY3VyclBsYXlsaXN0KTtcbiAgICAgICAgY29uc3QgcGFyc2VyID0gY3VyclBsYXlsaXN0LnBpcGUobmV3IFBhcnNlcihvcHRpb25zLmlkKSk7XG4gICAgICAgIHBhcnNlci5vbignc3RhcnR0aW1lJywgKGEpID0+IHtcbiAgICAgICAgICAgIGlmIChzdGFydHRpbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGFydHRpbWUgPSBhO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmJlZ2luID09PSAnc3RyaW5nJyAmJiBiZWdpbiA+PSAwKSB7XG4gICAgICAgICAgICAgICAgYmVnaW4gKz0gc3RhcnR0aW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcGFyc2VyLm9uKCdlbmRsaXN0JywgKCkgPT4geyBpc1N0YXRpYyA9IHRydWU7IH0pO1xuICAgICAgICBwYXJzZXIub24oJ2VuZGVhcmx5JywgY3VyclBsYXlsaXN0LnVucGlwZS5iaW5kKGN1cnJQbGF5bGlzdCwgcGFyc2VyKSk7XG4gICAgICAgIGxldCBhZGRlZEl0ZW1zID0gW107XG4gICAgICAgIGNvbnN0IGFkZEl0ZW0gPSAoaXRlbSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFpdGVtLmluaXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5zZXEgPD0gbGFzdFNlcSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxhc3RTZXEgPSBpdGVtLnNlcTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJlZ2luID0gaXRlbS50aW1lO1xuICAgICAgICAgICAgcmVxdWVzdFF1ZXVlLnB1c2goaXRlbSwgb25RdWV1ZWRFbmQpO1xuICAgICAgICAgICAgYWRkZWRJdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICB9O1xuICAgICAgICBsZXQgdGFpbGVkSXRlbXMgPSBbXSwgdGFpbGVkSXRlbXNEdXJhdGlvbiA9IDA7XG4gICAgICAgIHBhcnNlci5vbignaXRlbScsIChpdGVtKSA9PiB7XG4gICAgICAgICAgICBsZXQgdGltZWRJdGVtID0gT2JqZWN0LmFzc2lnbih7IHRpbWU6IHN0YXJ0dGltZSB9LCBpdGVtKTtcbiAgICAgICAgICAgIGlmIChiZWdpbiA8PSB0aW1lZEl0ZW0udGltZSkge1xuICAgICAgICAgICAgICAgIGFkZEl0ZW0odGltZWRJdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRhaWxlZEl0ZW1zLnB1c2godGltZWRJdGVtKTtcbiAgICAgICAgICAgICAgICB0YWlsZWRJdGVtc0R1cmF0aW9uICs9IHRpbWVkSXRlbS5kdXJhdGlvbjtcbiAgICAgICAgICAgICAgICAvLyBPbmx5IGtlZXAgdGhlIGxhc3QgYGxpdmVCdWZmZXJgIG9mIGl0ZW1zLlxuICAgICAgICAgICAgICAgIHdoaWxlICh0YWlsZWRJdGVtcy5sZW5ndGggPiAxICYmXG4gICAgICAgICAgICAgICAgICAgIHRhaWxlZEl0ZW1zRHVyYXRpb24gLSB0YWlsZWRJdGVtc1swXS5kdXJhdGlvbiA+IGxpdmVCdWZmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFzdEl0ZW0gPSB0YWlsZWRJdGVtcy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICB0YWlsZWRJdGVtc0R1cmF0aW9uIC09IGxhc3RJdGVtLmR1cmF0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YXJ0dGltZSArPSB0aW1lZEl0ZW0uZHVyYXRpb247XG4gICAgICAgIH0pO1xuICAgICAgICBwYXJzZXIub24oJ2VuZCcsICgpID0+IHtcbiAgICAgICAgICAgIGN1cnJQbGF5bGlzdCA9IG51bGw7XG4gICAgICAgICAgICAvLyBJZiB3ZSBhcmUgdG9vIGFoZWFkIG9mIHRoZSBzdHJlYW0sIG1ha2Ugc3VyZSB0byBnZXQgdGhlXG4gICAgICAgICAgICAvLyBsYXRlc3QgYXZhaWxhYmxlIGl0ZW1zIHdpdGggYSBzbWFsbCBidWZmZXIuXG4gICAgICAgICAgICBpZiAoIWFkZGVkSXRlbXMubGVuZ3RoICYmIHRhaWxlZEl0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRhaWxlZEl0ZW1zLmZvckVhY2goaXRlbSA9PiB7IGFkZEl0ZW0oaXRlbSk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmVmcmVzaCB0aGUgcGxheWxpc3Qgd2hlbiByZW1haW5pbmcgc2VnbWVudHMgZ2V0IGxvdy5cbiAgICAgICAgICAgIHJlZnJlc2hUaHJlc2hvbGQgPSBNYXRoLm1heCgxLCBNYXRoLmNlaWwoYWRkZWRJdGVtcy5sZW5ndGggKiAwLjAxKSk7XG4gICAgICAgICAgICAvLyBUaHJvdHRsZSByZWZyZXNoaW5nIHRoZSBwbGF5bGlzdCBieSBsb29raW5nIGF0IHRoZSBkdXJhdGlvblxuICAgICAgICAgICAgLy8gb2YgbGl2ZSBpdGVtcyBhZGRlZCBvbiB0aGlzIHJlZnJlc2guXG4gICAgICAgICAgICBtaW5SZWZyZXNoVGltZSA9XG4gICAgICAgICAgICAgICAgYWRkZWRJdGVtcy5yZWR1Y2UoKHRvdGFsLCBpdGVtKSA9PiBpdGVtLmR1cmF0aW9uICsgdG90YWwsIDApO1xuICAgICAgICAgICAgZmV0Y2hpbmdQbGF5bGlzdCA9IGZhbHNlO1xuICAgICAgICAgICAgb25RdWV1ZWRFbmQobnVsbCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmVmcmVzaFBsYXlsaXN0KCk7XG4gICAgc3RyZWFtLmVuZCA9ICgpID0+IHtcbiAgICAgICAgZW5kZWQgPSB0cnVlO1xuICAgICAgICBzdHJlYW1RdWV1ZS5kaWUoKTtcbiAgICAgICAgcmVxdWVzdFF1ZXVlLmRpZSgpO1xuICAgICAgICBjbGVhclRpbWVvdXQocmVmcmVzaFRpbWVvdXQpO1xuICAgICAgICBjdXJyUGxheWxpc3QgPT09IG51bGwgfHwgY3VyclBsYXlsaXN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXJyUGxheWxpc3QuZGVzdHJveSgpO1xuICAgICAgICBjdXJyU2VnbWVudCA9PT0gbnVsbCB8fCBjdXJyU2VnbWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3VyclNlZ21lbnQuZGVzdHJveSgpO1xuICAgICAgICBzdHJlYW1fMS5QYXNzVGhyb3VnaC5wcm90b3R5cGUuZW5kLmNhbGwoc3RyZWFtLCBudWxsKTtcbiAgICAgICAgcmV0dXJuIHN0cmVhbTtcbiAgICB9O1xuICAgIHJldHVybiBzdHJlYW07XG59KTtcbm0zdThzdHJlYW0ucGFyc2VUaW1lc3RhbXAgPSBwYXJzZV90aW1lXzEuaHVtYW5TdHI7XG5tb2R1bGUuZXhwb3J0cyA9IG0zdThzdHJlYW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/m3u8stream/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/m3u8stream/dist/m3u8-parser.js":
/*!*****************************************************!*\
  !*** ./node_modules/m3u8stream/dist/m3u8-parser.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst stream_1 = __webpack_require__(/*! stream */ \"stream\");\n/**\n * A very simple m3u8 playlist file parser that detects tags and segments.\n */\nclass m3u8Parser extends stream_1.Writable {\n    constructor() {\n        super();\n        this._lastLine = '';\n        this._seq = 0;\n        this._nextItemDuration = null;\n        this._nextItemRange = null;\n        this._lastItemRangeEnd = 0;\n        this.on('finish', () => {\n            this._parseLine(this._lastLine);\n            this.emit('end');\n        });\n    }\n    _parseAttrList(value) {\n        let attrs = {};\n        let regex = /([A-Z0-9-]+)=(?:\"([^\"]*?)\"|([^,]*?))/g;\n        let match;\n        while ((match = regex.exec(value)) !== null) {\n            attrs[match[1]] = match[2] || match[3];\n        }\n        return attrs;\n    }\n    _parseRange(value) {\n        if (!value)\n            return null;\n        let svalue = value.split('@');\n        let start = svalue[1] ? parseInt(svalue[1]) : this._lastItemRangeEnd + 1;\n        let end = start + parseInt(svalue[0]) - 1;\n        let range = { start, end };\n        this._lastItemRangeEnd = range.end;\n        return range;\n    }\n    _parseLine(line) {\n        let match = line.match(/^#(EXT[A-Z0-9-]+)(?::(.*))?/);\n        if (match) {\n            // This is a tag.\n            const tag = match[1];\n            const value = match[2] || '';\n            switch (tag) {\n                case 'EXT-X-PROGRAM-DATE-TIME':\n                    this.emit('starttime', new Date(value).getTime());\n                    break;\n                case 'EXT-X-MEDIA-SEQUENCE':\n                    this._seq = parseInt(value);\n                    break;\n                case 'EXT-X-MAP': {\n                    let attrs = this._parseAttrList(value);\n                    if (!attrs.URI) {\n                        this.destroy(new Error('`EXT-X-MAP` found without required attribute `URI`'));\n                        return;\n                    }\n                    this.emit('item', {\n                        url: attrs.URI,\n                        seq: this._seq,\n                        init: true,\n                        duration: 0,\n                        range: this._parseRange(attrs.BYTERANGE),\n                    });\n                    break;\n                }\n                case 'EXT-X-BYTERANGE': {\n                    this._nextItemRange = this._parseRange(value);\n                    break;\n                }\n                case 'EXTINF':\n                    this._nextItemDuration =\n                        Math.round(parseFloat(value.split(',')[0]) * 1000);\n                    break;\n                case 'EXT-X-ENDLIST':\n                    this.emit('endlist');\n                    break;\n            }\n        }\n        else if (!/^#/.test(line) && line.trim()) {\n            // This is a segment\n            this.emit('item', {\n                url: line.trim(),\n                seq: this._seq++,\n                duration: this._nextItemDuration,\n                range: this._nextItemRange,\n            });\n            this._nextItemRange = null;\n        }\n    }\n    _write(chunk, encoding, callback) {\n        let lines = chunk.toString('utf8').split('\\n');\n        if (this._lastLine) {\n            lines[0] = this._lastLine + lines[0];\n        }\n        lines.forEach((line, i) => {\n            if (this.destroyed)\n                return;\n            if (i < lines.length - 1) {\n                this._parseLine(line);\n            }\n            else {\n                // Save the last line in case it has been broken up.\n                this._lastLine = line;\n            }\n        });\n        callback();\n    }\n}\nexports[\"default\"] = m3u8Parser;\n//# sourceMappingURL=m3u8-parser.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbTN1OHN0cmVhbS9kaXN0L20zdTgtcGFyc2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlCQUFpQixtQkFBTyxDQUFDLHNCQUFRO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGtCQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcYWdneW1cXE9uZURyaXZlXFxEZXNrdG9wXFxwcm9qZWN0c1xceW91dHViZV9zdW1tYXJpemVyXFxub2RlX21vZHVsZXNcXG0zdThzdHJlYW1cXGRpc3RcXG0zdTgtcGFyc2VyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3Qgc3RyZWFtXzEgPSByZXF1aXJlKFwic3RyZWFtXCIpO1xuLyoqXG4gKiBBIHZlcnkgc2ltcGxlIG0zdTggcGxheWxpc3QgZmlsZSBwYXJzZXIgdGhhdCBkZXRlY3RzIHRhZ3MgYW5kIHNlZ21lbnRzLlxuICovXG5jbGFzcyBtM3U4UGFyc2VyIGV4dGVuZHMgc3RyZWFtXzEuV3JpdGFibGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9sYXN0TGluZSA9ICcnO1xuICAgICAgICB0aGlzLl9zZXEgPSAwO1xuICAgICAgICB0aGlzLl9uZXh0SXRlbUR1cmF0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbmV4dEl0ZW1SYW5nZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX2xhc3RJdGVtUmFuZ2VFbmQgPSAwO1xuICAgICAgICB0aGlzLm9uKCdmaW5pc2gnLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9wYXJzZUxpbmUodGhpcy5fbGFzdExpbmUpO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdlbmQnKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9wYXJzZUF0dHJMaXN0KHZhbHVlKSB7XG4gICAgICAgIGxldCBhdHRycyA9IHt9O1xuICAgICAgICBsZXQgcmVnZXggPSAvKFtBLVowLTktXSspPSg/OlwiKFteXCJdKj8pXCJ8KFteLF0qPykpL2c7XG4gICAgICAgIGxldCBtYXRjaDtcbiAgICAgICAgd2hpbGUgKChtYXRjaCA9IHJlZ2V4LmV4ZWModmFsdWUpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgYXR0cnNbbWF0Y2hbMV1dID0gbWF0Y2hbMl0gfHwgbWF0Y2hbM107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF0dHJzO1xuICAgIH1cbiAgICBfcGFyc2VSYW5nZSh2YWx1ZSkge1xuICAgICAgICBpZiAoIXZhbHVlKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCBzdmFsdWUgPSB2YWx1ZS5zcGxpdCgnQCcpO1xuICAgICAgICBsZXQgc3RhcnQgPSBzdmFsdWVbMV0gPyBwYXJzZUludChzdmFsdWVbMV0pIDogdGhpcy5fbGFzdEl0ZW1SYW5nZUVuZCArIDE7XG4gICAgICAgIGxldCBlbmQgPSBzdGFydCArIHBhcnNlSW50KHN2YWx1ZVswXSkgLSAxO1xuICAgICAgICBsZXQgcmFuZ2UgPSB7IHN0YXJ0LCBlbmQgfTtcbiAgICAgICAgdGhpcy5fbGFzdEl0ZW1SYW5nZUVuZCA9IHJhbmdlLmVuZDtcbiAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgIH1cbiAgICBfcGFyc2VMaW5lKGxpbmUpIHtcbiAgICAgICAgbGV0IG1hdGNoID0gbGluZS5tYXRjaCgvXiMoRVhUW0EtWjAtOS1dKykoPzo6KC4qKSk/Lyk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgLy8gVGhpcyBpcyBhIHRhZy5cbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IG1hdGNoWzFdO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBtYXRjaFsyXSB8fCAnJztcbiAgICAgICAgICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnRVhULVgtUFJPR1JBTS1EQVRFLVRJTUUnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3N0YXJ0dGltZScsIG5ldyBEYXRlKHZhbHVlKS5nZXRUaW1lKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdFWFQtWC1NRURJQS1TRVFVRU5DRSc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NlcSA9IHBhcnNlSW50KHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnRVhULVgtTUFQJzoge1xuICAgICAgICAgICAgICAgICAgICBsZXQgYXR0cnMgPSB0aGlzLl9wYXJzZUF0dHJMaXN0KHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhdHRycy5VUkkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVzdHJveShuZXcgRXJyb3IoJ2BFWFQtWC1NQVBgIGZvdW5kIHdpdGhvdXQgcmVxdWlyZWQgYXR0cmlidXRlIGBVUklgJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnaXRlbScsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybDogYXR0cnMuVVJJLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VxOiB0aGlzLl9zZXEsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbml0OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZHVyYXRpb246IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZTogdGhpcy5fcGFyc2VSYW5nZShhdHRycy5CWVRFUkFOR0UpLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ0VYVC1YLUJZVEVSQU5HRSc6IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbmV4dEl0ZW1SYW5nZSA9IHRoaXMuX3BhcnNlUmFuZ2UodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnRVhUSU5GJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbmV4dEl0ZW1EdXJhdGlvbiA9XG4gICAgICAgICAgICAgICAgICAgICAgICBNYXRoLnJvdW5kKHBhcnNlRmxvYXQodmFsdWUuc3BsaXQoJywnKVswXSkgKiAxMDAwKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnRVhULVgtRU5ETElTVCc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZW5kbGlzdCcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghL14jLy50ZXN0KGxpbmUpICYmIGxpbmUudHJpbSgpKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIGEgc2VnbWVudFxuICAgICAgICAgICAgdGhpcy5lbWl0KCdpdGVtJywge1xuICAgICAgICAgICAgICAgIHVybDogbGluZS50cmltKCksXG4gICAgICAgICAgICAgICAgc2VxOiB0aGlzLl9zZXErKyxcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5fbmV4dEl0ZW1EdXJhdGlvbixcbiAgICAgICAgICAgICAgICByYW5nZTogdGhpcy5fbmV4dEl0ZW1SYW5nZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5fbmV4dEl0ZW1SYW5nZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3dyaXRlKGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spIHtcbiAgICAgICAgbGV0IGxpbmVzID0gY2h1bmsudG9TdHJpbmcoJ3V0ZjgnKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgIGlmICh0aGlzLl9sYXN0TGluZSkge1xuICAgICAgICAgICAgbGluZXNbMF0gPSB0aGlzLl9sYXN0TGluZSArIGxpbmVzWzBdO1xuICAgICAgICB9XG4gICAgICAgIGxpbmVzLmZvckVhY2goKGxpbmUsIGkpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAoaSA8IGxpbmVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZUxpbmUobGluZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBTYXZlIHRoZSBsYXN0IGxpbmUgaW4gY2FzZSBpdCBoYXMgYmVlbiBicm9rZW4gdXAuXG4gICAgICAgICAgICAgICAgdGhpcy5fbGFzdExpbmUgPSBsaW5lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBtM3U4UGFyc2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bTN1OC1wYXJzZXIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/m3u8stream/dist/m3u8-parser.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/m3u8stream/dist/parse-time.js":
/*!****************************************************!*\
  !*** ./node_modules/m3u8stream/dist/parse-time.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.durationStr = exports.humanStr = void 0;\nconst numberFormat = /^\\d+$/;\nconst timeFormat = /^(?:(?:(\\d+):)?(\\d{1,2}):)?(\\d{1,2})(?:\\.(\\d{3}))?$/;\nconst timeUnits = {\n    ms: 1,\n    s: 1000,\n    m: 60000,\n    h: 3600000,\n};\n/**\n * Converts human friendly time to milliseconds. Supports the format\n * 00:00:00.000 for hours, minutes, seconds, and milliseconds respectively.\n * And 0ms, 0s, 0m, 0h, and together 1m1s.\n *\n * @param {number|string} time\n * @returns {number}\n */\nexports.humanStr = (time) => {\n    if (typeof time === 'number') {\n        return time;\n    }\n    if (numberFormat.test(time)) {\n        return +time;\n    }\n    const firstFormat = timeFormat.exec(time);\n    if (firstFormat) {\n        return (+(firstFormat[1] || 0) * timeUnits.h) +\n            (+(firstFormat[2] || 0) * timeUnits.m) +\n            (+firstFormat[3] * timeUnits.s) +\n            +(firstFormat[4] || 0);\n    }\n    else {\n        let total = 0;\n        const r = /(-?\\d+)(ms|s|m|h)/g;\n        let rs;\n        while ((rs = r.exec(time)) !== null) {\n            total += +rs[1] * timeUnits[rs[2]];\n        }\n        return total;\n    }\n};\n/**\n * Parses a duration string in the form of \"123.456S\", returns milliseconds.\n *\n * @param {string} time\n * @returns {number}\n */\nexports.durationStr = (time) => {\n    let total = 0;\n    const r = /(\\d+(?:\\.\\d+)?)(S|M|H)/g;\n    let rs;\n    while ((rs = r.exec(time)) !== null) {\n        total += +rs[1] * timeUnits[rs[2].toLowerCase()];\n    }\n    return total;\n};\n//# sourceMappingURL=parse-time.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbTN1OHN0cmVhbS9kaXN0L3BhcnNlLXRpbWUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUJBQW1CLEdBQUcsZ0JBQWdCO0FBQ3RDO0FBQ0EsdUNBQXVDLElBQUksUUFBUSxJQUFJLFVBQVUsRUFBRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLGFBQWE7QUFDYjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcYWdneW1cXE9uZURyaXZlXFxEZXNrdG9wXFxwcm9qZWN0c1xceW91dHViZV9zdW1tYXJpemVyXFxub2RlX21vZHVsZXNcXG0zdThzdHJlYW1cXGRpc3RcXHBhcnNlLXRpbWUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmR1cmF0aW9uU3RyID0gZXhwb3J0cy5odW1hblN0ciA9IHZvaWQgMDtcbmNvbnN0IG51bWJlckZvcm1hdCA9IC9eXFxkKyQvO1xuY29uc3QgdGltZUZvcm1hdCA9IC9eKD86KD86KFxcZCspOik/KFxcZHsxLDJ9KTopPyhcXGR7MSwyfSkoPzpcXC4oXFxkezN9KSk/JC87XG5jb25zdCB0aW1lVW5pdHMgPSB7XG4gICAgbXM6IDEsXG4gICAgczogMTAwMCxcbiAgICBtOiA2MDAwMCxcbiAgICBoOiAzNjAwMDAwLFxufTtcbi8qKlxuICogQ29udmVydHMgaHVtYW4gZnJpZW5kbHkgdGltZSB0byBtaWxsaXNlY29uZHMuIFN1cHBvcnRzIHRoZSBmb3JtYXRcbiAqIDAwOjAwOjAwLjAwMCBmb3IgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIGFuZCBtaWxsaXNlY29uZHMgcmVzcGVjdGl2ZWx5LlxuICogQW5kIDBtcywgMHMsIDBtLCAwaCwgYW5kIHRvZ2V0aGVyIDFtMXMuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSB0aW1lXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnRzLmh1bWFuU3RyID0gKHRpbWUpID0+IHtcbiAgICBpZiAodHlwZW9mIHRpbWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiB0aW1lO1xuICAgIH1cbiAgICBpZiAobnVtYmVyRm9ybWF0LnRlc3QodGltZSkpIHtcbiAgICAgICAgcmV0dXJuICt0aW1lO1xuICAgIH1cbiAgICBjb25zdCBmaXJzdEZvcm1hdCA9IHRpbWVGb3JtYXQuZXhlYyh0aW1lKTtcbiAgICBpZiAoZmlyc3RGb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuICgrKGZpcnN0Rm9ybWF0WzFdIHx8IDApICogdGltZVVuaXRzLmgpICtcbiAgICAgICAgICAgICgrKGZpcnN0Rm9ybWF0WzJdIHx8IDApICogdGltZVVuaXRzLm0pICtcbiAgICAgICAgICAgICgrZmlyc3RGb3JtYXRbM10gKiB0aW1lVW5pdHMucykgK1xuICAgICAgICAgICAgKyhmaXJzdEZvcm1hdFs0XSB8fCAwKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCB0b3RhbCA9IDA7XG4gICAgICAgIGNvbnN0IHIgPSAvKC0/XFxkKykobXN8c3xtfGgpL2c7XG4gICAgICAgIGxldCBycztcbiAgICAgICAgd2hpbGUgKChycyA9IHIuZXhlYyh0aW1lKSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRvdGFsICs9ICtyc1sxXSAqIHRpbWVVbml0c1tyc1syXV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvdGFsO1xuICAgIH1cbn07XG4vKipcbiAqIFBhcnNlcyBhIGR1cmF0aW9uIHN0cmluZyBpbiB0aGUgZm9ybSBvZiBcIjEyMy40NTZTXCIsIHJldHVybnMgbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0aW1lXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnRzLmR1cmF0aW9uU3RyID0gKHRpbWUpID0+IHtcbiAgICBsZXQgdG90YWwgPSAwO1xuICAgIGNvbnN0IHIgPSAvKFxcZCsoPzpcXC5cXGQrKT8pKFN8TXxIKS9nO1xuICAgIGxldCBycztcbiAgICB3aGlsZSAoKHJzID0gci5leGVjKHRpbWUpKSAhPT0gbnVsbCkge1xuICAgICAgICB0b3RhbCArPSArcnNbMV0gKiB0aW1lVW5pdHNbcnNbMl0udG9Mb3dlckNhc2UoKV07XG4gICAgfVxuICAgIHJldHVybiB0b3RhbDtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJzZS10aW1lLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/m3u8stream/dist/parse-time.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/m3u8stream/dist/queue.js":
/*!***********************************************!*\
  !*** ./node_modules/m3u8stream/dist/queue.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Queue = void 0;\nclass Queue {\n    /**\n     * A really simple queue with concurrency.\n     *\n     * @param {Function} worker\n     * @param {Object} options\n     * @param {!number} options.concurrency\n     */\n    constructor(worker, options = {}) {\n        this._worker = worker;\n        this._concurrency = options.concurrency || 1;\n        this.tasks = [];\n        this.total = 0;\n        this.active = 0;\n    }\n    /**\n     * Push a task to the queue.\n     *\n     *  @param {T} item\n     *  @param {!Function} callback\n     */\n    push(item, callback) {\n        this.tasks.push({ item, callback });\n        this.total++;\n        this._next();\n    }\n    /**\n     * Process next job in queue.\n     */\n    _next() {\n        if (this.active >= this._concurrency || !this.tasks.length) {\n            return;\n        }\n        const { item, callback } = this.tasks.shift();\n        let callbackCalled = false;\n        this.active++;\n        this._worker(item, (err, result) => {\n            if (callbackCalled) {\n                return;\n            }\n            this.active--;\n            callbackCalled = true;\n            callback === null || callback === void 0 ? void 0 : callback(err, result);\n            this._next();\n        });\n    }\n    /**\n     * Stops processing queued jobs.\n     */\n    die() {\n        this.tasks = [];\n    }\n}\nexports.Queue = Queue;\n//# sourceMappingURL=queue.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbTN1OHN0cmVhbS9kaXN0L3F1ZXVlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixHQUFHO0FBQ25CLGdCQUFnQixXQUFXO0FBQzNCO0FBQ0E7QUFDQSwwQkFBMEIsZ0JBQWdCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGFnZ3ltXFxPbmVEcml2ZVxcRGVza3RvcFxccHJvamVjdHNcXHlvdXR1YmVfc3VtbWFyaXplclxcbm9kZV9tb2R1bGVzXFxtM3U4c3RyZWFtXFxkaXN0XFxxdWV1ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUXVldWUgPSB2b2lkIDA7XG5jbGFzcyBRdWV1ZSB7XG4gICAgLyoqXG4gICAgICogQSByZWFsbHkgc2ltcGxlIHF1ZXVlIHdpdGggY29uY3VycmVuY3kuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB3b3JrZXJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7IW51bWJlcn0gb3B0aW9ucy5jb25jdXJyZW5jeVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHdvcmtlciwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHRoaXMuX3dvcmtlciA9IHdvcmtlcjtcbiAgICAgICAgdGhpcy5fY29uY3VycmVuY3kgPSBvcHRpb25zLmNvbmN1cnJlbmN5IHx8IDE7XG4gICAgICAgIHRoaXMudGFza3MgPSBbXTtcbiAgICAgICAgdGhpcy50b3RhbCA9IDA7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHVzaCBhIHRhc2sgdG8gdGhlIHF1ZXVlLlxuICAgICAqXG4gICAgICogIEBwYXJhbSB7VH0gaXRlbVxuICAgICAqICBAcGFyYW0geyFGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgKi9cbiAgICBwdXNoKGl0ZW0sIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMudGFza3MucHVzaCh7IGl0ZW0sIGNhbGxiYWNrIH0pO1xuICAgICAgICB0aGlzLnRvdGFsKys7XG4gICAgICAgIHRoaXMuX25leHQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvY2VzcyBuZXh0IGpvYiBpbiBxdWV1ZS5cbiAgICAgKi9cbiAgICBfbmV4dCgpIHtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlID49IHRoaXMuX2NvbmN1cnJlbmN5IHx8ICF0aGlzLnRhc2tzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgaXRlbSwgY2FsbGJhY2sgfSA9IHRoaXMudGFza3Muc2hpZnQoKTtcbiAgICAgICAgbGV0IGNhbGxiYWNrQ2FsbGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYWN0aXZlKys7XG4gICAgICAgIHRoaXMuX3dvcmtlcihpdGVtLCAoZXJyLCByZXN1bHQpID0+IHtcbiAgICAgICAgICAgIGlmIChjYWxsYmFja0NhbGxlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYWN0aXZlLS07XG4gICAgICAgICAgICBjYWxsYmFja0NhbGxlZCA9IHRydWU7XG4gICAgICAgICAgICBjYWxsYmFjayA9PT0gbnVsbCB8fCBjYWxsYmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FsbGJhY2soZXJyLCByZXN1bHQpO1xuICAgICAgICAgICAgdGhpcy5fbmV4dCgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RvcHMgcHJvY2Vzc2luZyBxdWV1ZWQgam9icy5cbiAgICAgKi9cbiAgICBkaWUoKSB7XG4gICAgICAgIHRoaXMudGFza3MgPSBbXTtcbiAgICB9XG59XG5leHBvcnRzLlF1ZXVlID0gUXVldWU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1xdWV1ZS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/m3u8stream/dist/queue.js\n");

/***/ })

};
;
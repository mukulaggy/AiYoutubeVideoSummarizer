"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/miniget";
exports.ids = ["vendor-chunks/miniget"];
exports.modules = {

/***/ "(rsc)/./node_modules/miniget/dist/index.js":
/*!********************************************!*\
  !*** ./node_modules/miniget/dist/index.js ***!
  \********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nconst http_1 = __importDefault(__webpack_require__(/*! http */ \"http\"));\nconst https_1 = __importDefault(__webpack_require__(/*! https */ \"https\"));\nconst stream_1 = __webpack_require__(/*! stream */ \"stream\");\nconst httpLibs = { 'http:': http_1.default, 'https:': https_1.default };\nconst redirectStatusCodes = new Set([301, 302, 303, 307, 308]);\nconst retryStatusCodes = new Set([429, 503]);\n// `request`, `response`, `abort`, left out, miniget will emit these.\nconst requestEvents = ['connect', 'continue', 'information', 'socket', 'timeout', 'upgrade'];\nconst responseEvents = ['aborted'];\nMiniget.MinigetError = class MinigetError extends Error {\n    constructor(message, statusCode) {\n        super(message);\n        this.statusCode = statusCode;\n    }\n};\nMiniget.defaultOptions = {\n    maxRedirects: 10,\n    maxRetries: 2,\n    maxReconnects: 0,\n    backoff: { inc: 100, max: 10000 },\n};\nfunction Miniget(url, options = {}) {\n    var _a;\n    const opts = Object.assign({}, Miniget.defaultOptions, options);\n    const stream = new stream_1.PassThrough({ highWaterMark: opts.highWaterMark });\n    stream.destroyed = stream.aborted = false;\n    let activeRequest;\n    let activeResponse;\n    let activeDecodedStream;\n    let redirects = 0;\n    let retries = 0;\n    let retryTimeout;\n    let reconnects = 0;\n    let contentLength;\n    let acceptRanges = false;\n    let rangeStart = 0, rangeEnd;\n    let downloaded = 0;\n    // Check if this is a ranged request.\n    if ((_a = opts.headers) === null || _a === void 0 ? void 0 : _a.Range) {\n        let r = /bytes=(\\d+)-(\\d+)?/.exec(`${opts.headers.Range}`);\n        if (r) {\n            rangeStart = parseInt(r[1], 10);\n            rangeEnd = parseInt(r[2], 10);\n        }\n    }\n    // Add `Accept-Encoding` header.\n    if (opts.acceptEncoding) {\n        opts.headers = Object.assign({\n            'Accept-Encoding': Object.keys(opts.acceptEncoding).join(', '),\n        }, opts.headers);\n    }\n    const downloadHasStarted = () => activeDecodedStream && downloaded > 0;\n    const downloadComplete = () => !acceptRanges || downloaded === contentLength;\n    const reconnect = (err) => {\n        activeDecodedStream = null;\n        retries = 0;\n        let inc = opts.backoff.inc;\n        let ms = Math.min(inc, opts.backoff.max);\n        retryTimeout = setTimeout(doDownload, ms);\n        stream.emit('reconnect', reconnects, err);\n    };\n    const reconnectIfEndedEarly = (err) => {\n        if (options.method !== 'HEAD' && !downloadComplete() && reconnects++ < opts.maxReconnects) {\n            reconnect(err);\n            return true;\n        }\n        return false;\n    };\n    const retryRequest = (retryOptions) => {\n        if (stream.destroyed) {\n            return false;\n        }\n        if (downloadHasStarted()) {\n            return reconnectIfEndedEarly(retryOptions.err);\n        }\n        else if ((!retryOptions.err || retryOptions.err.message === 'ENOTFOUND') &&\n            retries++ < opts.maxRetries) {\n            let ms = retryOptions.retryAfter ||\n                Math.min(retries * opts.backoff.inc, opts.backoff.max);\n            retryTimeout = setTimeout(doDownload, ms);\n            stream.emit('retry', retries, retryOptions.err);\n            return true;\n        }\n        return false;\n    };\n    const forwardEvents = (ee, events) => {\n        for (let event of events) {\n            ee.on(event, stream.emit.bind(stream, event));\n        }\n    };\n    const doDownload = () => {\n        let parsed = {}, httpLib;\n        try {\n            let urlObj = typeof url === 'string' ? new URL(url) : url;\n            parsed = Object.assign({}, {\n                host: urlObj.host,\n                hostname: urlObj.hostname,\n                path: urlObj.pathname + urlObj.search + urlObj.hash,\n                port: urlObj.port,\n                protocol: urlObj.protocol,\n            });\n            if (urlObj.username) {\n                parsed.auth = `${urlObj.username}:${urlObj.password}`;\n            }\n            httpLib = httpLibs[String(parsed.protocol)];\n        }\n        catch (err) {\n            // Let the error be caught by the if statement below.\n        }\n        if (!httpLib) {\n            stream.emit('error', new Miniget.MinigetError(`Invalid URL: ${url}`));\n            return;\n        }\n        Object.assign(parsed, opts);\n        if (acceptRanges && downloaded > 0) {\n            let start = downloaded + rangeStart;\n            let end = rangeEnd || '';\n            parsed.headers = Object.assign({}, parsed.headers, {\n                Range: `bytes=${start}-${end}`,\n            });\n        }\n        if (opts.transform) {\n            try {\n                parsed = opts.transform(parsed);\n            }\n            catch (err) {\n                stream.emit('error', err);\n                return;\n            }\n            if (!parsed || parsed.protocol) {\n                httpLib = httpLibs[String(parsed === null || parsed === void 0 ? void 0 : parsed.protocol)];\n                if (!httpLib) {\n                    stream.emit('error', new Miniget.MinigetError('Invalid URL object from `transform` function'));\n                    return;\n                }\n            }\n        }\n        const onError = (err) => {\n            if (stream.destroyed || stream.readableEnded) {\n                return;\n            }\n            cleanup();\n            if (!retryRequest({ err })) {\n                stream.emit('error', err);\n            }\n            else {\n                activeRequest.removeListener('close', onRequestClose);\n            }\n        };\n        const onRequestClose = () => {\n            cleanup();\n            retryRequest({});\n        };\n        const cleanup = () => {\n            activeRequest.removeListener('close', onRequestClose);\n            activeResponse === null || activeResponse === void 0 ? void 0 : activeResponse.removeListener('data', onData);\n            activeDecodedStream === null || activeDecodedStream === void 0 ? void 0 : activeDecodedStream.removeListener('end', onEnd);\n        };\n        const onData = (chunk) => { downloaded += chunk.length; };\n        const onEnd = () => {\n            cleanup();\n            if (!reconnectIfEndedEarly()) {\n                stream.end();\n            }\n        };\n        activeRequest = httpLib.request(parsed, (res) => {\n            // Needed for node v10, v12.\n            // istanbul ignore next\n            if (stream.destroyed) {\n                return;\n            }\n            if (redirectStatusCodes.has(res.statusCode)) {\n                if (redirects++ >= opts.maxRedirects) {\n                    stream.emit('error', new Miniget.MinigetError('Too many redirects'));\n                }\n                else {\n                    if (res.headers.location) {\n                        url = res.headers.location;\n                    }\n                    else {\n                        let err = new Miniget.MinigetError('Redirect status code given with no location', res.statusCode);\n                        stream.emit('error', err);\n                        cleanup();\n                        return;\n                    }\n                    setTimeout(doDownload, parseInt(res.headers['retry-after'] || '0', 10) * 1000);\n                    stream.emit('redirect', url);\n                }\n                cleanup();\n                return;\n                // Check for rate limiting.\n            }\n            else if (retryStatusCodes.has(res.statusCode)) {\n                if (!retryRequest({ retryAfter: parseInt(res.headers['retry-after'] || '0', 10) })) {\n                    let err = new Miniget.MinigetError(`Status code: ${res.statusCode}`, res.statusCode);\n                    stream.emit('error', err);\n                }\n                cleanup();\n                return;\n            }\n            else if (res.statusCode && (res.statusCode < 200 || res.statusCode >= 400)) {\n                let err = new Miniget.MinigetError(`Status code: ${res.statusCode}`, res.statusCode);\n                if (res.statusCode >= 500) {\n                    onError(err);\n                }\n                else {\n                    stream.emit('error', err);\n                }\n                cleanup();\n                return;\n            }\n            activeDecodedStream = res;\n            if (opts.acceptEncoding && res.headers['content-encoding']) {\n                for (let enc of res.headers['content-encoding'].split(', ').reverse()) {\n                    let fn = opts.acceptEncoding[enc];\n                    if (fn) {\n                        activeDecodedStream = activeDecodedStream.pipe(fn());\n                        activeDecodedStream.on('error', onError);\n                    }\n                }\n            }\n            if (!contentLength) {\n                contentLength = parseInt(`${res.headers['content-length']}`, 10);\n                acceptRanges = res.headers['accept-ranges'] === 'bytes' &&\n                    contentLength > 0 && opts.maxReconnects > 0;\n            }\n            res.on('data', onData);\n            activeDecodedStream.on('end', onEnd);\n            activeDecodedStream.pipe(stream, { end: !acceptRanges });\n            activeResponse = res;\n            stream.emit('response', res);\n            res.on('error', onError);\n            forwardEvents(res, responseEvents);\n        });\n        activeRequest.on('error', onError);\n        activeRequest.on('close', onRequestClose);\n        forwardEvents(activeRequest, requestEvents);\n        if (stream.destroyed) {\n            streamDestroy(...destroyArgs);\n        }\n        stream.emit('request', activeRequest);\n        activeRequest.end();\n    };\n    stream.abort = (err) => {\n        console.warn('`MinigetStream#abort()` has been deprecated in favor of `MinigetStream#destroy()`');\n        stream.aborted = true;\n        stream.emit('abort');\n        stream.destroy(err);\n    };\n    let destroyArgs = [];\n    const streamDestroy = (err) => {\n        activeRequest.destroy(err);\n        activeDecodedStream === null || activeDecodedStream === void 0 ? void 0 : activeDecodedStream.unpipe(stream);\n        activeDecodedStream === null || activeDecodedStream === void 0 ? void 0 : activeDecodedStream.destroy();\n        clearTimeout(retryTimeout);\n    };\n    stream._destroy = (...args) => {\n        stream.destroyed = true;\n        if (activeRequest) {\n            streamDestroy(...args);\n        }\n        else {\n            destroyArgs = args;\n        }\n    };\n    stream.text = () => new Promise((resolve, reject) => {\n        let body = '';\n        stream.setEncoding('utf8');\n        stream.on('data', chunk => body += chunk);\n        stream.on('end', () => resolve(body));\n        stream.on('error', reject);\n    });\n    process.nextTick(doDownload);\n    return stream;\n}\nmodule.exports = Miniget;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbWluaWdldC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSwrQkFBK0IsbUJBQU8sQ0FBQyxrQkFBTTtBQUM3QyxnQ0FBZ0MsbUJBQU8sQ0FBQyxvQkFBTztBQUMvQyxpQkFBaUIsbUJBQU8sQ0FBQyxzQkFBUTtBQUNqQyxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxzQkFBc0I7QUFDckM7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQSxpQ0FBaUM7QUFDakMsOENBQThDLG1DQUFtQztBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLG1CQUFtQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxpQ0FBaUMsZ0JBQWdCLEdBQUcsZ0JBQWdCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLElBQUk7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDLGdDQUFnQyxNQUFNLEdBQUcsSUFBSTtBQUM3QyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsS0FBSztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyw2REFBNkQ7QUFDakcsdUVBQXVFLGVBQWU7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLGVBQWU7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qyw4QkFBOEI7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxvQkFBb0I7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxhZ2d5bVxcT25lRHJpdmVcXERlc2t0b3BcXHByb2plY3RzXFx5b3V0dWJlX3N1bW1hcml6ZXJcXG5vZGVfbW9kdWxlc1xcbWluaWdldFxcZGlzdFxcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5jb25zdCBodHRwXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImh0dHBcIikpO1xuY29uc3QgaHR0cHNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiaHR0cHNcIikpO1xuY29uc3Qgc3RyZWFtXzEgPSByZXF1aXJlKFwic3RyZWFtXCIpO1xuY29uc3QgaHR0cExpYnMgPSB7ICdodHRwOic6IGh0dHBfMS5kZWZhdWx0LCAnaHR0cHM6JzogaHR0cHNfMS5kZWZhdWx0IH07XG5jb25zdCByZWRpcmVjdFN0YXR1c0NvZGVzID0gbmV3IFNldChbMzAxLCAzMDIsIDMwMywgMzA3LCAzMDhdKTtcbmNvbnN0IHJldHJ5U3RhdHVzQ29kZXMgPSBuZXcgU2V0KFs0MjksIDUwM10pO1xuLy8gYHJlcXVlc3RgLCBgcmVzcG9uc2VgLCBgYWJvcnRgLCBsZWZ0IG91dCwgbWluaWdldCB3aWxsIGVtaXQgdGhlc2UuXG5jb25zdCByZXF1ZXN0RXZlbnRzID0gWydjb25uZWN0JywgJ2NvbnRpbnVlJywgJ2luZm9ybWF0aW9uJywgJ3NvY2tldCcsICd0aW1lb3V0JywgJ3VwZ3JhZGUnXTtcbmNvbnN0IHJlc3BvbnNlRXZlbnRzID0gWydhYm9ydGVkJ107XG5NaW5pZ2V0Lk1pbmlnZXRFcnJvciA9IGNsYXNzIE1pbmlnZXRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBzdGF0dXNDb2RlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLnN0YXR1c0NvZGUgPSBzdGF0dXNDb2RlO1xuICAgIH1cbn07XG5NaW5pZ2V0LmRlZmF1bHRPcHRpb25zID0ge1xuICAgIG1heFJlZGlyZWN0czogMTAsXG4gICAgbWF4UmV0cmllczogMixcbiAgICBtYXhSZWNvbm5lY3RzOiAwLFxuICAgIGJhY2tvZmY6IHsgaW5jOiAxMDAsIG1heDogMTAwMDAgfSxcbn07XG5mdW5jdGlvbiBNaW5pZ2V0KHVybCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IG9wdHMgPSBPYmplY3QuYXNzaWduKHt9LCBNaW5pZ2V0LmRlZmF1bHRPcHRpb25zLCBvcHRpb25zKTtcbiAgICBjb25zdCBzdHJlYW0gPSBuZXcgc3RyZWFtXzEuUGFzc1Rocm91Z2goeyBoaWdoV2F0ZXJNYXJrOiBvcHRzLmhpZ2hXYXRlck1hcmsgfSk7XG4gICAgc3RyZWFtLmRlc3Ryb3llZCA9IHN0cmVhbS5hYm9ydGVkID0gZmFsc2U7XG4gICAgbGV0IGFjdGl2ZVJlcXVlc3Q7XG4gICAgbGV0IGFjdGl2ZVJlc3BvbnNlO1xuICAgIGxldCBhY3RpdmVEZWNvZGVkU3RyZWFtO1xuICAgIGxldCByZWRpcmVjdHMgPSAwO1xuICAgIGxldCByZXRyaWVzID0gMDtcbiAgICBsZXQgcmV0cnlUaW1lb3V0O1xuICAgIGxldCByZWNvbm5lY3RzID0gMDtcbiAgICBsZXQgY29udGVudExlbmd0aDtcbiAgICBsZXQgYWNjZXB0UmFuZ2VzID0gZmFsc2U7XG4gICAgbGV0IHJhbmdlU3RhcnQgPSAwLCByYW5nZUVuZDtcbiAgICBsZXQgZG93bmxvYWRlZCA9IDA7XG4gICAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBhIHJhbmdlZCByZXF1ZXN0LlxuICAgIGlmICgoX2EgPSBvcHRzLmhlYWRlcnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5SYW5nZSkge1xuICAgICAgICBsZXQgciA9IC9ieXRlcz0oXFxkKyktKFxcZCspPy8uZXhlYyhgJHtvcHRzLmhlYWRlcnMuUmFuZ2V9YCk7XG4gICAgICAgIGlmIChyKSB7XG4gICAgICAgICAgICByYW5nZVN0YXJ0ID0gcGFyc2VJbnQoclsxXSwgMTApO1xuICAgICAgICAgICAgcmFuZ2VFbmQgPSBwYXJzZUludChyWzJdLCAxMCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQWRkIGBBY2NlcHQtRW5jb2RpbmdgIGhlYWRlci5cbiAgICBpZiAob3B0cy5hY2NlcHRFbmNvZGluZykge1xuICAgICAgICBvcHRzLmhlYWRlcnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgICdBY2NlcHQtRW5jb2RpbmcnOiBPYmplY3Qua2V5cyhvcHRzLmFjY2VwdEVuY29kaW5nKS5qb2luKCcsICcpLFxuICAgICAgICB9LCBvcHRzLmhlYWRlcnMpO1xuICAgIH1cbiAgICBjb25zdCBkb3dubG9hZEhhc1N0YXJ0ZWQgPSAoKSA9PiBhY3RpdmVEZWNvZGVkU3RyZWFtICYmIGRvd25sb2FkZWQgPiAwO1xuICAgIGNvbnN0IGRvd25sb2FkQ29tcGxldGUgPSAoKSA9PiAhYWNjZXB0UmFuZ2VzIHx8IGRvd25sb2FkZWQgPT09IGNvbnRlbnRMZW5ndGg7XG4gICAgY29uc3QgcmVjb25uZWN0ID0gKGVycikgPT4ge1xuICAgICAgICBhY3RpdmVEZWNvZGVkU3RyZWFtID0gbnVsbDtcbiAgICAgICAgcmV0cmllcyA9IDA7XG4gICAgICAgIGxldCBpbmMgPSBvcHRzLmJhY2tvZmYuaW5jO1xuICAgICAgICBsZXQgbXMgPSBNYXRoLm1pbihpbmMsIG9wdHMuYmFja29mZi5tYXgpO1xuICAgICAgICByZXRyeVRpbWVvdXQgPSBzZXRUaW1lb3V0KGRvRG93bmxvYWQsIG1zKTtcbiAgICAgICAgc3RyZWFtLmVtaXQoJ3JlY29ubmVjdCcsIHJlY29ubmVjdHMsIGVycik7XG4gICAgfTtcbiAgICBjb25zdCByZWNvbm5lY3RJZkVuZGVkRWFybHkgPSAoZXJyKSA9PiB7XG4gICAgICAgIGlmIChvcHRpb25zLm1ldGhvZCAhPT0gJ0hFQUQnICYmICFkb3dubG9hZENvbXBsZXRlKCkgJiYgcmVjb25uZWN0cysrIDwgb3B0cy5tYXhSZWNvbm5lY3RzKSB7XG4gICAgICAgICAgICByZWNvbm5lY3QoZXJyKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIGNvbnN0IHJldHJ5UmVxdWVzdCA9IChyZXRyeU9wdGlvbnMpID0+IHtcbiAgICAgICAgaWYgKHN0cmVhbS5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZG93bmxvYWRIYXNTdGFydGVkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiByZWNvbm5lY3RJZkVuZGVkRWFybHkocmV0cnlPcHRpb25zLmVycik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKCFyZXRyeU9wdGlvbnMuZXJyIHx8IHJldHJ5T3B0aW9ucy5lcnIubWVzc2FnZSA9PT0gJ0VOT1RGT1VORCcpICYmXG4gICAgICAgICAgICByZXRyaWVzKysgPCBvcHRzLm1heFJldHJpZXMpIHtcbiAgICAgICAgICAgIGxldCBtcyA9IHJldHJ5T3B0aW9ucy5yZXRyeUFmdGVyIHx8XG4gICAgICAgICAgICAgICAgTWF0aC5taW4ocmV0cmllcyAqIG9wdHMuYmFja29mZi5pbmMsIG9wdHMuYmFja29mZi5tYXgpO1xuICAgICAgICAgICAgcmV0cnlUaW1lb3V0ID0gc2V0VGltZW91dChkb0Rvd25sb2FkLCBtcyk7XG4gICAgICAgICAgICBzdHJlYW0uZW1pdCgncmV0cnknLCByZXRyaWVzLCByZXRyeU9wdGlvbnMuZXJyKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIGNvbnN0IGZvcndhcmRFdmVudHMgPSAoZWUsIGV2ZW50cykgPT4ge1xuICAgICAgICBmb3IgKGxldCBldmVudCBvZiBldmVudHMpIHtcbiAgICAgICAgICAgIGVlLm9uKGV2ZW50LCBzdHJlYW0uZW1pdC5iaW5kKHN0cmVhbSwgZXZlbnQpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgZG9Eb3dubG9hZCA9ICgpID0+IHtcbiAgICAgICAgbGV0IHBhcnNlZCA9IHt9LCBodHRwTGliO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IHVybE9iaiA9IHR5cGVvZiB1cmwgPT09ICdzdHJpbmcnID8gbmV3IFVSTCh1cmwpIDogdXJsO1xuICAgICAgICAgICAgcGFyc2VkID0gT2JqZWN0LmFzc2lnbih7fSwge1xuICAgICAgICAgICAgICAgIGhvc3Q6IHVybE9iai5ob3N0LFxuICAgICAgICAgICAgICAgIGhvc3RuYW1lOiB1cmxPYmouaG9zdG5hbWUsXG4gICAgICAgICAgICAgICAgcGF0aDogdXJsT2JqLnBhdGhuYW1lICsgdXJsT2JqLnNlYXJjaCArIHVybE9iai5oYXNoLFxuICAgICAgICAgICAgICAgIHBvcnQ6IHVybE9iai5wb3J0LFxuICAgICAgICAgICAgICAgIHByb3RvY29sOiB1cmxPYmoucHJvdG9jb2wsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh1cmxPYmoudXNlcm5hbWUpIHtcbiAgICAgICAgICAgICAgICBwYXJzZWQuYXV0aCA9IGAke3VybE9iai51c2VybmFtZX06JHt1cmxPYmoucGFzc3dvcmR9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGh0dHBMaWIgPSBodHRwTGlic1tTdHJpbmcocGFyc2VkLnByb3RvY29sKV07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgLy8gTGV0IHRoZSBlcnJvciBiZSBjYXVnaHQgYnkgdGhlIGlmIHN0YXRlbWVudCBiZWxvdy5cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWh0dHBMaWIpIHtcbiAgICAgICAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBNaW5pZ2V0Lk1pbmlnZXRFcnJvcihgSW52YWxpZCBVUkw6ICR7dXJsfWApKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuYXNzaWduKHBhcnNlZCwgb3B0cyk7XG4gICAgICAgIGlmIChhY2NlcHRSYW5nZXMgJiYgZG93bmxvYWRlZCA+IDApIHtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IGRvd25sb2FkZWQgKyByYW5nZVN0YXJ0O1xuICAgICAgICAgICAgbGV0IGVuZCA9IHJhbmdlRW5kIHx8ICcnO1xuICAgICAgICAgICAgcGFyc2VkLmhlYWRlcnMgPSBPYmplY3QuYXNzaWduKHt9LCBwYXJzZWQuaGVhZGVycywge1xuICAgICAgICAgICAgICAgIFJhbmdlOiBgYnl0ZXM9JHtzdGFydH0tJHtlbmR9YCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRzLnRyYW5zZm9ybSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwYXJzZWQgPSBvcHRzLnRyYW5zZm9ybShwYXJzZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFwYXJzZWQgfHwgcGFyc2VkLnByb3RvY29sKSB7XG4gICAgICAgICAgICAgICAgaHR0cExpYiA9IGh0dHBMaWJzW1N0cmluZyhwYXJzZWQgPT09IG51bGwgfHwgcGFyc2VkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJzZWQucHJvdG9jb2wpXTtcbiAgICAgICAgICAgICAgICBpZiAoIWh0dHBMaWIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IE1pbmlnZXQuTWluaWdldEVycm9yKCdJbnZhbGlkIFVSTCBvYmplY3QgZnJvbSBgdHJhbnNmb3JtYCBmdW5jdGlvbicpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvbkVycm9yID0gKGVycikgPT4ge1xuICAgICAgICAgICAgaWYgKHN0cmVhbS5kZXN0cm95ZWQgfHwgc3RyZWFtLnJlYWRhYmxlRW5kZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgICBpZiAoIXJldHJ5UmVxdWVzdCh7IGVyciB9KSkge1xuICAgICAgICAgICAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhY3RpdmVSZXF1ZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uUmVxdWVzdENsb3NlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgb25SZXF1ZXN0Q2xvc2UgPSAoKSA9PiB7XG4gICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgICByZXRyeVJlcXVlc3Qoe30pO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjbGVhbnVwID0gKCkgPT4ge1xuICAgICAgICAgICAgYWN0aXZlUmVxdWVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvblJlcXVlc3RDbG9zZSk7XG4gICAgICAgICAgICBhY3RpdmVSZXNwb25zZSA9PT0gbnVsbCB8fCBhY3RpdmVSZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWN0aXZlUmVzcG9uc2UucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbkRhdGEpO1xuICAgICAgICAgICAgYWN0aXZlRGVjb2RlZFN0cmVhbSA9PT0gbnVsbCB8fCBhY3RpdmVEZWNvZGVkU3RyZWFtID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhY3RpdmVEZWNvZGVkU3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbkVuZCk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG9uRGF0YSA9IChjaHVuaykgPT4geyBkb3dubG9hZGVkICs9IGNodW5rLmxlbmd0aDsgfTtcbiAgICAgICAgY29uc3Qgb25FbmQgPSAoKSA9PiB7XG4gICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgICBpZiAoIXJlY29ubmVjdElmRW5kZWRFYXJseSgpKSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtLmVuZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBhY3RpdmVSZXF1ZXN0ID0gaHR0cExpYi5yZXF1ZXN0KHBhcnNlZCwgKHJlcykgPT4ge1xuICAgICAgICAgICAgLy8gTmVlZGVkIGZvciBub2RlIHYxMCwgdjEyLlxuICAgICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgICAgIGlmIChzdHJlYW0uZGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlZGlyZWN0U3RhdHVzQ29kZXMuaGFzKHJlcy5zdGF0dXNDb2RlKSkge1xuICAgICAgICAgICAgICAgIGlmIChyZWRpcmVjdHMrKyA+PSBvcHRzLm1heFJlZGlyZWN0cykge1xuICAgICAgICAgICAgICAgICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgTWluaWdldC5NaW5pZ2V0RXJyb3IoJ1RvbyBtYW55IHJlZGlyZWN0cycpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXMuaGVhZGVycy5sb2NhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gcmVzLmhlYWRlcnMubG9jYXRpb247XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZXJyID0gbmV3IE1pbmlnZXQuTWluaWdldEVycm9yKCdSZWRpcmVjdCBzdGF0dXMgY29kZSBnaXZlbiB3aXRoIG5vIGxvY2F0aW9uJywgcmVzLnN0YXR1c0NvZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGRvRG93bmxvYWQsIHBhcnNlSW50KHJlcy5oZWFkZXJzWydyZXRyeS1hZnRlciddIHx8ICcwJywgMTApICogMTAwMCk7XG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbS5lbWl0KCdyZWRpcmVjdCcsIHVybCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIHJhdGUgbGltaXRpbmcuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyZXRyeVN0YXR1c0NvZGVzLmhhcyhyZXMuc3RhdHVzQ29kZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXJldHJ5UmVxdWVzdCh7IHJldHJ5QWZ0ZXI6IHBhcnNlSW50KHJlcy5oZWFkZXJzWydyZXRyeS1hZnRlciddIHx8ICcwJywgMTApIH0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBlcnIgPSBuZXcgTWluaWdldC5NaW5pZ2V0RXJyb3IoYFN0YXR1cyBjb2RlOiAke3Jlcy5zdGF0dXNDb2RlfWAsIHJlcy5zdGF0dXNDb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJlcy5zdGF0dXNDb2RlICYmIChyZXMuc3RhdHVzQ29kZSA8IDIwMCB8fCByZXMuc3RhdHVzQ29kZSA+PSA0MDApKSB7XG4gICAgICAgICAgICAgICAgbGV0IGVyciA9IG5ldyBNaW5pZ2V0Lk1pbmlnZXRFcnJvcihgU3RhdHVzIGNvZGU6ICR7cmVzLnN0YXR1c0NvZGV9YCwgcmVzLnN0YXR1c0NvZGUpO1xuICAgICAgICAgICAgICAgIGlmIChyZXMuc3RhdHVzQ29kZSA+PSA1MDApIHtcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFjdGl2ZURlY29kZWRTdHJlYW0gPSByZXM7XG4gICAgICAgICAgICBpZiAob3B0cy5hY2NlcHRFbmNvZGluZyAmJiByZXMuaGVhZGVyc1snY29udGVudC1lbmNvZGluZyddKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgZW5jIG9mIHJlcy5oZWFkZXJzWydjb250ZW50LWVuY29kaW5nJ10uc3BsaXQoJywgJykucmV2ZXJzZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBmbiA9IG9wdHMuYWNjZXB0RW5jb2RpbmdbZW5jXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmVEZWNvZGVkU3RyZWFtID0gYWN0aXZlRGVjb2RlZFN0cmVhbS5waXBlKGZuKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlRGVjb2RlZFN0cmVhbS5vbignZXJyb3InLCBvbkVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghY29udGVudExlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnRlbnRMZW5ndGggPSBwYXJzZUludChgJHtyZXMuaGVhZGVyc1snY29udGVudC1sZW5ndGgnXX1gLCAxMCk7XG4gICAgICAgICAgICAgICAgYWNjZXB0UmFuZ2VzID0gcmVzLmhlYWRlcnNbJ2FjY2VwdC1yYW5nZXMnXSA9PT0gJ2J5dGVzJyAmJlxuICAgICAgICAgICAgICAgICAgICBjb250ZW50TGVuZ3RoID4gMCAmJiBvcHRzLm1heFJlY29ubmVjdHMgPiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzLm9uKCdkYXRhJywgb25EYXRhKTtcbiAgICAgICAgICAgIGFjdGl2ZURlY29kZWRTdHJlYW0ub24oJ2VuZCcsIG9uRW5kKTtcbiAgICAgICAgICAgIGFjdGl2ZURlY29kZWRTdHJlYW0ucGlwZShzdHJlYW0sIHsgZW5kOiAhYWNjZXB0UmFuZ2VzIH0pO1xuICAgICAgICAgICAgYWN0aXZlUmVzcG9uc2UgPSByZXM7XG4gICAgICAgICAgICBzdHJlYW0uZW1pdCgncmVzcG9uc2UnLCByZXMpO1xuICAgICAgICAgICAgcmVzLm9uKCdlcnJvcicsIG9uRXJyb3IpO1xuICAgICAgICAgICAgZm9yd2FyZEV2ZW50cyhyZXMsIHJlc3BvbnNlRXZlbnRzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGFjdGl2ZVJlcXVlc3Qub24oJ2Vycm9yJywgb25FcnJvcik7XG4gICAgICAgIGFjdGl2ZVJlcXVlc3Qub24oJ2Nsb3NlJywgb25SZXF1ZXN0Q2xvc2UpO1xuICAgICAgICBmb3J3YXJkRXZlbnRzKGFjdGl2ZVJlcXVlc3QsIHJlcXVlc3RFdmVudHMpO1xuICAgICAgICBpZiAoc3RyZWFtLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgc3RyZWFtRGVzdHJveSguLi5kZXN0cm95QXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgc3RyZWFtLmVtaXQoJ3JlcXVlc3QnLCBhY3RpdmVSZXF1ZXN0KTtcbiAgICAgICAgYWN0aXZlUmVxdWVzdC5lbmQoKTtcbiAgICB9O1xuICAgIHN0cmVhbS5hYm9ydCA9IChlcnIpID0+IHtcbiAgICAgICAgY29uc29sZS53YXJuKCdgTWluaWdldFN0cmVhbSNhYm9ydCgpYCBoYXMgYmVlbiBkZXByZWNhdGVkIGluIGZhdm9yIG9mIGBNaW5pZ2V0U3RyZWFtI2Rlc3Ryb3koKWAnKTtcbiAgICAgICAgc3RyZWFtLmFib3J0ZWQgPSB0cnVlO1xuICAgICAgICBzdHJlYW0uZW1pdCgnYWJvcnQnKTtcbiAgICAgICAgc3RyZWFtLmRlc3Ryb3koZXJyKTtcbiAgICB9O1xuICAgIGxldCBkZXN0cm95QXJncyA9IFtdO1xuICAgIGNvbnN0IHN0cmVhbURlc3Ryb3kgPSAoZXJyKSA9PiB7XG4gICAgICAgIGFjdGl2ZVJlcXVlc3QuZGVzdHJveShlcnIpO1xuICAgICAgICBhY3RpdmVEZWNvZGVkU3RyZWFtID09PSBudWxsIHx8IGFjdGl2ZURlY29kZWRTdHJlYW0gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFjdGl2ZURlY29kZWRTdHJlYW0udW5waXBlKHN0cmVhbSk7XG4gICAgICAgIGFjdGl2ZURlY29kZWRTdHJlYW0gPT09IG51bGwgfHwgYWN0aXZlRGVjb2RlZFN0cmVhbSA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWN0aXZlRGVjb2RlZFN0cmVhbS5kZXN0cm95KCk7XG4gICAgICAgIGNsZWFyVGltZW91dChyZXRyeVRpbWVvdXQpO1xuICAgIH07XG4gICAgc3RyZWFtLl9kZXN0cm95ID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgc3RyZWFtLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgIGlmIChhY3RpdmVSZXF1ZXN0KSB7XG4gICAgICAgICAgICBzdHJlYW1EZXN0cm95KC4uLmFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVzdHJveUFyZ3MgPSBhcmdzO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBzdHJlYW0udGV4dCA9ICgpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgbGV0IGJvZHkgPSAnJztcbiAgICAgICAgc3RyZWFtLnNldEVuY29kaW5nKCd1dGY4Jyk7XG4gICAgICAgIHN0cmVhbS5vbignZGF0YScsIGNodW5rID0+IGJvZHkgKz0gY2h1bmspO1xuICAgICAgICBzdHJlYW0ub24oJ2VuZCcsICgpID0+IHJlc29sdmUoYm9keSkpO1xuICAgICAgICBzdHJlYW0ub24oJ2Vycm9yJywgcmVqZWN0KTtcbiAgICB9KTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGRvRG93bmxvYWQpO1xuICAgIHJldHVybiBzdHJlYW07XG59XG5tb2R1bGUuZXhwb3J0cyA9IE1pbmlnZXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/miniget/dist/index.js\n");

/***/ })

};
;